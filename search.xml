<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Kotlin Contracts DSL</title>
      <link href="/2018/03/25/kotlin-contracts-dsl/"/>
      <url>/2018/03/25/kotlin-contracts-dsl/</url>
      <content type="html"><![CDATA[<p>从 Kotlin 1.2 版本开始，如果你查看 <code>apply</code>、<code>let</code> 等函数的源码，你会发现比 1.1 版本多了几行不明觉厉的代码<a id="more"></a>：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> T<span class="token punctuation">.</span><span class="token function">let</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> R<span class="token punctuation">)</span><span class="token operator">:</span> R <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// kotlin 1.2 加了下面三行代码</span>   contract <span class="token punctuation">{</span>      <span class="token function">callsInPlace</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> InvocationKind<span class="token punctuation">.</span>EXACTLY_ONCE<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// kotlin 1.2 加了上面三行代码</span>   <span class="token keyword">return</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>很好，接下来就讲讲那几行多出来的代码到底有什么用。</p><h2 id="简单的需求"><a href="#简单的需求" class="headerlink" title="简单的需求"></a>简单的需求</h2><p>假设我们有这样一段代码，Kotlin 版本为 1.2.31：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> text<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      text <span class="token operator">=</span> <span class="token string">"我永远喜欢燕结芽"</span>   <span class="token punctuation">}</span>   <span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// error, cannot smart cast to String</span><span class="token punctuation">}</span></code></pre><p>稍微有点常识的人都知道，在最后一行代码使用 <code>text</code> 的时候 <code>text</code> 不可能为 <code>null</code>。</p><p>但是编译器并不喜欢按常理出牌，向你丢出了一个编译错误：Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?</p><p>原因在于编译器不能深入分析每个函数（在这个例子中是 <code>isNullOrEmpty</code>）的数据流，无法得知「<code>test</code> 不为空」的事实，也就无法进行 Smart Cast 了。</p><p>所以如果要享受到 Smart Cast 的便利的话，可以手动将 <code>isNullOrEmpty</code> 内联展开：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">if</span><span class="token punctuation">(</span>text <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> text<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   text <span class="token operator">=</span> <span class="token string">"我永远喜欢燕结芽"</span><span class="token punctuation">}</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ok, smart cast to String</span></code></pre><p>为了解决这个问题，于是就有了 Contracts DSL。</p><h2 id="Contracts-DSL"><a href="#Contracts-DSL" class="headerlink" title="Contracts DSL"></a>Contracts DSL</h2><p>Contracts DSL 可以为编译器提供关于函数行为的附加信息，帮助编译器分析函数的实际运行情况。</p><p>我们可以查看一下 isNullOrEmpty 的源码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> CharSequence<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{</span>   contract <span class="token punctuation">{</span>      <span class="token function">returns</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token function">implies</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token label symbol">@isNullOrEmpty</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">}</span></code></pre><p>你可以看到 <code>contract</code> 代码块里面的那行代码，表示「如果返回值为<code>false</code>，那么<code>this</code>（函数的接收者）不为<code>null</code>」。</p><p>因为这个东西目前还是个实验性特性，处于内部评估的状态，尚未对外公开发布，所以是默认关闭的。</p><p>为了开启这个特性，我们需要给编译器传入提供额外的编译参数：<code>-Xeffect-system</code> 和 <code>-Xread-deserialized-contracts</code>。然后下面的代码就能够正常通过编译：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> str<span class="token operator">:</span> String<span class="token operator">?</span>   <span class="token comment" spellcheck="true">// captured value initialization is forbidden due to possible reassignment</span>   run <span class="token punctuation">{</span> str <span class="token operator">=</span> <span class="token string">"でないと、私のすごいとこ 見せられないじゃん"</span> <span class="token punctuation">}</span>   <span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// str not initialized</span>   <span class="token keyword">val</span> notNull1<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> str   <span class="token function">requireNotNull</span><span class="token punctuation">(</span>notNull1<span class="token punctuation">)</span>   <span class="token function">println</span><span class="token punctuation">(</span>notNull1<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cannot smart cast to Any</span>   <span class="token keyword">val</span> notNull2<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> str   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>notNull2<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">println</span><span class="token punctuation">(</span>notNull2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cannot smart cast to String</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>虽然在 IDEA 里这些代码仍然会被标上红色下划线表示有错，但是加上编译器参数后的确能通过编译。</p><p>就拿上面例子的 <code>run</code> 函数说起，看看源码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token operator">></span> <span class="token function">run</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> R<span class="token punctuation">)</span><span class="token operator">:</span> R <span class="token punctuation">{</span>   contract <span class="token punctuation">{</span>      <span class="token function">callsInPlace</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> InvocationKind<span class="token punctuation">.</span>EXACTLY_ONCE<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>编译器可以知道「传入的 lambda 会立即在“原地”执行有且仅有一次」，那么 <code>str</code> 一定会被初始化，而且不会被重新赋值。编译通过！</p><p>现在 Contracts DSL 位于 <code>kotlin.internal.contracts</code> 这个包内，是 <code>internal</code> 的，一般用户还无法直接拿来写自己的 contract，等JB那帮人把这个功能做好了就能用了。</p><h3 id="跑个题"><a href="#跑个题" class="headerlink" title="跑个题"></a>跑个题</h3><p>JetBrains 注解库有个 <code>@Contract</code> 可以实现类似的功能。虽然这个功能是 IDEA 提供的，不是 javac 的功能，并不能阻止错误的代码通过编译，不过总比没有强（逃</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaMain</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Contract</span><span class="token punctuation">(</span><span class="token string">"null->true"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> CharSequence cs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cs <span class="token operator">==</span> null <span class="token operator">||</span> cs<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> KotlinMainKt<span class="token punctuation">.</span><span class="token function">getNullableString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// IDEA提示：调用 hashCode 可能会产生 NullPointerException</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// IDEA提示：condition `b` is always true</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"でないと、私のすごいとこ 見せられないじゃん"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么我不用 Gradle Kotlin DSL</title>
      <link href="/2018/02/26/why-not-gradle-kts-dsl/"/>
      <url>/2018/02/26/why-not-gradle-kts-dsl/</url>
      <content type="html"><![CDATA[<p>一图流。</p><p>Groovy：优雅，简洁，美观！</p><img src="/2018/02/26/why-not-gradle-kts-dsl/20180226191232.jpg" title="Groovy"><p>Kotlin DSL：你看看这何等鬼畜的用法！</p><img src="/2018/02/26/why-not-gradle-kts-dsl/20180226191238.jpg" title="Kotlin"><a id="more"></a>]]></content>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin协程 - 先入个门吧</title>
      <link href="/2018/02/08/kotlin-coroutine-kepa/"/>
      <url>/2018/02/08/kotlin-coroutine-kepa/</url>
      <content type="html"><![CDATA[<p>你们要的协程文，嗯。封面图id：66548341。<a id="more"></a></p><p>因为是入门嘛，所以本文保证不会出现任何与 <a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener">kotlinx.coroutines</a> 相关的内容。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话说为什么我要在已经有辣么多篇优秀的协程文的情况下再水一篇呢？因为我太鶸了，bennyhuo的<a href="https://blog.kotliner.cn/2017/01/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Kotlin%20Coroutine/" target="_blank" rel="noopener">那篇文章</a>根本看不懂，一开始上来就抛出一堆难以理解的专业名词，比如线程、Lua、CoroutineContext 等等，再加上那一堆根本看不懂的 Lua 代码以及 UML 类图，萌新一脸懵逼，直接被劝退，根本不留情面。所以我决定自己写一篇（自己能看懂的），就酱。</p><p>本水文不保证其他读者能看懂！（逃</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote><p>Kotlin 1.1 的关键新特性是<em>协程</em>，它带来了 <code>future</code>/<code>await</code>、 <code>yield</code> 以及类似的编程模式的支持。Kotlin 的设计中的关键特性是协程执行的实现是语言库的一部分，而不是语言的一部分，所以你不必绑定任何特定的编程范式或并发库。</p></blockquote><p>为了不让内容太过单薄，抄了一段Kotlin中文网上的<a href="https://www.kotlincn.net/docs/reference/whatsnew11.html" target="_blank" rel="noopener">翻译</a>（逃</p><h3 id="suspend-关键字"><a href="#suspend-关键字" class="headerlink" title="suspend 关键字"></a>suspend 关键字</h3><p>Kotlin在1.1版本新增加了 <code>suspend</code> 关键字，可以用来修饰函数或者 lambda 表达式的类型：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ↑ 你看这辣鸡代码高亮 ↓</span><span class="token keyword">val</span> suspendLambda<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 你需要显式写出这个suspend lambda的类型，不然其类型会推导成普通的lambda而不是suspend lambda</span></code></pre><p>然后你得到了一个 suspend 函数和 suspend lambda。被标记为 <code>suspend</code> 的函数只能在 suspend 函数或 suspend lambda 中被调用。</p><p>Kotlin 1.2.30 版本提供了一个更简单的方法来声明无参数的 suspend lambda，不用显式写出类型了：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin 1.2.30 以后才能这样写</span><span class="token keyword">val</span> suspendLambda <span class="token operator">=</span> suspend <span class="token punctuation">{</span>    <span class="token string">"Hello world!"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// suspendLambda 的类型将被自动推导为 suspend () -> String</span></code></pre><p>PS：Kotlin 将在下次大更新（可能是 1.3）时让 suspend 关键字能够修饰 lambda 表达式，使之称为一个 suspend lambda，就像上面代码里的那样。但是 Kotlin 团队的那帮人根本就没有耐心，决定在 Kotlin 1.2.30 版本（小更新）就引入这个特性，但是又不想引入 breaking change，于是折中了一下，往标准库里加入了一个辅助函数，等到大版本更新正式加入这个功能时再移除这个函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>internal<span class="token punctuation">.</span>InlineOnly<span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token operator">></span> <span class="token function">suspend</span><span class="token punctuation">(</span><span class="token keyword">noinline</span> block<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> R<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> R <span class="token operator">=</span> block</code></pre><p>因为计划中这是要成为一个修饰符的，所以编译器会禁止那些看起来不像是修饰符的用法（non-modifier-like usages）：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token label symbol">@suspend</span> <span class="token string">"1551"</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 不允许 return@suspend，编译错误！</span>suspend <span class="token label symbol">poi@</span> <span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token label symbol">@poi</span> <span class="token string">"1551"</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 这是好的！</span><span class="token operator">::</span>suspend <span class="token comment" spellcheck="true">// 禁止函数引用，编译错误！</span></code></pre><p>因为是个折衷的版本嘛，所以目前只适用于声明无参 suspend lambda，等下个大版本真正成为一个 lambda 的修饰符的时候，就能适用于有参数的 lambda 了。</p><h3 id="创建和启动协程"><a href="#创建和启动协程" class="headerlink" title="创建和启动协程"></a>创建和启动协程</h3><p>创建并启动一个协程十分简单，你只需要两件宝具：一个 <em>suspend lambda</em>，以及一个 <em>Continuation</em>：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span><span class="token operator">*</span><span class="token keyword">val</span> suspendLambda<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> String <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"Hello world!"</span><span class="token punctuation">}</span><span class="token keyword">val</span> completion <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> context <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> EmptyCoroutineContext    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resume</span><span class="token punctuation">(</span>value<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWithException</span><span class="token punctuation">(</span>exception<span class="token operator">:</span> Throwable<span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token keyword">throw</span> exception<span class="token punctuation">}</span></code></pre><p>使用 Kotlin 标准库中的 <code>createCoroutine</code> 函数来创建协程：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> coroutine<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token operator">=</span> suspendLambda<span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span>completion<span class="token punctuation">)</span></code></pre><p>然后调用 <code>resume</code> 方法启动这个协程：</p><pre class=" language-kotlin"><code class="language-kotlin">coroutine<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印出 Hello world!</span></code></pre><p>或者使用标准库里的 <code>startCoroutine</code> 函数来创建并立即启动一个协程：</p><pre class=" language-kotlin"><code class="language-kotlin">suspendLambda<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>completion<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印出 Hello world!</span></code></pre><p>很简单。另外对于有带接收者的 suspend lambda，有与之相对应的库函数。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span>completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">(</span>suspend R<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span>receiver<span class="token operator">:</span> R<span class="token punctuation">,</span> completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Unit<span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">(</span>suspend R<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>receiver<span class="token operator">:</span> R<span class="token punctuation">,</span> completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Unit</code></pre><h3 id="协程挂起和恢复执行"><a href="#协程挂起和恢复执行" class="headerlink" title="协程挂起和恢复执行"></a>协程挂起和恢复执行</h3><p>想要暂停一个协程的执行，可以使用标准库里面的 <code>suspendCoroutine</code> 函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> suspendLambda<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before suspend"</span><span class="token punctuation">)</span>    suspendCoroutine<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after suspend"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>suspendLambda<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Any<span class="token operator">></span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 只输出 before suspend</span></code></pre><p>如果需要恢复协程，例如等待3秒后继续执行：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> suspendLambda<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before suspend"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> int<span class="token operator">:</span> Int <span class="token operator">=</span> suspendCoroutine <span class="token punctuation">{</span> c <span class="token operator">-></span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token number">1551</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after suspend, resume with <span class="token interpolation variable">$int</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>suspendLambda<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Any<span class="token operator">></span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 输出（两行输出间隔3秒）：</span><span class="token comment" spellcheck="true">// before suspend</span><span class="token comment" spellcheck="true">// after suspend, resume with 1551</span></code></pre><p><code>suspendCoroutine</code> 函数的签名如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> suspend <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suspendCoroutine</span><span class="token punctuation">(</span><span class="token keyword">crossinline</span> block<span class="token operator">:</span> <span class="token punctuation">(</span>Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> T</code></pre><p>如果你知道这上面的各段代码里面究竟发生了什么，那太棒了，你不需要浪费时间阅读这篇辣鸡水文，请点击右上角的关闭按钮。</p><h2 id="概念摘出：Continuation"><a href="#概念摘出：Continuation" class="headerlink" title="概念摘出：Continuation"></a>概念摘出：Continuation</h2><p>Continuation（续延）究竟是一个什么概念？一般来讲，Continuation 表示的是「剩余的计算」的概念，换句话说就是「接下来要执行的代码」。举个例子来说，假设我们有这样一段代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1551</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span></code></pre><p>我们知道这段代码会先执行 <code>1551.toString()</code>，然后再执行 <code>_.length</code>，最后将结果打印出来 <code>println(_)</code>。</p><p>当 <code>1551.toString()</code> 求值之后，需要将其结果传递至 <code>println(_.length)</code>。我们可以将 <code>println(_.length)</code> 写成一个 lambda 表达式：<code>{ s: String -&gt; println(s.length) }</code>。这个 lambda 表达式（或者说是闭包）表示的就是 <code>1551.toString()</code> 的 Continuation，即「剩余的计算」。</p><p>这样，我们就可以通过把 <code>1551.toString()</code> 应用到这个lambda来重新构建原来的形式：<code>{ s: String -&gt; println(s.length) }.invoke(1551.toString())</code>。换句话说，执行该 lambda 表达式的 <code>invoke</code> 方法以执行「剩余的计算」。</p><p>那么 <code>1551.toString().length</code> 的 Continuation 又是什么呢？很简单，是 <code>{ i: Int -&gt; println(i) }</code>。</p><p>以上讲的就是 Continuation 的一般概念。Kotlin 里面的 Continuation 长什么样子？大概像这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> context<span class="token operator">:</span> CoroutineContext   <span class="token keyword">fun</span> <span class="token function">resume</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span>   <span class="token keyword">fun</span> <span class="token function">resumeWithException</span><span class="token punctuation">(</span>exception<span class="token operator">:</span> Throwable<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这不就跟上面的 lambd 表达式很像嘛，Continuation接口的 <code>resume</code> 就相当与 lambda 表达式的 <code>invoke</code> ，所以当你拿到一个 Continuation 时，<code>resume</code> 方法即是「剩余的计算」的入口。</p><p>上文基本操作的例子中，<code>createCoroutine</code> 函数接受一个 Contiuation 参数 completion，表示「协程执行完之后要执行的代码」。而 <code>createCoroutine</code> 的接收者 suspendLambda 则是协程的主要部分。<code>createCoroutine</code> 函数把这两个东西搓成一个表示「整个协程所有需要执行的代码」的 Contiuation，称为初始 Continuation（initial continuation）。当 suspendLambda 执行完毕后，将其结果传至 completion 的 <code>resume</code> 方法；若 suspendLambda 的执行过程中抛出了异常，则走 completion 的 <code>resumeWithException</code> 方法。</p><p>再看上文 <code>suspendCoroutine</code> 函数的例子：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> suspendLambda<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before suspend"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> int<span class="token operator">:</span> Int <span class="token operator">=</span> suspendCoroutine <span class="token punctuation">{</span> c <span class="token operator">-></span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token number">1551</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after suspend, resume with <span class="token interpolation variable">$int</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>suspendCoroutine</code> 函数接收一个lambda表达式作为参数，这个 lambda 的 Continuation 参数即是表示「协程挂起后剩下的还没执行的代码」。在这个例子中，表示的是 <code>{ i: Int -&gt; val int = i; println(&quot;after suspend, resume with $int&quot;) }</code>。调用<code>resume</code>方法将这个协程继续执行下去，<code>suspendCoroutine</code> 的返回值即是通过 <code>resume</code> 方法传入的值（本例中为<code>1551</code>），于是变量<code>int</code>得到值<code>1551</code>。</p><p>超简单~！</p><h2 id="编译器的魔术"><a href="#编译器的魔术" class="headerlink" title="编译器的魔术"></a>编译器的魔术</h2><blockquote><p><strong>「别逗我了。那种东西怎么会是魔法！」</strong></p></blockquote><p>那么 Kotlin 的协程是怎么实现的呢？</p><p>协程完全通过编译技术实现（不需要来自 VM 或 OS 端的支持），挂起通过代码来生效。（本句话抄自 Kotlin 中文网）</p><h3 id="CPS-转换"><a href="#CPS-转换" class="headerlink" title="CPS 转换"></a>CPS 转换</h3><blockquote><p>「CPST 就是 Gödel–Gentzen 变换的 Curry–Howard 像而已，这有什么难理解的？」</p></blockquote><p>在编译时，suspend 函数会被编译器加上一个 Continuation 参数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 编译前</span>suspend <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> U<span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 编译后</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> U<span class="token punctuation">,</span> c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> String<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span></code></pre><p>这叫做 CPS 转换（Continuation-Passing-Style transformation）。</p><p>可以认为每个 suspend 函数都有一个隐式参数，每个 suspend 函数都能通过这个参数拿到一个 Continuation，代表着「该函数之后将要执行的代码」。</p><p>PS：<code>suspendFunction</code> 经过CPS转换后，返回值的那个 <code>Any?</code> 其实是个类似于 union types（并集类型）的玩意。它其实是 <code>T | COROUTINE_SUSPENDED</code>，表示返回值可能为 <code>T</code> 类型的值，也可能是个 <code>COROUTINE_SUSPENDED</code>。但是辣鸡 Kotlin 没有 union types，所以只能写成 <code>Any?</code>，使用的时候再做类型强转。（看看人家 <a href="http://dotty.epfl.ch/docs/reference/union-types.html" target="_blank" rel="noopener">Scala</a> 和 <a href="https://ceylon-lang.org/documentation/1.3/tour/types/#union_types" target="_blank" rel="noopener">Ceylon</a> ，做得多好）</p><p>PPS：如果你喜欢翻看源码，你会发现在 Kotlin 标准库的协程部分以及 <a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener">kotlinx.coroutines</a> 里面能经常见到这种用 <code>Any?</code> 表示的 union types。</p><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>我们知道 Continuation 就相当于一个闭包，经过 CPS 转换，每次调用 suspend 函数都需要传一个 Continuation 进去。为了避免创建过多的闭包和匿名类，Kotlin 选择使用<strong>状态机</strong>（state machines）来实现 Continuation。</p><p>由于懒，我直接把官方的非正式文档里面的例子抄了过来：</p><p>suspend 函数会被编译成一个状态机，例如一个 suspend 函数里有以下代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> y <span class="token operator">=</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 挂起点 1</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> z <span class="token operator">=</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 挂起点 2</span><span class="token function">c</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span></code></pre><p>其中的2个 suspend 函数调用点（简称挂起点，suspension point）将这段代码分成3个状态：</p><p>状态0：第一个挂起点之前（初始状态）</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></code></pre><p>状态1：第一个挂起点之后，至第二个挂起点之前</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> y <span class="token operator">=</span> _<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">bar</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> y<span class="token punctuation">)</span></code></pre><p>状态2：第二个挂起点之后</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> z <span class="token operator">=</span> _<span class="token function">c</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span></code></pre><p>代码会被编译成一个匿名类，它具有一个实现状态机的方法，一个保存状态机当前状态的字段，以及各个状态的局部变量的字段，看起来像这样：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 伪代码，简化模型，实际情况会比这个要复杂一些</span><span class="token keyword">class</span> 状态机匿名类 <span class="token keyword">extends</span> <span class="token class-name">CoroutineImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Continuation</span><span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这个int用来保存状态机当前的状态</span>    <span class="token keyword">int</span> label <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">// 用来保存suspend方法中的局部变量</span>    A a <span class="token operator">=</span> null    Y y <span class="token operator">=</span> null    <span class="token comment" spellcheck="true">// 实现状态机的方法</span>    <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span>Object data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>label <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> L0        <span class="token keyword">if</span> <span class="token punctuation">(</span>label <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> L1        <span class="token keyword">if</span> <span class="token punctuation">(</span>label <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> L2        <span class="token keyword">else</span> <span class="token keyword">throw</span> <span class="token function">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 英文不翻译了，懒~</span>      L0<span class="token operator">:</span>        <span class="token comment" spellcheck="true">// data is expected to be `null` at this invocation</span>        a <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        label <span class="token operator">=</span> <span class="token number">1</span>        data <span class="token operator">=</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'this' is passed as a continuation </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> COROUTINE_SUSPENDED<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// return if suspendFunction had suspended execution</span>      L1<span class="token operator">:</span>        <span class="token comment" spellcheck="true">// external code has resumed this coroutine passing the result of suspendFunction() as data </span>        y <span class="token operator">=</span> <span class="token punctuation">(</span>Y<span class="token punctuation">)</span> data        <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        label <span class="token operator">=</span> <span class="token number">2</span>        data <span class="token operator">=</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'this' is passed as a continuation</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> COROUTINE_SUSPENDED<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// return if suspendFunction had suspended execution</span>      L2<span class="token operator">:</span>        <span class="token comment" spellcheck="true">// external code has resumed this coroutine passing the result of suspendFunction() as data </span>        Z z <span class="token operator">=</span> <span class="token punctuation">(</span>Z<span class="token punctuation">)</span> data        <span class="token function">c</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span>        label <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true">// No more steps are allowed</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>各位读者自行体会，我懒得解释了。</p><p>我们可以看到每次调用 suspendFunction 时，传进去的 Continuation 都是同一个对象，即状态机本身；并且通过 label 来控制状态和代码跳转，使其符合「剩下的计算」的语义。</p><p>PS：并不是所有的 suspend 函数都会编译成一个状态机，存在一种尾调用优化（tail call optimization）的机制。举个例子：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do something before calling f2"</span><span class="token punctuation">)</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// &lt;==这里</span><span class="token punctuation">}</span>suspend <span class="token keyword">fun</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span></code></pre><p>f1函数内部唯一的一个 suspend 调用是在函数尾部的位置（即 tail suspension invocation），这时不会编译成状态机，而是这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">f1</span><span class="token punctuation">(</span>c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> Unit<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do something before calling f2"</span><span class="token punctuation">)</span>    <span class="token function">f2</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">f2</span><span class="token punctuation">(</span>c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> Unit<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span></code></pre><p>即尾调用优化。（亲爱的读者可以思考一下为什么可以这么做）</p><p>PPS：在 Kotlin 1.2.30 之前的版本中（不包括 1.2.30），上面的代码并不会发生尾调用优化，你需要这样：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do something before calling f2"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里必须写 return</span><span class="token punctuation">}</span>suspend <span class="token keyword">fun</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span></code></pre><p>显式地写成 <code>return f2()</code> 才能有尾调用优化。</p><h3 id="伪・Call-CC"><a href="#伪・Call-CC" class="headerlink" title="伪・Call/CC"></a>伪・Call/CC</h3><p>前面提到，每个 suspend 函数都有一个隐式的 Continuation 参数（由编译器在编译时添加），但是我们在代码里是看不到这个参数的，我们要怎么样才能拿到这个参数呢？</p><p>Kotlin 厚颜无耻地把 Scheme 的 Call/CC（call-with-current-continuation）抄了过来并加以魔改，放在 <code>kotlin.coroutines.experimental.intrinsics</code> 这个包里，就是这玩意：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> suspend <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suspendCoroutineOrReturn</span><span class="token punctuation">(</span><span class="token keyword">crossinline</span> block<span class="token operator">:</span> <span class="token punctuation">(</span>Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> T</code></pre><p>这个函数是 Kotlin 协程库中最重要的函数。在 Kotlin1.1 版本里，这个函数是个固有函数（intrinsic function，即编译器特殊对待的函数），如果你去看了它的源码（Kotlin1.1 版本），你会看到类似与这样的东西：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> suspend <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suspendCoroutineOrReturn</span><span class="token punctuation">(</span><span class="token keyword">crossinline</span> block<span class="token operator">:</span> <span class="token punctuation">(</span>Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span>        <span class="token keyword">throw</span> <span class="token function">NotImplementedError</span><span class="token punctuation">(</span><span class="token string">"Implementation is intrinsic"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 或者可能是一个 `null!!`</span></code></pre><p>流石固有函数。在经过 CPS 转换后，我们来看一下这个函数的真面目：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suspendCoroutineOrReturn</span><span class="token punctuation">(</span><span class="token keyword">crossinline</span> block<span class="token operator">:</span> <span class="token punctuation">(</span>Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token operator">?</span><span class="token punctuation">,</span>                                        c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">block</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span></code></pre><p>简单明了，直接将这个 Continuation 参数传给了 lambda，我们就可以通过这个 lambda 参数来操纵由 CPS 转换得来的 Continuation 。</p><p>上文讲过，这个返回值 Any? 其实是 <code>T | COROUTINE_SUSPENDED</code> ，<code>COROUTINE_SUSPENDED</code> 的定义也在这个包里：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> COROUTINE_SUSPENDED<span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>太简单了。从上文的那个状态机伪代码里面可以看到，对于每个 suspend 函数的调用，都会检查其返回值是不是 <code>COROUTINE_SUSPENDED</code>。如果不是，那么状态机就开始执行下一个状态的代码；如果是 <code>COROUTINE_SUSPENDED</code>，就直接返回，停止执行代码，即协程挂起。可以写个demo来验证一下：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> suspendCoroutineOrReturn <span class="token punctuation">{</span> c <span class="token operator">-></span>    COROUTINE_SUSPENDED<span class="token punctuation">}</span><span class="token keyword">val</span> suspendLambda<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before suspend"</span><span class="token punctuation">)</span>    <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after suspend"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>suspendLambda<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Any<span class="token operator">></span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>结果只有 before suspend 被打印了出来。如果要继续执行下去，则需要调用其 <code>resume</code> 方法：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> suspendCoroutineOrReturn <span class="token punctuation">{</span> c <span class="token operator">-></span>    thread <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5_000<span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    COROUTINE_SUSPENDED<span class="token punctuation">}</span></code></pre><p>这时候我们可以看到，before suspend 先被打印出来，5秒种后，after suspend 再被打印出来。</p><p>f3函数经过 CPS 转换、suspend 函数的尾调用优化以及 <code>suspendCoroutineOrReturn</code> 的内联，最终会变成如下的样子：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">f3</span><span class="token punctuation">(</span>c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>    thread <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//  ↑ 这个Any?其实是 ↓</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5_000<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//       Unit | COROUTINE_SUSPENDED</span>        c<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> COROUTINE_SUSPENDED<span class="token punctuation">}</span></code></pre><p>看起来就像是在直接操纵附加的 Continuation 参数。</p><p>本节比较长，给个小结：<code>suspendCoroutineOrReturn</code> 能够让你直接操纵通过CPS转换得来的 Continuation 参数，这个函数接收一个 lambda 参数。在这个 lambda 里面，你将面临两种选择：直接返回需要的结果（不挂起协程）或者返回 <code>COROUTINE_SUSPENDED</code>（挂起协程）。如果你选择挂起协程，你需要在合适的地方与时机调用（从lambda的参数得到的）Continuation 的 <code>resume</code> 方法将需要的结果传入以便继续执行协程。</p><p>Kotlin 标准库里面的 <code>suspendCoroutine</code> 即是对 <code>suspendCoroutineOrReturn</code> 的封装，使其更易于使用。读者可以对比一下两者的函数签名以及文档上的注意事项。一般情况下使用 <code>suspendCoroutine</code> 即可满足需求。</p><p>PS：不知道从什么时候开始的，<code>kotlin.coroutines.experimental.intrinsics</code> 这个包以及里面的所有东西，都被Intellij IDEA的自动补全屏蔽了。你需要手动import这个包，里面的东西才能出现在自动补全的列表里。</p><p>PPS：在 Kotlin1.2 版本中，suspendCoroutineOrReturn 不再是一个固有函数，其实现由两个新的固有函数组成，但是不影响使用。（拆东墙补西墙）</p><p>PPPS：本文完。</p><h2 id="你学到了什么"><a href="#你学到了什么" class="headerlink" title="你学到了什么"></a>你学到了什么</h2><ul><li>Kotlin 协程的（不）常用的标准库函数的使用方法</li><li>编译器都做了什么事（的一部分）</li><li><code>suspendCoroutineOrReturn</code>有什么用</li></ul><p>下一篇协程文？不存在的。</p><p>课后作业：Codewars上面的<a href="https://www.codewars.com/kata/tricky-kotlin-number-8-simple-for-comprehension" target="_blank" rel="noopener">一道题</a>，要求实现简单的控制流，很简单。如果你能看懂这篇文章，那么这道题对于你来说应该是十分简单的。（冰封julao仅用了不到十分钟的时间就做出来了）</p><p>反编译Tip：Intellij IDEA的Kotlin插件有将Kotlin代码反编译至Java的功能，但是在面对协程相关的代码时大多数情况下都不好用。请不要想太多，老老实实用其他反编译工具，我用的是这个<a href="https://github.com/skylot/jadx" target="_blank" rel="noopener">jadx</a>，版本0.6.1。</p>]]></content>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Coroutine </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin的一些技巧和迂回操作</title>
      <link href="/2018/01/07/kotlin-jiqiao/"/>
      <url>/2018/01/07/kotlin-jiqiao/</url>
      <content type="html"><![CDATA[<p>RT，不定期更新。</p><h2 id="递归的-Lambda-表达式"><a href="#递归的-Lambda-表达式" class="headerlink" title="递归的 Lambda 表达式"></a>递归的 Lambda 表达式</h2><a id="more"></a><p>刚才在某个 Kotlin 裙里看到有人在问：</p><blockquote><p>是不是lambda无法递归</p></blockquote><p>举个例子，我们可以写一个简单的递归函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1551"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印出很多1551</span></code></pre><p>如果要写成 Lambda 呢？这样的代码会报错：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> a<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1551"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>我们自然是不能直接写这样的代码的，它会说 <code>a</code> 没有定义。解决方法当然是使用 <code>lateinit</code>：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">lateinit</span> <span class="token keyword">var</span> a<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unita <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1551"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印出很多1551</span></code></pre><h3 id="更进一步：匿名-Lambda-表达式的递归"><a href="#更进一步：匿名-Lambda-表达式的递归" class="headerlink" title="更进一步：匿名 Lambda 表达式的递归"></a>更进一步：匿名 Lambda 表达式的递归</h3><p>正统的「<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener">Lambda演算</a>」里面的函数全部都是匿名函数，需要使用「<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator" target="_blank" rel="noopener">不动点组合子</a>」实现递归：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 这是javascript</span><span class="token punctuation">(</span>f <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span>y <span class="token operator">=</span><span class="token operator">></span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span>y <span class="token operator">=</span><span class="token operator">></span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>func <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"1551"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印出很多1551</span></code></pre><p>上面的那一坨 <code>f =&gt; (x =&gt; f(y =&gt; x(x)(y)))(x =&gt; f(y =&gt; x(x)(y)))</code> 即是「Z组合子」。（读者可以思考一下为什么这里我给了 JavaScript 的例子是而不是 Kotlin（逃</p><h2 id="阻止编译器添加对非空类型的函数参数的-NullCheck"><a href="#阻止编译器添加对非空类型的函数参数的-NullCheck" class="headerlink" title="阻止编译器添加对非空类型的函数参数的 NullCheck"></a>阻止编译器添加对非空类型的函数参数的 NullCheck</h2><p>总所周知，当一个函数的参数是非空类型时，Kotlin编译器会在方法入口处加一行检查入参是否为空的代码。比如说 <code>main</code> 函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>经过编译后，再反编译成Java：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Intrinsics<span class="token punctuation">.</span><span class="token function">checkParameterIsNotNull</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token string">"args"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可恶！辣鸡编译器自作主张！我不想要这行代码！</p><p>如果不想编译器生成这些代码，把这几个编译器参数 <code>-Xno-call-assertions</code>、<code>-Xno-param-assertions</code>、<code>-Xno-receiver-assertions</code> 传给Kotlin编译器即可。</p><p>传递编译器参数的方法：</p><p>使用IDEA调用编译器的情况：</p><pre><code>Project 设置：File -&gt; Settings -&gt; 找到 Kotlin Compiler -&gt; Additional command line parametersModule 设置：File -&gt; Project Structure -&gt; Module -&gt; 找到你的Module里面的Kotlin设置 -&gt; Additional command line parameters</code></pre><p>使用Gradle Kotlin DSL的情况：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// build.gradle.kts</span>tasks<span class="token punctuation">.</span>withType<span class="token operator">&lt;</span>KotlinCompile<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 加上下面这行</span>    kotlinOptions<span class="token punctuation">.</span>freeCompilerArgs <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"-Xno-call-assertions"</span><span class="token punctuation">,</span> <span class="token string">"-Xno-param-assertions"</span><span class="token punctuation">,</span> <span class="token string">"-Xno-receiver-assertions"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>PS：注意IDEA的 <code>Delegate IDE build/run actions to gradle</code> 这个选项是否勾选的区别。</p><h2 id="给data-class自定义getter和setter"><a href="#给data-class自定义getter和setter" class="headerlink" title="给data class自定义getter和setter"></a>给data class自定义getter和setter</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">SomeClass</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span></code></pre><p>众所周知 Kotlin 不允许给声明在主构造器里面的属性写自定义getter、setter，主要是为了防止有好事者乱写，破坏规则就不好了。所以迂回操作如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">SomeClass</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">var</span> _name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> name<span class="token operator">:</span> String        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> _name        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> _name <span class="token operator">=</span> value <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解释：<code>private</code>的<code>_name</code>不会生成getter和setter，你再把你想写的getter和setter添上就好。这样<code>SomeClass</code>里面就有3样东西：<code>String _name</code>，<code>String getName()</code>和<code>void setName(String)</code>（以及data class根据<code>_name</code>自动生成的那些）。</p><p>缺点很明显，toString 生成的字符串会比较丑。</p><h2 id="流的读取"><a href="#流的读取" class="headerlink" title="流的读取"></a>流的读取</h2><p>普通青年：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// java 代码</span><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>InputStream in<span class="token punctuation">,</span> OutputStream out<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">int</span> read<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>read <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>文艺青年：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>`<span class="token keyword">in</span>`<span class="token operator">:</span> InputStream<span class="token punctuation">,</span> <span class="token keyword">out</span><span class="token operator">:</span> OutputStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> read<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> read <span class="token operator">=</span> `<span class="token keyword">in</span>`<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>read <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>二逼青年：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>`<span class="token keyword">in</span>`<span class="token operator">:</span> InputStream<span class="token punctuation">,</span> <span class="token keyword">out</span><span class="token operator">:</span> OutputStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> read<span class="token operator">:</span> Int <span class="token operator">=</span> `<span class="token keyword">in</span>`<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>read <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span>        read <span class="token operator">=</span> `<span class="token keyword">in</span>`<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>群里的优秀的青年（不是我）：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>`<span class="token keyword">in</span>`<span class="token operator">:</span> InputStream<span class="token punctuation">,</span> <span class="token keyword">out</span><span class="token operator">:</span> OutputStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> read<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>`<span class="token keyword">in</span>`<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span> read <span class="token operator">=</span> it <span class="token punctuation">}</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="限制扩展的作用域（防止污染命名空间）"><a href="#限制扩展的作用域（防止污染命名空间）" class="headerlink" title="限制扩展的作用域（防止污染命名空间）"></a>限制扩展的作用域（防止污染命名空间）</h2><p>注意：此技巧并不稳定，可能在未来被官方干掉。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 把扩展丢进一个object里面</span><span class="token keyword">object</span> StringExtension <span class="token punctuation">{</span>    <span class="token annotation builtin">@JvmStatic</span> <span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fuck <span class="token interpolation variable">$this</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 使用说明</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 下面这行被注释掉的代码不能通过编译</span>    <span class="token comment" spellcheck="true">// "kotlin".fuck()</span>    <span class="token comment" spellcheck="true">// 你要这么用，将MyExtentions塞进上下文（即this）</span>    <span class="token function">with</span><span class="token punctuation">(</span>StringExtention<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token string">"kotlin"</span><span class="token punctuation">.</span><span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 或者手动引入</span><span class="token keyword">import</span> StringExtension<span class="token punctuation">.</span>fuck<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">"kotlin"</span><span class="token punctuation">.</span><span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 以下是夏姬八写，别模仿</span><span class="token keyword">interface</span> Extension<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T <span class="token operator">:</span> Extension<span class="token punctuation">,</span> R<span class="token operator">></span> T<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>block<span class="token operator">:</span> T<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> R<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">object</span> StringExtension <span class="token operator">:</span> Extension <span class="token punctuation">{</span>    <span class="token annotation builtin">@JvmStatic</span> <span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fuck <span class="token interpolation variable">$this</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">object</span> IntExtension <span class="token operator">:</span> Extension <span class="token punctuation">{</span>    <span class="token annotation builtin">@JvmStatic</span> <span class="token keyword">fun</span> Int<span class="token punctuation">.</span><span class="token function">love</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love <span class="token interpolation variable">$this</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringExtension<span class="token punctuation">.</span><span class="token function">use</span> <span class="token punctuation">{</span> <span class="token string">"kotlin"</span><span class="token punctuation">.</span><span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>    IntExtension<span class="token punctuation">.</span><span class="token function">use</span> <span class="token punctuation">{</span> <span class="token number">1551</span><span class="token punctuation">.</span><span class="token function">love</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="链式调用时输出中间值"><a href="#链式调用时输出中间值" class="headerlink" title="链式调用时输出中间值"></a>链式调用时输出中间值</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> printlnBy <span class="token punctuation">{</span> it <span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span> T<span class="token punctuation">.</span><span class="token function">printlnBy</span><span class="token punctuation">(</span>selector<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> U<span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">selector</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> it <span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">printlnBy</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// &lt;==这里</span>            <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> it <span class="token operator">and</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">}</span>            <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// &lt;==还有这里</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：</span><span class="token comment" spellcheck="true">// 18</span><span class="token comment" spellcheck="true">// 6</span></code></pre><p>注意副作用，别夏姬八用！</p><p>如果是集合操作，可以考虑使用 <code>onEach</code> 这个高阶函数，例如<code>onEach { println(it) }</code>。</p>]]></content>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【水】Kotlin Puzzlers 改</title>
      <link href="/2017/12/28/kotlin-puzzlers/"/>
      <url>/2017/12/28/kotlin-puzzlers/</url>
      <content type="html"><![CDATA[<p>《Java Puzzlers》（中文名《Java 解惑》）里面讲解了许多 Java 语言的大坑，相信各位julao应该都看过。Kotlin 作为「a better Java」，在填补一些坑的同时，不可避免地引入了许多新坑。<a id="more"></a>本来本鶸进行了一段时间的取材，想要写一篇《Kotlin Puzzlers》的，可谁知 已经有人早就把我的饭碗抢走了，而且素材比我还多，可恶！</p><p>这篇文章就是本鶸看完录像（油土鳖上面有）以及 Github 上的完整内容后，将一些比较坑的谜题拿出来报复社会，蛐蛐一篇观后感而已。</p><p>题型为选择题，本辣鸡博客没有NGA的折叠，没有萌百的黑幕，为了防止一眼瞄到答案而造成剧透，本文对答案（以及解释）的摆放位置做了调整，例如第一题的答案被我放在了第二题的位置（以此类推）。各位看客从上到下开始阅读就好了。</p><p>使用的 Kotlin 版本为1.2。</p><h2 id="没有坑到我的谜题"><a href="#没有坑到我的谜题" class="headerlink" title="没有坑到我的谜题"></a>没有坑到我的谜题</h2><p>虽然没有被坑，比较简单，但是值得注意的题。一些更加简单的题目就不放上来了。想刷一遍完整题库的同学可以到 GitHub 上面找。</p><h3 id="强力返回-Power-Return"><a href="#强力返回-Power-Return" class="headerlink" title="强力返回 ~ Power Return"></a>强力返回 ~ Power Return</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>  <span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token keyword">return</span> <span class="token keyword">throw</span> <span class="token keyword">return</span> <span class="token string">"Hello"</span>  <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </code></pre><pre><code>这会打印出什么？a) Hellob) 两个Helloc) 这破代码根本没法通过编译d) 以上答案都不对</code></pre><p>本题答案（以及解释）在下一题那里。（以此类推）</p><h3 id="计划生育-One-Chile-Policy"><a href="#计划生育-One-Chile-Policy" class="headerlink" title="计划生育 ~ One Chile Policy"></a>计划生育 ~ One Chile Policy</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">fun</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">class</span> Parent <span class="token operator">:</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token string">"parent"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">fun</span> <span class="token function">child</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">Node</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>  <span class="token keyword">val</span> child1 <span class="token operator">=</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token string">"child1"</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token keyword">val</span> child2 <span class="token operator">=</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token string">"child2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) child1 和 child2b) child1 和 parentc) parent 和 child2d) 以上答案都不对</code></pre><p>上一题的答案：a</p><p>要记住，<code>return ***</code> 和 <code>throw ***</code> 都是表达式，其结果的类型为 <code>Nothing</code>，<code>Nothing</code> 类型是任意类型的子类型，所以 <code>Nothing</code> 可以被抛出，可以被返回，可以赋值给任意类型的变量。事实上 <code>hello()</code> 在 <code>return &quot;Hello&quot;</code> 的时候已经结束了，剩下的 <code>throw</code>、<code>val result</code>、<code>println()</code> 什么的都是不可到达代码（unreachable code），不会被运行。</p><p>PS：你甚至可以写出这样的代码：<code>throw throw throw Exception()</code></p><h3 id="两只拉姆达跑得快-Two-Lambda"><a href="#两只拉姆达跑得快-Two-Lambda" class="headerlink" title="两只拉姆达跑得快 ~ Two Lambda"></a>两只拉姆达跑得快 ~ Two Lambda</h3><pre class=" language-kotlin"><code class="language-kotlin">typealias L <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span>one<span class="token operator">:</span> L <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> two<span class="token operator">:</span> L <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">one</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span>  <span class="token function">two</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>foo <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) oneoneb) twotwoc) onetwod) 以上答案都不对</code></pre><p>上一题的答案：d</p><p>事实上是 <code>child1</code> 和 <code>parent</code>。<code>Kotlin</code> 的这些扩展方法如 <code>apply</code>、<code>let</code>、<code>also</code> 等等都是适用于所有类型的，包括可空类型。<code>child2</code> 那行 <code>apply</code> 函数接收的拉姆达表达式的类型其实是 <code>Node?.() -&gt; Unit</code>，如果 <code>child2</code>那行代码是写在 <code>Parent</code> 类的外面的话，你就会发现这行代码根本没法通过编译，这里面调用的 <code>lookup</code> 实际上是 <code>parent</code> 的 <code>lookup</code>。（你可以把 <code>apply</code> 换成 <code>also</code> 试试。）</p><h3 id="衔尾蛇-Cyclic-Object-Constructions"><a href="#衔尾蛇-Cyclic-Object-Constructions" class="headerlink" title="衔尾蛇 ~ Cyclic Object Constructions"></a>衔尾蛇 ~ Cyclic Object Constructions</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">val</span> x<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">)</span><span class="token keyword">object</span> B <span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token keyword">object</span> C <span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span>x<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) nullnullb) C@********nullc) ExceptionInInitializerErrord) 这破代码根本没法通过编译</code></pre><p>上一题的答案：d</p><p>实际上是 <code>twoone</code>。第一句的语法只有在拉姆达表达式是最后一个参数的时候才能写的，所以是 <code>two</code>。第二句是普通的方法调用，先填上第一个参数，第二个参数使用默认值。</p><p>PS：想要朴素地实现 <code>foo { } { }</code> 这样的调用的话应该是办不到的吧。(如果能做到请赶快告诉我！)</p><h3 id="哇，好长-Breaking-Lines"><a href="#哇，好长-Breaking-Lines" class="headerlink" title="哇，好长 ~ Breaking Lines"></a>哇，好长 ~ Breaking Lines</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> anExtremelyLongAndBoringStatementThatBarelyFitsOnALine <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">val</span> anotherExtremelyLongStatementThatBarelyFitsOnALine <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">val</span> someList <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> result <span class="token operator">=</span> someList<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span>        anExtremelyLongAndBoringStatementThatBarelyFitsOnALine            <span class="token operator">+</span> anotherExtremelyLongStatementThatBarelyFitsOnALine<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) [1]b) [2]c) [4]d) [1, 4]</code></pre><p>上一题的答案：b</p><p><code>B</code> 初始化需要 <code>C</code>，<code>C</code> 初始化需要 <code>B</code>。咦，<code>B</code> 还没初始化完成呢，那么哪来的 <code>B</code> 呢，只能是 <code>null</code> 了啊！</p><p>参见 <a href="http://jetbrains.github.io/kotlin-spec/#_singleton_objects" target="_blank" rel="noopener">http://jetbrains.github.io/kotlin-spec/#_singleton_objects</a></p><h3 id="换个名字你就不认识我了-Good-Child-Has-Many-Names"><a href="#换个名字你就不认识我了-Good-Child-Has-Many-Names" class="headerlink" title="换个名字你就不认识我了 ~ Good Child Has Many Names"></a>换个名字你就不认识我了 ~ Good Child Has Many Names</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> C <span class="token punctuation">{</span>  <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">}</span><span class="token keyword">class</span> D <span class="token operator">:</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">sum</span><span class="token punctuation">(</span>y<span class="token operator">:</span> Int<span class="token punctuation">,</span> x<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">val</span> d<span class="token operator">:</span> D <span class="token operator">=</span> <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> c<span class="token operator">:</span> C <span class="token operator">=</span> d<span class="token function">print</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) 22b) 11c) 21d) 这破代码根本没法通过编译</code></pre><p>上一题的答案：b</p><p>之前裙里有julao问过类似的问题所以我没被坑到。你可以把代码丢到IDEA里面，光标定位到加号前面，按下 <code>Ctrl+B</code> 或者 <code>Ctrl+Q</code>，看看那个加号是什么意思吧。解决方法：把加号放在上一行的后面可破。</p><h3 id="排序-Sorting"><a href="#排序-Sorting" class="headerlink" title="排序 ~ Sorting"></a>排序 ~ Sorting</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">arrayListOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">val</span> sortedList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>sortedList<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) [1, 5, 3, 2, 4]b) [1, 2, 3, 4, 5]c) kotlin.Unitd) 这破代码根本没法通过编译</code></pre><p>上一题的答案：c</p><p>命名参数是静态分配的。</p><h3 id="致命的顺序-The-Order"><a href="#致命的顺序-The-Order" class="headerlink" title="致命的顺序 ~ The Order"></a>致命的顺序 ~ The Order</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Order <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">val</span> c<span class="token operator">:</span> String  <span class="token keyword">init</span> <span class="token punctuation">{</span>    <span class="token function">the</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    c <span class="token operator">=</span> <span class="token string">""</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">the</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>length<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">Order</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) 0b) nullc) 这破代码根本没法通过编译d) 以上答案都不对</code></pre><p>上一题的答案：c</p><p>参见 <a href="https://zhuanlan.zhihu.com/p/27234651" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27234651</a></p><p>本题的答案：d</p><p>JVM 不想理你并向你抛出了一只 NPE。Java 也有这个问题，Scala 不熟悉不清楚。据说 Ceylon 就没有这个问题，具体可以看 Ceylon 官网上的说明（趁机吹一波 Ceylon）。</p><p><a href="https://ceylon-lang.org/documentation/1.3/tour/initialization/#definite_assignment_and_definite_initialization" target="_blank" rel="noopener">https://ceylon-lang.org/documentation/1.3/tour/initialization/#definite_assignment_and_definite_initialization</a></p><p>Kotlin 官方人员曾表示修复这个缺陷是一件十分困难的事。</p><h2 id="那些坑了我的迷题"><a href="#那些坑了我的迷题" class="headerlink" title="那些坑了我的迷题"></a>那些坑了我的迷题</h2><p>我果然是鶸，错了这么多，进入自卑模式~</p><h3 id="区间测试-Inclusive-Range"><a href="#区间测试-Inclusive-Range" class="headerlink" title="区间测试 ~ Inclusive Range"></a>区间测试 ~ Inclusive Range</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> i <span class="token operator">=</span> <span class="token number">10.5</span><span class="token keyword">when</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"in"</span><span class="token punctuation">)</span>  <span class="token operator">!</span><span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"!in"</span><span class="token punctuation">)</span>  <span class="token keyword">else</span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"else"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre><code>这会打印出什么？a) inb) !inc) elsed) 这破代码根本没法通过编译</code></pre><p>据说这道题在 Kotlin 1.0 版本和 1.2 版本里有不同的表现。（我懒得试旧版本了）</p><h3 id="极性不定-Weird-Chaining"><a href="#极性不定-Weird-Chaining" class="headerlink" title="极性不定 ~ Weird Chaining"></a>极性不定 ~ Weird Chaining</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">printNumberSign</span><span class="token punctuation">(</span>num<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">"negative"</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">"positive"</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token string">"zero"</span>  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">printNumberSign</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token function">printNumberSign</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token function">printNumberSign</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) negative; zero; positiveb) negative; zeroc) negative; positived) zero; positive</code></pre><p>上一题的答案：a</p><p>实际上是把 <code>i</code> 转成 <code>Int</code> 再进行的比较。</p><h3 id="Dollar-In-Multiline-Literals"><a href="#Dollar-In-Multiline-Literals" class="headerlink" title="$_$ ~ Dollar In Multiline Literals"></a>$_$ ~ Dollar In Multiline Literals</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> multiline <span class="token operator">=</span> <span class="token raw-string string">"""        To win \<span class="token interpolation variable">$999</span>.999 execute "rm -fr \<span class="token interpolation variable">$HOME</span>/kotlin-puzzlers/*"        """</span><span class="token punctuation">.</span><span class="token function">trimIndent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span>multiline<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) To win \$999.999 execute &quot;rm -fr \$HOME/kotlin-puzzlers/*&quot;b) To win 999.999 execute &quot;rm -fr \/home/user/kotlin-puzzlers/*&quot;c) To win $999.999 execute &quot;rm -fr $HOME/kotlin-puzzlers/*&quot;d) 这破代码根本没法通过编译</code></pre><p>上一题的答案：d</p><p>相当于：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token string">"negative"</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token string">"positive"</span> <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token string">"zero"</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>秒懂！</p><p>解决方法：用小括号将那串 <code>if else</code> 括起来再接 <code>let</code> 可破。</p><h3 id="你的名字是-Property-Override"><a href="#你的名字是-Property-Override" class="headerlink" title="你的名字是 ~ Property Override"></a>你的名字是 ~ Property Override</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> Named <span class="token punctuation">{</span>  <span class="token keyword">open</span> <span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> field <span class="token operator">?:</span> <span class="token string">"&lt;unnamed>"</span><span class="token punctuation">}</span><span class="token keyword">class</span> Person<span class="token operator">:</span> <span class="token function">Named</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">override</span> <span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span>name    <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> field <span class="token operator">=</span> <span class="token string">"Mr <span class="token interpolation variable">$value</span>"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">val</span> person <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Anton"</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) Antonb) Mr Antonc) &lt;unnamed&gt;d) null</code></pre><p>上一题的答案：d</p><p>这种 raw string 里面美元符号 <code>$</code> 一直都是表示模板表达式，而且不能被转义，所以 <code>$HOME</code> 这里糟了。（你问为什么 <code>$999.999</code> 没糟？因为 <code>999.999</code> 不是合法的变量名啊，你在 <code>999.999</code> 两边加上反引号试试。）</p><p>解决方法：”””${‘$’}HOME”””</p><h3 id="冰雪聪明-Custom-Getter-Smartcast"><a href="#冰雪聪明-Custom-Getter-Smartcast" class="headerlink" title="冰雪聪明 ~ Custom Getter Smartcast"></a>冰雪聪明 ~ Custom Getter Smartcast</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> SmartCastable <span class="token punctuation">{</span>    <span class="token keyword">val</span> list<span class="token operator">:</span> List<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> <span class="token keyword">set</span><span class="token operator">:</span> Set<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableSetOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>         <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> field<span class="token punctuation">}</span><span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token function">SmartCastable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span>list <span class="token keyword">is</span> MutableList<span class="token punctuation">)</span>    sc<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span>set <span class="token keyword">is</span> MutableSet<span class="token punctuation">)</span>    sc<span class="token punctuation">.</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">${</span>sc<span class="token punctuation">.</span>list<span class="token delimiter variable">}</span></span>, <span class="token interpolation"><span class="token delimiter variable">${</span>sc<span class="token punctuation">.</span>set<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) [1, 2, 3], [1, 2, 3]b) [1, 2, 3, 4], [1, 2, 3, 4]c) UnsupportedOperationExceptiond) 这破代码根本没法通过编译</code></pre><p>上一题的答案：c</p><p>这里有两个 <code>backing field</code>，<code>Named</code> 类的那个 <code>get</code> 方法操纵了父类的 <code>backing field</code>，<code>set</code> 方法操纵的是自己的 <code>backing field</code>。</p><p>解决方法：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Person<span class="token operator">:</span> <span class="token function">Named</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token operator">?</span>        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span>name        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Mr <span class="token interpolation variable">$value</span>"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="最小值-MinInt"><a href="#最小值-MinInt" class="headerlink" title="最小值 ~ MinInt"></a>最小值 ~ MinInt</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">printInt</span><span class="token punctuation">(</span>n<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">printInt</span><span class="token punctuation">(</span><span class="token operator">-</span>2_147_483_648<span class="token punctuation">.</span><span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) -2147483647b) -2147483649c)  2147483647d) 以上答案都不对</code></pre><p>上一题的答案：d</p><p><code>sc.set</code> 有一个自定义 <code>getter</code>，编译器没法判断这个 <code>getter</code> 返回的是否是同一个对象，所以无法进行智能转换（smart cast）。</p><p>解决方法：这时候别声明只有 <code>getter</code> 的属性，声明有 <code>backing field</code> 的属性就好。或者像这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> <span class="token keyword">set</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>set<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">set</span> <span class="token keyword">is</span> MutableSet<span class="token punctuation">)</span>    <span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><h3 id="人类衰退之后-Population-To-Mars"><a href="#人类衰退之后-Population-To-Mars" class="headerlink" title="人类衰退之后 ~ Population To Mars"></a>人类衰退之后 ~ Population To Mars</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">Population</span><span class="token punctuation">(</span><span class="token keyword">var</span> cities<span class="token operator">:</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Int<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">val</span> 帝都 <span class="token keyword">by</span> cities  <span class="token keyword">val</span> 魔都 <span class="token keyword">by</span> cities  <span class="token keyword">val</span> 妖都 <span class="token keyword">by</span> cities<span class="token punctuation">}</span><span class="token keyword">val</span> population <span class="token operator">=</span> <span class="token function">Population</span><span class="token punctuation">(</span><span class="token function">mapOf</span><span class="token punctuation">(</span>    <span class="token string">"帝都"</span> <span class="token keyword">to</span> 864_816<span class="token punctuation">,</span>    <span class="token string">"魔都"</span> <span class="token keyword">to</span> 413_782<span class="token punctuation">,</span>    <span class="token string">"妖都"</span> <span class="token keyword">to</span> 43_005<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 许多年过去了，地球毁灭了，只有少数幸存者抵达了火星（大吉大利今晚吃鸡）！</span>population<span class="token punctuation">.</span>cities <span class="token operator">=</span> <span class="token function">emptyMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">with</span><span class="token punctuation">(</span>population<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"$帝都; $魔都; $妖都"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre><code>这会打印出什么？a) 0; 0; 0b) 864816; 413782; 43005c) NullPointerExceptiond) NoSuchElementException</code></pre><p>上一题的答案：d</p><p>破代码没法通过编译。实际的求值顺序是：<code>-(2_147_483_648.inc())</code>，这TM是个 <code>Long</code>。这个一元操作符的优先级比普通方法调用低。</p><h3 id="反物质-AntiMatter"><a href="#反物质-AntiMatter" class="headerlink" title="反物质 ~ AntiMatter"></a>反物质 ~ AntiMatter</h3><pre class=" language-kotlin"><code class="language-kotlin">operator <span class="token keyword">fun</span> Nothing<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Unitoperator <span class="token keyword">fun</span> Unit<span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">val</span> foo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token operator">!!</span><span class="token operator">!!</span><span class="token operator">!</span>foo<span class="token operator">!!</span><span class="token operator">!!</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) nullb) kotlin.Unitc) KotlinNullPointerExceptiond) 这破代码根本没法通过编译</code></pre><p>上一题的答案：b</p><p>用于委托代理的那个 <code>Map</code> 被保存在了一个 <code>private final</code> 的 <code>field</code> 里面，正常手段没法赋新值。</p><p>本题的答案：d</p><p><code>null</code> 的类型是 <code>Nothing?</code>（而且是这个类型的唯一值）。<code>***!!</code> 这个非空断言比 <code>not()</code> 的优先级要高，所以 <code>foo!!!!</code> 的类型是 <code>Nothing</code>，<code>Nothing</code> 是所有类型的子类型，所以编译器没法判断该调用哪个扩展方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些辣鸡代码，别学。</p><img src="/2017/12/28/kotlin-puzzlers/20171206120238.jpg" title="辣鸡Kotlin">]]></content>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最近观察到的Kotlin的华点</title>
      <link href="/2017/10/18/huadian/"/>
      <url>/2017/10/18/huadian/</url>
      <content type="html"><![CDATA[<p>不定期更新。<br><a id="more"></a><br>以下内容使用的 Kotlin 版本为 1.1.51。</p><h1 id="2017-10-18"><a href="#2017-10-18" class="headerlink" title="2017-10-18"></a>2017-10-18</h1><p>封面换成了艾拉酱，真好啊~真好啊~ ヾ(≧▽≦*)o</p><h2 id="一件Java能做但是Kotlin不能做的事情"><a href="#一件Java能做但是Kotlin不能做的事情" class="headerlink" title="一件Java能做但是Kotlin不能做的事情"></a>一件Java能做但是Kotlin不能做的事情</h2><p>在Codewars上刷题的时候发现的，本来这网站上面的Kotlin题就少，而且还有大把大把不会写，能玩的就更少了。这种题目不调戏一下冰酱就可惜了。具体是<a href="http://www.codewars.com/kata/tricky-kotlin-number-3-define-a-function" target="_blank" rel="noopener">这道题</a>。</p><p>这题要求你代码中不能出现<code>fun</code>、<code>{</code>以及<code>}</code>的情况下让定义一个拼接两个字符串的函数。这个要求等同于禁止你使用lambda表达式、函数声明，并且限制你仅用一个表达式完成任务（根据我的理解，是这样的没错）。</p><p>那我们来找找有什么现成的有<code>invoke()</code>方法的东西吧。首先想到了反射，但是反射那家伙需要传入接收者作为第一个参数，rua~。既然反射不行，啊，有个更好的东西，看起来完美符合需求。</p><p>马上写好代码准备吊打冰酱，然后就是喜闻乐见的辣鸡Kotlin时间，代码如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> concatString <span class="token operator">=</span> MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findVirtual</span><span class="token punctuation">(</span>String<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">,</span>            <span class="token string">"concat"</span><span class="token punctuation">,</span> MethodType<span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span>String<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">,</span> String<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token function">concatString</span><span class="token punctuation">(</span><span class="token string">"我永远喜欢"</span><span class="token punctuation">,</span> <span class="token string">"珂朵莉"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> String <span class="token comment" spellcheck="true">// Boom！</span></code></pre><p>然后在Java里写下同样的代码进行测试，嗯，果然是辣鸡Kotlin。</p><p>炸裂原因是Kotlin不支持所谓的签名多态性（signature polymorphism），从编译出来的字节码可以看得出来：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// kotlin</span>INVOKEVIRTUAL java<span class="token operator">/</span>lang<span class="token operator">/</span>invoke<span class="token operator">/</span>MethodHandle<span class="token punctuation">.</span><span class="token function">invoke</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>Object<span class="token punctuation">;</span><span class="token punctuation">)</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>Object<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// java</span>INVOKEVIRTUAL java<span class="token operator">/</span>lang<span class="token operator">/</span>invoke<span class="token operator">/</span>MethodHandle<span class="token punctuation">.</span><span class="token function">invoke</span> <span class="token punctuation">(</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span></code></pre><p>运行时要成功调用该方法的话，字节码中的参数与返回值类型必须与运行时<code>MethodHandle</code>所代表的实际的方法类型一致，否则会抛出<code>WrongMethodTypeException</code>。上面那段Kotlin代码运行时就会抛出这个异常，异常信息为<code>cannot convert MethodHandle(String,String)String to (Object[])Object</code>，正好与上面的字节码相对应。嗯就是这样。</p><p>Kotlin编译器现在还不能支持多态签名，而且这将持续很长一段时间（官方人员说了，1.2版本也不会实现这项功能）。</p><p>解决方法：辣鸡Kotlin。</p><h1 id="2017-10-10"><a href="#2017-10-10" class="headerlink" title="2017-10-10"></a>2017-10-10</h1><p>最近翻看以前写的旧代码，发现由于Kotlin及其IDEA插件版本更新了，静态检查工具功能增强，检出了一些令人窒息的代码（例如 Check for instance is always ‘true’）。然后我在查看这些乱七八糟的代码时发现了两个问题。</p><h2 id="编译器生成了无用的字节码"><a href="#编译器生成了无用的字节码" class="headerlink" title="编译器生成了无用的字节码(?)"></a>编译器生成了无用的字节码(?)</h2><p>把问题单独抽出来就像是这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> A<span class="token operator">&lt;</span>T <span class="token operator">:</span> Any<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">val</span> <span class="token keyword">data</span><span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">val</span> string<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>a<span class="token operator">:</span> A<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a<span class="token punctuation">.</span>data <span class="token keyword">as</span> B   <span class="token comment" spellcheck="true">// 注意这行对应的字节码</span>    a<span class="token punctuation">.</span>data<span class="token punctuation">.</span>string <span class="token comment" spellcheck="true">// 这里 a.data 有提示 Smart cast to B</span><span class="token punctuation">}</span></code></pre><p>然后看看编译出的字节码里面都有啥：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以上省略</span>   L1    LINENUMBER <span class="token number">5</span> L1    ALOAD <span class="token number">0</span>    INVOKEVIRTUAL A<span class="token punctuation">.</span><span class="token function">getData</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>Object<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a.data</span>    DUP    IFNONNULL L2   <span class="token comment" spellcheck="true">// &lt;============================ 这里进行判空</span>    NEW <span class="token class-name">kotlin</span><span class="token operator">/</span>TypeCastException    DUP    LDC <span class="token string">"null cannot be cast to non-null type B"</span>    INVOKESPECIAL kotlin<span class="token operator">/</span>TypeCastException<span class="token punctuation">.</span>&lt;init<span class="token operator">></span> <span class="token punctuation">(</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V    ATHROW   L2    CHECKCAST B    <span class="token comment" spellcheck="true">// &lt;============================ 不为空则进行类型转换</span>    POP   L3<span class="token comment" spellcheck="true">// 以下省略</span></code></pre><p>大致内容就是判断 <code>a.data</code> 是否为 <code>null</code>，如果是 <code>null</code> 就 <code>throw TypeCastException(&quot;null cannot be cast to non-null type B&quot;)</code>。然而根据 <code>A</code> 这个类的定义，其属性 <code>data</code> 必定是非空的。对非空属性进行 null check 岂不是多余？难道说编译器太傻，在分析这种操作时不知道 <code>a.data</code> 是非空的？</p><p>解决方法：加个问号，如下所示：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>a<span class="token operator">:</span> A<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a<span class="token punctuation">.</span>data <span class="token keyword">as</span> B<span class="token operator">?</span>   <span class="token comment" spellcheck="true">// 加了个问号，变成了B?</span>    a<span class="token punctuation">.</span>data<span class="token punctuation">.</span>string  <span class="token comment" spellcheck="true">// 注意这里 a.data 同样有提示 Smart cast to B</span><span class="token punctuation">}</span></code></pre><p>这时候字节码就是这样的：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以上省略</span>   L1    LINENUMBER <span class="token number">5</span> L1    ALOAD <span class="token number">0</span>    INVOKEVIRTUAL A<span class="token punctuation">.</span><span class="token function">getData</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>Object<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a.data</span>    CHECKCAST B    <span class="token comment" spellcheck="true">// &lt;============================ 直接进行类型转换</span>    POP   L2<span class="token comment" spellcheck="true">// 以下省略</span></code></pre><p>这回就没有多余的判空处理了。但是注意代码中的 <code>a.data.string</code>，IDE提示 <code>a.data</code> 能够 Smart cast to B。咦编译器还是蛮聪明的呢！</p><h2 id="检查工具提示可对代码进行负优化"><a href="#检查工具提示可对代码进行负优化" class="headerlink" title="检查工具提示可对代码进行负优化(?)"></a>检查工具提示可对代码进行负优化(?)</h2><p>这个问题单独抽出来就像这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> A<span class="token keyword">class</span> B <span class="token punctuation">{</span>    <span class="token keyword">fun</span> <span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> A <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>some<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> A <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>some <span class="token keyword">is</span> B<span class="token punctuation">)</span> some<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 注意这行</span><span class="token punctuation">}</span></code></pre><p>然后你可以看到，IDE提示你可以 Replace ‘if’ expression with elvis experssion。如果你让IDE帮你优化，就变成了这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>some<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> A <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>some <span class="token keyword">as</span><span class="token operator">?</span> B<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// WTF???</span><span class="token punctuation">}</span></code></pre><p>不知道你们是怎么想的，至少对于我来说可读性下降，而且很明显生成的字节码也变复杂了。明显是负优化，吧？</p><p>解决方法：<code>@Suppress(&quot;IfThenToElvis&quot;)</code></p><h1 id="很久以前的冷饭"><a href="#很久以前的冷饭" class="headerlink" title="很久以前的冷饭"></a>很久以前的冷饭</h1><p>把以前想过的东西拿出来凑字数。</p><h2 id="Kotlin数组类型与reified"><a href="#Kotlin数组类型与reified" class="headerlink" title="Kotlin数组类型与reified"></a>Kotlin数组类型与reified</h2><p>在Java，你可以这样写：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">some</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is String[]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是辣鸡Kotlin不行：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span>any<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 编译错误：Cannot check for instance of erased type: Array&lt;String></span>    <span class="token comment" spellcheck="true">//               ↓</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>any <span class="token keyword">is</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is String[]"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说好的 <code>Array&lt;reified T&gt;</code> 呢？</p>]]></content>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于此博客，以及博主，还有那些七七八八的事</title>
      <link href="/2017/04/27/about/"/>
      <url>/2017/04/27/about/</url>
      <content type="html"><![CDATA[<h1 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h1><p>讲道理，我搭好 Hexo 才发现，如果使用 Jekyll 的话，只要将页面源码 Push 到 Github 上，是可以自动生成页面并发布的。<br><a id="more"></a><br>全栽在 CI 上了（用的是 AppVeyor），首先是太久没用 Git，忘记子模块怎么用了，坑了好久。之后是 Git 一些操作重定向 stdout 到 stderr 导致 PowerShell ISE 报错，于是 CI 那边就挂掉了。然后是 Gitlab 的神奇 Bug，一次 Push 让 CI 那边连续 Build 了 5 次……</p><p>于是 3 天的人生就浪费掉了。<del>其实如果不搞持续集成的话就没那么多事。</del>虽然说结果都一样，但是总感觉有那么点不爽，我特么怎么就选了 Hexo 呢。越想越恼火。不排除以后换成 Jekyll 的可能性，不过主题一定是要换的。</p><p>2017年5月29日，主题由 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a> 变更为 <a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">material</a>。</p><p>2018年1月20日，域名已部署，HTTPS已部署。</p><h1 id="关于博客-The-History-of-RenTou"><a href="#关于博客-The-History-of-RenTou" class="headerlink" title="关于博客 ~ The History of RenTou"></a>关于博客 ~ The History of RenTou</h1><blockquote><p>Q：这个博客的名字“人头会社”有什么含义么？</p><p>A：没啥，这个只是从我的 QQ 空间那里拿来的（逃</p></blockquote><p>说实话我还专门上了一下万年没打理的 QQ 空间考究了一番，发现原来我的 QQ 空间是叫做 “反补课基地” 的（没错，我忘了）。初中时期补课之风盛行，原本每周都有的双休，补得只剩半天假期。唔，这个 “反补课基地” 就是当时中二病发作的产物。</p><p>所谓 “人头”，并不是位于身体最上方部位、由人的颅骨支撑的那个圆滚滚的东西<del>（对不起让你们失望了）</del>，而是挂在小卖部外墙上的衣服或杂物。由于当时正值放假前夜，月黑风高，去买零食的3人误认为是人头。于是这项活动「在放假的前一天晚上，前往小卖部采购以庆祝放假」便固定了下来，美名其曰「人头节」，随后便有了「人头会」，可喜可贺。</p><p>虽然人头会仅3名成员，但经常与班上其他同学一起庆祝人头节，所谓“独乐乐不如众乐乐”。这被班上另一邪恶组织「精神病院」的院长大人看到了，院长害怕事情变得一发不可收拾，便对人头会施压，试图使其解散。坚毅的人头会成员不惧怕任何威胁，事实证明，看似实力强大的精神病院（十几名成员）实际上却是一盘散沙。高贵的人头会有共同的信仰（放假），有定期的活动（人头节），具有强大的精神凝聚力，不是无所事事的精神病院所能比拟的。</p><p>嘻嘻。院长大人别打我~~</p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>唔，感觉没啥好说的呢。</p><p><del>人头会社三元老之一，精神病院第13号床位所有者。</del></p><p><del>不务正业的辣鸡。</del></p><p>噫，就这样。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>这个博客是有评论系统的，看不到的话那应该是被墙了，请使用科学姿势查看。（或者等我换成其他系统（懒癌不允许我这么做（不！</p>]]></content>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
