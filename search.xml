<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Kotlin的自动类型转换</title>
      <link href="/2020/09/12/kotlin-auto-type-conversion/"/>
      <url>/2020/09/12/kotlin-auto-type-conversion/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 1.4 正式版在好早以前就已经发布了。关于那些“看得见”的新特性，比如SAM转换、参数列表末尾的可选逗号什么的，已经有无数文章介绍过了。所以本文打算介绍一些可能是鲜为人知的、Kotlin 官方团队偷偷塞进 1.4 的新特性。<a id="more"></a></p><p>不过单独讲这些东西会显得文章太过单薄，于是我打算把其他相似的东西拉一起凑凑字数。</p><p>本文使用的 Kotlin 版本为 Kotlin 1.4。</p><h2 id="本文要讲的东西"><a href="#本文要讲的东西" class="headerlink" title="本文要讲的东西"></a>本文要讲的东西</h2><p>看题目就知道了，Kotlin 里自动类型转换（automatic type conversion）。这里讲的不是 「把一个 <code>String</code> 转成 <code>Any</code>，再转成 <code>String</code>」 这种和子类型有关的东西，当然也不是 Smart Cast，而是两个不相容的类型之间的转换，比如说 <code>Int</code> 转成 <code>Long</code>，如下文所示。</p><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>一般地，在 Kotlin 里我们不能像 Java 一样直接把一个 <code>Int</code> 类型的东西赋值给 <code>Long</code> 类型的变量，因为它们之间并不具有子类型关系。像下面这样会得到一个编译错误：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> int<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">555</span><span class="token keyword">val</span> long<span class="token operator">:</span> Long <span class="token operator">=</span> int <span class="token comment" spellcheck="true">// 编译错误！</span><span class="token function">println</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span></code></pre><p>你需要调用标准库提供给你的那些 <code>toXXX</code> 函数把数值转换成其他类型的数值。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> int<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">555</span><span class="token keyword">val</span> long<span class="token operator">:</span> Long <span class="token operator">=</span> int<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// OK</span><span class="token function">println</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span></code></pre><p>Kotlin 官方团队曾经表示过不喜欢隐式（implicit）的东西，关于数值的隐式类型转换也包括在内。这就导致了使用 Kotlin 在进行一些关于数值方面的操作时，有时候会写出一些看起来无比蛋疼的代码。</p><blockquote><p>Bennyhuo：就是有时候写点儿计算比较多的代码，满篇的 toFloat toDouble。</p></blockquote><p>不一般地，我们可以使用 <code>@Suppress</code> 来搞事：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> int<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">233</span><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"TYPE_MISMATCH"</span><span class="token punctuation">)</span><span class="token keyword">val</span> long<span class="token operator">:</span> Long <span class="token operator">=</span> int<span class="token function">println</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 233</span></code></pre><p>这个代码是可以跑起来的，而且你真的可以从字节码里看到那个把 <code>Int</code> 转成 <code>Long</code> 的指令 <code>I2L</code>。</p><p>不过我不确定 Kotlin 的其他 target 是否能这样用，我也不保证这样写完全不会出问题。（这里是关于 <code>@Suppress</code> 的免责声明，请读者自行脑补）</p><h2 id="SAM-Conversion"><a href="#SAM-Conversion" class="headerlink" title="SAM Conversion"></a>SAM Conversion</h2><p>SAM 转换也是一种自动类型转换。它把一个 lambda 表达式（具有函数类型）转成某个具体的接口类型。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token keyword">interface</span> ISome <span class="token punctuation">{</span>   <span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">useSome</span><span class="token punctuation">(</span>some<span class="token operator">:</span> ISome<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>useSome <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"some"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>在我的<a href="https://aisia.moe/2020/09/12/kotlin-sam-history/">另一篇文章</a>里有更详细的介绍。</p><p>如果读者不同意这个说法，可以选择跳过本小节内容。</p><h2 id="Coercion-to-Unit"><a href="#Coercion-to-Unit" class="headerlink" title="Coercion to Unit"></a>Coercion to Unit</h2><p>我们都知道 Kotlin 的 lambda 表达式是使用里面最后一个表达式的值来作为 lambda 的返回值的。比如这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> block <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"yeah"</span> <span class="token punctuation">}</span></code></pre><p>block 的类型是 <code>() -&gt; String</code>。</p><p>然后我们来看看这样的情况：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>test <span class="token punctuation">{</span> <span class="token string">"yeah"</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 输出 Unit</span></code></pre><p>相信很多人都熟悉这样的写法。</p><p>在某些初学者的眼里这看起来像是把一个 <code>() -&gt; String</code> 类型的 lambda 传给了需要 <code>() -&gt; Unit</code> 类型的函数。</p><p>这就是 <strong>coercion to unit</strong>，一个很久以前就存在的特性，可以理解为编译器自动帮你在 lambda 表达式的最后加了一行 <code>Unit</code>，把本来应该是<code>() -&gt; String</code> 类型的 lambda 变成了 <code>() -&gt; Unit</code> 类型。</p><p>在 Kotlin 1.4 版本，这个特性得到了进化，你甚至可以这样写：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token string">"str"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 需要 Kotlin 1.4 版本</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token operator">::</span>some<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出 Unit</span></code></pre><p>编译器帮你把 <code>() -&gt; String</code> 类型的函数引用转成了 <code>() -&gt; Unit</code>。</p><h2 id="Unit-Conversion"><a href="#Unit-Conversion" class="headerlink" title="Unit Conversion"></a>Unit Conversion</h2><p><strong>警告：这是一项未完成的特性！</strong></p><p>添加编译器参数 <code>-XXLanguage:+UnitConversion</code>，你就开启了一个 Kotlin 官方团队偷偷塞进 1.4 版本的未完成的新特性。</p><p>这个特性允许你写出这样的代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">test</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里是重点</span>   <span class="token comment" spellcheck="true">// 如果你不加那个编译器参数，会报错</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   some <span class="token punctuation">{</span> <span class="token string">"str"</span> <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 理论上会输出 Unit</span><span class="token punctuation">}</span></code></pre><p>在函数 some 里把一个 <code>() -&gt; String</code> 传给了 test 函数，可以看出来这个特性其实和 coercion to unit 是差不多的。</p><p>理论上这样的代码运行时会输出 <code>Unit</code>，但是目前由于该特性的代码生成没写好，得不到预期的结果。</p><p>另外，在开启了这个特性后，<code>() -&gt; String</code> 并不会成为 <code>() -&gt; Unit</code> 的子类型，它们依然是两个不相容的类型。</p><h2 id="Suspend-Conversion"><a href="#Suspend-Conversion" class="headerlink" title="Suspend Conversion"></a>Suspend Conversion</h2><p><strong>警告：这是一项未完成的特性！</strong></p><p>这是本文要介绍的第二个 Kt 官方团队偷偷塞进 1.4 版本的未完成的新特性。</p><p>比如说我们有这样的一个函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>f<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// do something with f</span><span class="token punctuation">}</span></code></pre><p>我们可以这样调用它：</p><pre class=" language-kotlin"><code class="language-kotlin">test <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> </code></pre><p>但是这样不行：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> f <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 编译错误</span></code></pre><p>编译器会告诉你类型不匹配，<code>f</code> 是 <code>() -&gt; Unit</code> 类型，<code>test</code> 函数需要 <code>suspend () -&gt; Unit</code> 类型的参数。</p><p>当你添加了编译器参数 <code>-XXLanguage:+SuspendConversion</code>，就可以让上面的代码通过编译。</p><p>也就是说这个特性可以帮你把普通函数类型的值转成 suspend 函数类型。</p><p>当然由于这是未完成的功能，即使可以通过编译，但是跑起来还是会炸。</p><p>这个特性或许会在 Kotlin 1.5 版本完工，但请不要抱有期待。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>我并不想讨论「为什么要加这种奇怪的特性」之类的话题。</p><p>不可否认的是，在有限的程序员生涯中，这些新特性可能一次也用不上。上面提到的问题也都有相应的 workaround，不需要新特性也可以写出等价的代码，就是没有那么优雅罢了（</p><p>本文完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Kotlin的SAM转换的破事水</title>
      <link href="/2020/09/12/kotlin-sam-history/"/>
      <url>/2020/09/12/kotlin-sam-history/</url>
      
        <content type="html"><![CDATA[<p>随着 Kotlin 1.4 正式发布，关于 SAM 转换的一些问题就可以盖棺定论了。因为这里要讲的都是些旧的东西，所以这是一篇灌水文。<a id="more"></a></p><h2 id="Kotlin对SAM转换的支持情况"><a href="#Kotlin对SAM转换的支持情况" class="headerlink" title="Kotlin对SAM转换的支持情况"></a>Kotlin对SAM转换的支持情况</h2><p>在 1.4 发布之前，经常有新人在群里提出关于 SAM 转换的问题。</p><p>为了说明这个问题，要分成几个情况来讨论。</p><p>我们需要区分这个接口是Java接口还是Kotlin接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是Java</span><span class="token keyword">interface</span> <span class="token class-name">JavaSome</span> <span class="token punctuation">{</span>   <span class="token keyword">void</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 这是Kotlin</span><span class="token keyword">interface</span> KotlinSome <span class="token punctuation">{</span>   <span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>以及区分在Java还是Kotlin里使用该接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是Java, ISome是一个接口</span><span class="token keyword">void</span> <span class="token function">useSome</span><span class="token punctuation">(</span>ISome some<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 这是Kotlin, ISome是一个接口</span><span class="token keyword">fun</span> <span class="token function">useSome</span><span class="token punctuation">(</span>some<span class="token operator">:</span> ISome<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>两两相乘，我们就需要对4种情况进行讨论。当然，<code>useSome</code> 函数都是在 Kotlin 里调用。</p><h3 id="1、Java接口，Java使用"><a href="#1、Java接口，Java使用" class="headerlink" title="1、Java接口，Java使用"></a>1、Java接口，Java使用</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Java</span><span class="token keyword">void</span> <span class="token function">useSome</span><span class="token punctuation">(</span>JavaSome some<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin</span>useSome <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// OK</span></code></pre><p>这种情况下的 SAM 转换，是自古以来 Kotlin 就支持的。</p><h3 id="2、Java接口，Kotlin使用"><a href="#2、Java接口，Kotlin使用" class="headerlink" title="2、Java接口，Kotlin使用"></a>2、Java接口，Kotlin使用</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin</span><span class="token keyword">fun</span> <span class="token function">useSome</span><span class="token punctuation">(</span>some<span class="token operator">:</span> JavaSome<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>useSome <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 能否编译成功跟Kotlin版本和编译器参数有关</span></code></pre><p>Kotlin 1.2 以及更旧版本不支持这种情况下的SAM转换。</p><p>Kotlin 1.3 版本，Kotlin 官方团队发现他们写的那堆类型推断算法是一座“屎山”，于是重新写了套新的类型推断算法，作为默认关闭的实验性特性加入了 1.3 版本。新的类型推断算法支持这种情况下的SAM转换，不过需要<a href="https://aisia.moe/2018/01/07/kotlin-jiqiao/#%E5%BC%80%E5%90%AF%E6%AE%8B%E5%BA%9F%E7%9A%84SAM%E8%BD%AC%E6%8D%A2%E5%8A%9F%E8%83%BD">手动传入编译器参数来开启这个功能</a>。</p><p>Kotlin 1.4 版本，由于新的类型推断算法已经默认开启，所以这种情况下可以进行SAM转换。</p><h3 id="3、Kotlin接口，Kotlin使用"><a href="#3、Kotlin接口，Kotlin使用" class="headerlink" title="3、Kotlin接口，Kotlin使用"></a>3、Kotlin接口，Kotlin使用</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin</span><span class="token keyword">fun</span> <span class="token function">useSome</span><span class="token punctuation">(</span>some<span class="token operator">:</span> KotlinSome<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>useSome <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 编译错误！</span></code></pre><p>这就是广为人知、为人诟病的垃圾 Kotlin 不支持 SAM 转换的情况。</p><p>在 Kotlin 1.4 版本，你需要在接口前加上关键字 fun，让它成为一个 fun interface 才能享受到 SAM 转换。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin</span><span class="token keyword">fun</span> <span class="token keyword">interface</span> KotlinSome <span class="token punctuation">{</span>   <span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">useSome</span><span class="token punctuation">(</span>some<span class="token operator">:</span> KotlinSome<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>useSome <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// OK</span></code></pre><p>当然 1.3 版本就别想了，老老实实升级吧。</p><h3 id="4、Kotlin接口，Java使用"><a href="#4、Kotlin接口，Java使用" class="headerlink" title="4、Kotlin接口，Java使用"></a>4、Kotlin接口，Java使用</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Java</span><span class="token keyword">void</span> <span class="token function">useSome</span><span class="token punctuation">(</span>KotlinSome some<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin</span>useSome <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 需要是 fun interface</span></code></pre><p>非常少见。</p><p>和上面的第三种情况一样，这需要 Kotlin 1.4 版本的 fun interface 才能进行 SAM 转换。</p><h3 id="5、带有suspend函数的Kotlin接口"><a href="#5、带有suspend函数的Kotlin接口" class="headerlink" title="5、带有suspend函数的Kotlin接口"></a>5、带有suspend函数的Kotlin接口</h3><p><del>四天王有五个人不是常识么</del></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token keyword">interface</span> Some <span class="token punctuation">{</span>   suspend <span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">useSome</span><span class="token punctuation">(</span>some<span class="token operator">:</span> KotlinSome<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>useSome <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 嘻嘻</span></code></pre><p>在 Kotlin 1.4 的测试版（里程碑版、RC版），可以编译成功，但是运行起来会炸。原因在于 Kotlin 官方团队并没有写好针对这种情况的代码生成（codegen）。于是在 Kotlin 1.4 正式版，他们就 ban 掉了这样的代码，不允许 <code>fun interface</code> 拥有抽象 <code>suspend</code> 函数。</p><h3 id="6、一些旧版本的bug"><a href="#6、一些旧版本的bug" class="headerlink" title="6、一些旧版本的bug"></a>6、一些旧版本的bug</h3><p>最经典的是那个安卓的LiveData的某个函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> liveData <span class="token operator">=</span> MutableLiveData<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>liveData<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">{</span> lifecycleOwner<span class="token punctuation">.</span>lifecycle <span class="token punctuation">}</span><span class="token punctuation">,</span> Observer <span class="token punctuation">{</span> <span class="token function">invokeMyMethod</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 第二个参数无法进行SAM转换</span></code></pre><p>详见<a href="https://youtrack.jetbrains.com/issue/KT-14984" target="_blank" rel="noopener">KT-14984</a>。</p><p>新的类型推断算法修正了这个bug。</p><h2 id="SAM-Constructor"><a href="#SAM-Constructor" class="headerlink" title="SAM Constructor"></a>SAM Constructor</h2><p>在 1.3 以及更早的版本，针对上面所说的第二种情况，可以这样使用：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin</span><span class="token keyword">fun</span> <span class="token function">useSome</span><span class="token punctuation">(</span>some<span class="token operator">:</span> JavaSome<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">useSome</span><span class="token punctuation">(</span>JavaSome <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>想必各位过来人都知道这样的写法。</p><p>这里 <code>JavaSome {}</code>，lambda 表达式前面的那个 <code>JavaSome</code> 就是所谓的 SAM 构造器（SAM constructor），或者说是 SAM 适配器（SAM adapter）。</p><p>在现在 1.4 版本里，SAM constructor 已经没什么用了，主要用途是“凭空捏出”一个 SAM 接口的实例：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> ktSome <span class="token operator">=</span> KotlinSome <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 需要是 fun interface</span><span class="token keyword">val</span> javaSome <span class="token operator">=</span> JavaSome <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 错误用法</span><span class="token comment" spellcheck="true">// val ktSome: KotlinSome = {}</span><span class="token comment" spellcheck="true">// val javaSome: JavaSome = {}</span></code></pre><p>SAM constructor 可以理解为编译器为 SAM 接口生成了一个如下所示的辅助函数，但是实际上这个函数并不存在。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是Java</span><span class="token keyword">interface</span> <span class="token class-name">JavaSome</span> <span class="token punctuation">{</span>   <span class="token keyword">void</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 实际上并不存在的辅助函数</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">JavaSome</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> JavaSome <span class="token punctuation">{</span>   <span class="token keyword">return</span> 编译器的魔法<span class="token punctuation">}</span></code></pre><p>然后就有一些鲜为人知的用法，比如说这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin</span><span class="token keyword">val</span> lambda<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">val</span> kepa<span class="token operator">:</span> JavaSome <span class="token operator">=</span> <span class="token function">JavaSome</span><span class="token punctuation">(</span>lambda<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 嘻嘻</span>kepa<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出 test</span></code></pre><p>上面这段代码确实是可以跑的。</p><p>甚至是这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> lambda<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">val</span> some<span class="token operator">:</span> KFunction1<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">,</span> JavaSome<span class="token operator">></span> <span class="token operator">=</span> <span class="token operator">::</span>JavaSome <span class="token comment" spellcheck="true">// 嘻嘻</span><span class="token keyword">val</span> kepa<span class="token operator">:</span> JavaSome <span class="token operator">=</span> some<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>lambda<span class="token punctuation">)</span>kepa<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这段代码 IDEA 不会提示错误，但是会编译失败。</p><p>表面上看确实有这个辅助函数，所以这样的代码可以通过 Kotlin 编译器前端的检查。但是实际上编译器的后端并没有办法针对这样的情况进行代码生成，彻底懵逼了，boom！</p><h2 id="你学到了什么"><a href="#你学到了什么" class="headerlink" title="你学到了什么"></a>你学到了什么</h2><ul><li>一些无用的历史知识</li><li>关于 SAM constructor 的冷知识</li></ul><p>本文完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin：比private更加自私的private to this</title>
      <link href="/2020/07/17/kotlin-private-to-this/"/>
      <url>/2020/07/17/kotlin-private-to-this/</url>
      
        <content type="html"><![CDATA[<p>可见性修饰符 <code>private</code>，对于顶层声明来说是该文件内可见，对于类内部的成员来说是该类内部可见，这是大家都知道的事。不过 Kotlin 里还存在着可见范围更小的，那就是 <code>private to this</code>，仅对 <code>this</code> 可见 。<a id="more"></a></p><p>我们先从泛型逆变（contravariant）说起。比如说我们有一个消费者：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Consumer<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">fun</span> <span class="token function">consume</span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> Unit<span class="token punctuation">}</span></code></pre><p>它的类型参数 <code>T</code> 是逆变的。这意味着 <code>T</code> 只能出现在成员的输入位置，如例子中 <code>consume</code> 函数的参数位置，而不能出现在成员的输出位置（比如说返回值位置）。这个限制是为了确保类型安全。</p><p>然后因为是逆变的，这使得 <code>Consumer&lt;CharSequence&gt;</code> 是 <code>Consumer&lt;String&gt;</code> 的子类型：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>c<span class="token operator">:</span> Consumer<span class="token operator">&lt;</span>CharSequence<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> consumer <span class="token operator">:</span> Consumer<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token operator">=</span> c   consumer<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>毕竟 <code>String</code> 是 <code>CharSequence</code> 的子类型，如果一个东西是字符串，那么这个东西也可以是一个字符序列。然后一个消费 <code>CharSequence</code> 的消费者当然可以拿一个 <code>String</code> 当做 <code>CharSequence</code> 来消费，所以说 “消费 <code>String</code> 的消费者” 可以用 “消费 <code>CharSequence</code> 的消费者” 来代替。</p><p>这个替代关系很好地阐释了 <code>Consumer&lt;CharSequence&gt;</code> 是 <code>Consumer&lt;String&gt;</code> 的子类型。</p><p>现在我们改一下消费者的逻辑，把接口删了换成类，并且让她在出生的时候就能拿到消费品，这样并不会改变逆变的性质：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Consumer<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">val</span> somethingToConsume<span class="token operator">:</span> T <span class="token operator">=</span> t   <span class="token keyword">fun</span> <span class="token function">consumeMyThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span>somethingToConsume<span class="token punctuation">)</span>   <span class="token keyword">fun</span> <span class="token function">consume</span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> consumer <span class="token operator">:</span> Consumer<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token operator">=</span> Consumer<span class="token operator">&lt;</span>Any<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   consumer<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>是时候回归主题了，我们的消费者小姐，她的 <code>somethingToConsume</code>，可见性就是 <code>private to this</code>，仅对 <code>this</code> 可见。 </p><p>比如说消费者小姐看中了别人的消费品，想要抢过来玩：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Consumer<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">val</span> somethingToConsume<span class="token operator">:</span> T <span class="token operator">=</span> t   <span class="token keyword">fun</span> <span class="token function">consumeMyThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span>somethingToConsume<span class="token punctuation">)</span>   <span class="token keyword">fun</span> <span class="token function">consumeOthers</span><span class="token punctuation">(</span>other<span class="token operator">:</span> Consumer<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token punctuation">{</span>      <span class="token keyword">val</span> string <span class="token operator">=</span> other<span class="token punctuation">.</span>somethingToConsume      <span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// Error: Cannot access 'somethingToConsume'</span>      <span class="token comment" spellcheck="true">// It is private</span><span class="token comment" spellcheck="true">/*private to this*/</span> <span class="token keyword">in</span> <span class="token string">'Consumer'</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编译器看到了这样的违法行为，马上阻止了她：你只能玩你自己的东西。</p><p>之所以 <code>consumeMyThing</code> 可以通过编译，是因为通过 <code>this</code> 调用 <code>somethingToConsume</code> （<code>this</code> 省略了）；在 <code>consumeOthers</code> 函数里调用 <code>somethingToConsume</code> 用的不是 <code>this</code>，所以失败了。仅对 <code>this</code> 可见，字面意思。</p><p>为什么会有这样的限制呢？原因很简单，<code>consumeOthers</code> 的代码其实是违反了逆变泛型参数的安全限制，<code>other.somethingToConsume</code> 这里实际上是 <code>other</code> 在对外输出 <code>T</code>，眼尖的同学可能早就发现了，<code>somethingToConsume</code> 的 <code>T</code> 是处在输出的位置上的。</p><p>但是“输出”是相对的，一个 <code>private</code> 的东西，自产自销自己用，那不算输出，是安全的。但是像上面那样从别人家里那东西，那就相当于是别人在输出了。</p><p>可以演示一下如果不存在 <code>private to this</code> 的限制会发生什么问题。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Consumer<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">val</span> somethingToConsume<span class="token operator">:</span> T <span class="token operator">=</span> t   <span class="token keyword">fun</span> <span class="token function">consumeMyThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span>somethingToConsume<span class="token punctuation">)</span>   <span class="token keyword">fun</span> <span class="token function">consumeOthers</span><span class="token punctuation">(</span>other<span class="token operator">:</span> Consumer<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token punctuation">{</span>      <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"INVISIBLE_MEMBER"</span><span class="token punctuation">)</span>      <span class="token keyword">val</span> string <span class="token operator">=</span> other<span class="token punctuation">.</span>somethingToConsume <span class="token comment" spellcheck="true">// dangerous!!</span>      <span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> intConsumer <span class="token operator">=</span> <span class="token function">Consumer</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>   <span class="token keyword">val</span> anyConsumer <span class="token operator">=</span> <span class="token function">Consumer</span><span class="token punctuation">(</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 因为是逆变的，所以 Consumer&lt;Any> 是 Consumer&lt;String> 的子类型</span>   intConsumer<span class="token punctuation">.</span><span class="token function">consumeOthers</span><span class="token punctuation">(</span>anyConsumer<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// intConsumer 想要从别人手里拿到一个 String，但是实际上拿到的是 Any</span><span class="token punctuation">}</span></code></pre><p>这里使用了我的<a href="https://aisia.moe/2018/12/09/kotlin-suppress/">那篇文章</a>介绍的技巧，使用 <code>@Suppress(&quot;INVISIBLE_MEMBER&quot;)</code> 强行无视可见性的限制。</p><p>运行代码然后就得到了一个类型转换异常：</p><pre><code>Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.String    at Consumer.consumeOthers</code></pre><p>所以现在来总结一下。当一个类、接口的逆变的泛型参数出现在 <code>private</code> 成员的输出位置时（比较常见的是返回值位置），那么那个 <code>private</code> 成员，实际上可见性是 <code>private to this</code>。举例：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Test<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">val</span> foo<span class="token operator">:</span> T <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">private</span> <span class="token keyword">var</span> bar<span class="token operator">:</span> T <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">bas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>为了允许上面这些代码合法存在，但是又要禁止不安全的调用，这就是为什么要有 <code>private to this</code> 的原因。</p><p>本文完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin标准库里的那些internal注解</title>
      <link href="/2020/07/16/kotlin-internal-annotations/"/>
      <url>/2020/07/16/kotlin-internal-annotations/</url>
      
        <content type="html"><![CDATA[<p>本文介绍一下 Koltin 标准库里面 <code>kotlin.internal</code> 这个包里的一些注解的作用。这些注解在 Kotlin 官网上的参考文档上没有任何提及，而且在网上搜也没有什么文章介绍，源码里的注释也只是寥寥几句话，难以理解。<a id="more"></a>虽然是声明为 <code>internal</code> 的，但是许多开发者（包括一些 JetBrains 员工）在非 Kotlin 标准库的项目中也有使用。</p><p>本文使用的 Kotlin 版本为 1.3.72。如果您使用的是 1.4 版本的 Kotlin，并且想要验证本文代码中与类型推断有关的部分，请添加编译器参数 <code>-XXLanguage:-NewInference</code> 关闭充满 bug 的新类型推断算法！</p><p><strong>另外由于文笔太差，本文不保证读者能看懂。</strong></p><h2 id="都有哪些注解"><a href="#都有哪些注解" class="headerlink" title="都有哪些注解"></a>都有哪些注解</h2><p>可以直接点开这个<a href="https://github.com/JetBrains/kotlin/blob/deb416484c5128a6f4bc76c39a3d9878b38cec8c/libraries/stdlib/src/kotlin/internal/Annotations.kt" target="_blank" rel="noopener">链接</a>查看。</p><p>或者在IDEA里随便点开个 kt 文件，复制粘贴下面代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   kotlin<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>NoInfer<span class="token punctuation">}</span></code></pre><p>光标定位到 NoInfer 处，按下 跳转到定义 的快捷键（Ctrl+B），就可以看到了。</p><h2 id="如何使用这些注解"><a href="#如何使用这些注解" class="headerlink" title="如何使用这些注解"></a>如何使用这些注解</h2><p>这些注解被声明为 <code>internal</code>，意味着该成员只在相同模块内可见，也就是只有 Kotlin 标准库能用这些注解。</p><p>这并不代表我们不能用他，有两种方法可以绕开限制。</p><p>其中一种方法我已经在之前<a href="https://aisia.moe/2018/03/25/kotlin-contracts-dsl/">介绍 Contracts DSL 的文章</a>里提到过了，在自己的项目里新建一个 kt 文件，把这些注解的源码一个不漏地复制粘贴进去（包括包名），然后添加编译器参数 <code>-Xallow-kotlin-package</code> （允许使用 kotlin 开头的包名），就可以使用了。这里有个现成的例子可以模仿 <a href="https://github.com/orangy/squash/blob/dc025481b7104a5e234d6df370d715b6b37c81eb/squash-core/src/kotlin/internal/InferenceAnnotations.kt" target="_blank" rel="noopener">orangy/squash</a>。</p><p>第二种方法是利用了我<a href="https://aisia.moe/2018/12/09/kotlin-suppress/">另一篇文章</a>介绍的可以使用注解 <code>@Suppress</code> 强行消除编译错误。如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"INVISIBLE_REFERENCE"</span><span class="token punctuation">,</span> <span class="token string">"INVISIBLE_MEMBER"</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suppressTest</span><span class="token punctuation">(</span>some<span class="token operator">:</span> <span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>internal<span class="token punctuation">.</span>NoInfer T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>个人比较推荐第二种方法。</p><h2 id="Magic-Inference-Annotations"><a href="#Magic-Inference-Annotations" class="headerlink" title="Magic Inference Annotations"></a>Magic Inference Annotations</h2><p>在大多数场景下，Kotlin 编译器的类型推断的默认行为足以满足需求。但是有时候会遇到一些例外情况需要我们对类型推断进行微调，于是就有了这些 magic inference annotations（官方就是这么称呼的）。</p><p>准确地说，它们都是对泛型的类型推导进行微调。</p><p>在介绍这些与类型推断有关的注解前先来了解一些 <strong>前 置 知 识</strong>，让我们来了解一下类型推断的大致流程（我会省略许多与本文无关的细节）。首先我们来看以下代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> <span class="token function">some</span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> R <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> result<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token number">1551</span><span class="token punctuation">)</span></code></pre><p>编译器首先会从代码中获得一些信息，称为类型约束（type constraint）。代码中对 <code>some</code> 这个函数进行调用，将 <code>1551</code> 作为参数传给 <code>some</code>，把返回值赋值给类型为 <code>String</code> 的变量 <code>result</code>，编译器最终获得了两条约束：Int 是 T 的子类型，R 是 String 的子类型。（省略了很多细节）</p><p>然后由编译器的类型约束求解器（type constraint solver）对这些约束进行进一步的处理，最终获得类型推断的结果：T 推导为 Int，R 推导为 String。（省略了非常多的细节，怎样画马.jpg）</p><p>接下来开始正式介绍。</p><p>重新提一遍，如果您使用的是 1.4 版本的 Kotlin，并且想要验证本文代码，请添加编译器参数 <code>-XXLanguage:-NewInference</code> 关闭新类型推断算法！这个新类型推断算法对 magic inference annotations 的支持并不够好，还存在一些 bug。</p><p>（这里并不是说 1.3.72 版本的旧类型推断算法就没有 bug 了，只是本文的示例代码并没有涉及旧类型推断算法已知的 bug。）</p><h3 id="NoInfer"><a href="#NoInfer" class="headerlink" title="@NoInfer"></a>@NoInfer</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">package</span> kotlin<span class="token punctuation">.</span>internal<span class="token annotation builtin">@Target</span><span class="token punctuation">(</span>AnnotationTarget<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation builtin">@Retention</span><span class="token punctuation">(</span>AnnotationRetention<span class="token punctuation">.</span>BINARY<span class="token punctuation">)</span><span class="token keyword">internal</span> <span class="token keyword">annotation</span> <span class="token keyword">class</span> NoInfer</code></pre><blockquote><p>Specifies that the corresponding type should be ignored during type inference.</p></blockquote><p><code>kotlin.internal.NoInfer</code> 比较简单，当一个类型被标注为 <code>@NoInfer</code> ，类型约束求解器并不会利用该类型提供的约束进行求解，编译器只检查类型推断的结果是否与约束相符合。简单地说就是不参与类型推断。比如下面的代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 本文以后的代码默认带有这两行，@Suppress和import</span><span class="token annotation builtin">@file:Suppress</span><span class="token punctuation">(</span><span class="token string">"INVISIBLE_REFERENCE"</span><span class="token punctuation">,</span> <span class="token string">"INVISIBLE_MEMBER"</span><span class="token punctuation">)</span><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>internal<span class="token punctuation">.</span><span class="token operator">*</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">someFun</span><span class="token punctuation">(</span>t1<span class="token operator">:</span> T<span class="token punctuation">,</span> t2<span class="token operator">:</span> <span class="token annotation builtin">@NoInfer</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">someFun</span><span class="token punctuation">(</span><span class="token string">"str"</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 编译错误</span>   <span class="token comment" spellcheck="true">// someFun("str", "str2") // 这样是好的</span><span class="token punctuation">}</span></code></pre><p>对 <code>someFun</code> 的调用提供了两条类型约束： String 是 T 的子类型（来自第一个参数），Int 是 T 的子类型（来自第二个参数）。</p><p>但是因为 <code>someFun</code> 的定义里第二个参数的类型 <code>T</code> 上有 <code>@NoInfer</code> 注解，类型约束求解器无视了 “ Int 是 T 的子类型” 这条约束，仅使用第一条约束 “ String 是 T 的子类型” 进行求解，最终 T 推导成 String 类型。</p><p>编译器发现第二个参数的类型 <code>Int</code> 和类型推断的结果不符合：Int 不是 String 的子类型。于是编译错误就产生了。</p><p>PS：如果不加 <code>@NoInfer</code> 注解，那么类型约束求解器会根据那两条约束将 <code>T</code> 推导成 <code>Any</code>。</p><p>再来看第二个例子：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">someFun2</span><span class="token punctuation">(</span>t<span class="token operator">:</span> <span class="token annotation builtin">@NoInfer</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">someFun2</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 编译错误</span>   <span class="token comment" spellcheck="true">// someFun2&lt;Int>(42) // 这样是好的，而且IDEA不会跟你讲&lt;Int>是多余的</span><span class="token punctuation">}</span></code></pre><p>在这个例子中，类型约束求解器实际上没有可用的类型约束，无法进行类型推断，需要在调用时显式传入泛型参数。</p><h3 id="Exact"><a href="#Exact" class="headerlink" title="@Exact"></a>@Exact</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">package</span> kotlin<span class="token punctuation">.</span>internal<span class="token annotation builtin">@Target</span><span class="token punctuation">(</span>AnnotationTarget<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation builtin">@Retention</span><span class="token punctuation">(</span>AnnotationRetention<span class="token punctuation">.</span>BINARY<span class="token punctuation">)</span><span class="token keyword">internal</span> <span class="token keyword">annotation</span> <span class="token keyword">class</span> Exact</code></pre><blockquote><p>Specifies that the constraint built for the type during type inference should be an equality one.</p></blockquote><p>@Exact 的注释在学习了上面的 <strong>前 置 知 识</strong> 后是非常好理解的。比如说这样的代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">someFun3</span><span class="token punctuation">(</span>t<span class="token operator">:</span> <span class="token annotation builtin">@Exact</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">someFun3</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>根据 <strong>前 置 知 识</strong>，类型约束求解器会拿到一条 “ Int 是 T 的子类型” 的约束。但是 <code>someFun3</code> 的定义里参数 <code>t</code> 的类型上有 <code>kotlin.internal.Exact</code> 注解，这个注解会将这个约束修改成 “ T 和 Int 是相同的类型”（不是很严谨，但大概是这么个意思）。于是类型约束求解器不假思索很快就把 T 推导成 Int。</p><p>下面用一个例子来说明：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U <span class="token operator">:</span> T<span class="token operator">></span> <span class="token function">someFun4</span><span class="token punctuation">(</span>list<span class="token operator">:</span> List<span class="token operator">&lt;</span><span class="token annotation builtin">@Exact</span> T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> U <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">test4</span><span class="token punctuation">(</span>list<span class="token operator">:</span> List<span class="token operator">&lt;</span>Number<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> i<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token function">someFun4</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这样是好的</span>   <span class="token keyword">val</span> s<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token function">someFun4</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 编译错误</span><span class="token punctuation">}</span></code></pre><p><code>someFun4</code> 接收一个 <code>List&lt;T&gt;</code> 类型的参数，返回一个类型为 <code>U</code> 的对象，<code>U</code> 是 <code>T</code> 的子类型，参数的类型 <code>List&lt;T&gt;</code> 的 <code>T</code> 被标记为 <code>@Exact</code>。</p><p><code>test4</code> 里给 <code>someFun4</code> 传入<code>List&lt;Number&gt;</code>类型的参数，类型约束实际上是 “ List&lt; Number&gt; 是 List&lt;@Exact T&gt; 的子类型”。不过因为 Kotlin 的 <code>List&lt;E&gt;</code> 在类型参数 <code>E</code> 上是协变的，所以那条约束其实等价于 “ Number 是 @Exact T 的子类型”，最终被 <code>@Exact</code> 注解修正为 “ T 和 Number 是相同的类型”。（省略了大量编译器如何处理约束的细节）</p><p>所以在 <code>test4</code> 里的第一行 <code>val i: Int = someFun4(list)</code>，有这样的约束：T 和 Number 是相同的类型，U 是 T 的子类型，U 是 Int 的子类型。最终结果为 T 推导为 Number、U 推导为 Int。</p><p>同理可知，第二行 <code>val s: String = someFun4(list)</code> 由于编译器找不到既是 Number 的子类型、又是 String 的子类型的类型，编译错误。</p><p>PS：如果不加 <code>@Exact</code> 注解，第二行的类型推断结果为 T 是 Any，U 是 String，不会有编译错误。</p><h3 id="OnlyInputTypes"><a href="#OnlyInputTypes" class="headerlink" title="@OnlyInputTypes"></a>@OnlyInputTypes</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">package</span> kotlin<span class="token punctuation">.</span>internal<span class="token annotation builtin">@Target</span><span class="token punctuation">(</span>AnnotationTarget<span class="token punctuation">.</span>TYPE_PARAMETER<span class="token punctuation">)</span><span class="token annotation builtin">@Retention</span><span class="token punctuation">(</span>AnnotationRetention<span class="token punctuation">.</span>BINARY<span class="token punctuation">)</span><span class="token keyword">internal</span> <span class="token keyword">annotation</span> <span class="token keyword">class</span> OnlyInputTypes</code></pre><blockquote><p>The value of this type parameter should be mentioned in input types (argument types, receiver type or expected type).</p></blockquote><p>终于可以丢掉那些无聊又难搞的类型约束了。<code>kotlin.internal.OnlyInputTypes</code> 和上面那两个注解不同，它是标注在类型参数上的，如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token annotation builtin">@OnlyInputTypes</span> T<span class="token operator">></span> <span class="token function">someFun5</span><span class="token punctuation">(</span>t1<span class="token operator">:</span> <span class="token annotation builtin">@NoInfer</span> T<span class="token punctuation">,</span> t2<span class="token operator">:</span> <span class="token annotation builtin">@Exact</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>这个注解对类型推断的结果添加了一个限制，要求这个结果必须在 input types 的位置上被提及。就像这个注解的注释所说的，可以是 argument types，receiver type 或者 expected type。这几个位置可以用代码来简单展示：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> result<span class="token operator">:</span> ExpectedType <span class="token operator">=</span> receiverType<span class="token punctuation">.</span><span class="token function">functionName</span><span class="token punctuation">(</span>argumentType<span class="token punctuation">)</span></code></pre><p>然后演示一下具体是什么意思：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token annotation builtin">@OnlyInputTypes</span> T<span class="token operator">></span> <span class="token function">someFun6</span><span class="token punctuation">(</span>t1<span class="token operator">:</span> T<span class="token punctuation">,</span> t2<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">open</span> <span class="token keyword">class</span> A<span class="token keyword">class</span> B <span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> C <span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> r1 <span class="token operator">=</span> <span class="token function">someFun6</span><span class="token punctuation">(</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 这个是好的</span>   <span class="token keyword">val</span> r2<span class="token operator">:</span> A <span class="token operator">=</span> <span class="token function">someFun6</span><span class="token punctuation">(</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这个也是好的</span>   <span class="token keyword">val</span> r3 <span class="token operator">=</span> <span class="token function">someFun6</span><span class="token punctuation">(</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 好不起来了！编译错误！</span>   someFun6<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 又好起来了</span><span class="token punctuation">}</span></code></pre><p>显而易见，<code>test6</code> 里面前3次对 <code>someFun6</code> 的调用的类型推断结果都是 T 推导为 A 类型。</p><p>第一次函数调用，A 类型出现在 argument type 的位置，第二次 A 类型出现在 expected type 的位置，符合 <code>@OnlyInputTypes</code> 这个注解的要求，所以编译通过。</p><p>第三次调用由于 A 类型在 input types 的位置上没有被提及，所以编译失败了。</p><p>至于第四次调用则是纯粹抛弃了类型推导，手动指明了泛型参数，与 <code>@OnlyInputTypes</code> 没有关系了。</p><p>这里举一个 Kotlin 标准库里的例子来说明这个看起来有点“奇葩”的限制有什么用：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 摘自 kotlin 标准库（有删减）</span><span class="token comment" spellcheck="true">/** * Returns `true` if [element] is found in the array. */</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token annotation builtin">@OnlyInputTypes</span> T<span class="token operator">></span> Array<span class="token operator">&lt;</span><span class="token keyword">out</span> T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">}</span></code></pre><p>然后有时候不小心写出了这样的代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">stupid</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> b <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"I want to find some String in an Int array. Oh! So stupid!"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 这里 T 推导为 Any</span><span class="token punctuation">}</span></code></pre><p>常识告诉我们，一个 Int 数组里不可能会有 String 元素，所以这行代码是无意义的。再看由于存在 <code>@OnlyInputTypes</code> 注解，类型推导的结果 Any 并没有出现在 input types 的位置上，所以编译失败了，从而阻止了这种无意义代码的产生。</p><p>PS：Kotlin 1.4 版本引入了一个默认开启的特性，将 <code>@OnlyInputTypes</code> 注解导致的编译错误（error）降级为警告（warring）。可以通过添加编译器参数 <code>-XXLanguage:-NonStrictOnlyInputTypesChecks</code> 关闭这个特性。（我并没有说一定要关闭这个特性）</p><p>PPS：可以在 Kotlin 标准库里搜索这三个注解都用在什么地方，理解这几个注解的实际用途。（我觉得都和我的举例差不多）</p><h2 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h2><h3 id="LowPriorityInOverloadResolution"><a href="#LowPriorityInOverloadResolution" class="headerlink" title="@LowPriorityInOverloadResolution"></a>@LowPriorityInOverloadResolution</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">package</span> kotlin<span class="token punctuation">.</span>internal<span class="token annotation builtin">@Target</span><span class="token punctuation">(</span>AnnotationTarget<span class="token punctuation">.</span>FUNCTION<span class="token punctuation">,</span> AnnotationTarget<span class="token punctuation">.</span>PROPERTY<span class="token punctuation">)</span><span class="token annotation builtin">@Retention</span><span class="token punctuation">(</span>AnnotationRetention<span class="token punctuation">.</span>BINARY<span class="token punctuation">)</span><span class="token keyword">internal</span> <span class="token keyword">annotation</span> <span class="token keyword">class</span> LowPriorityInOverloadResolution</code></pre><blockquote><p>Specifies that a corresponding member has the lowest priority in overload resolution.</p></blockquote><p>是名字超长的 <code>kotlin.internal.LowPriorityInOverloadResolution</code> ！</p><p>我觉得它的名字和注释已经很好地解释了它的作用。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">someFun7</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation builtin">@LowPriorityInOverloadResolution</span><span class="token keyword">fun</span> <span class="token function">someFun7</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">someFun7</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这将调用第一个someFun7</span>    <span class="token operator">::</span>someFun7   <span class="token comment" spellcheck="true">// 这将拿到第一个someFun7的引用</span><span class="token punctuation">}</span></code></pre><p>在标准库里多用于新旧 API 更替时，防止用户调用到旧的 API。</p><h3 id="HidesMembers"><a href="#HidesMembers" class="headerlink" title="@HidesMembers"></a>@HidesMembers</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">package</span> kotlin<span class="token punctuation">.</span>internal<span class="token annotation builtin">@Target</span><span class="token punctuation">(</span>AnnotationTarget<span class="token punctuation">.</span>FUNCTION<span class="token punctuation">,</span> AnnotationTarget<span class="token punctuation">.</span>PROPERTY<span class="token punctuation">)</span><span class="token annotation builtin">@Retention</span><span class="token punctuation">(</span>AnnotationRetention<span class="token punctuation">.</span>BINARY<span class="token punctuation">)</span><span class="token keyword">internal</span> <span class="token keyword">annotation</span> <span class="token keyword">class</span> HidesMembers</code></pre><blockquote><p>Specifies that the corresponding member has the highest priority in overload resolution.<br>Effectively this means that an extension annotated with this annotation will win in overload resolution over a member with the same signature.</p></blockquote><p><code>kotlin.internal.HidesMembers</code> 这个注解的名字和注释会给人造成一种错觉。</p><p>根据常识，Kotlin 的扩展函数不能覆盖成员函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> Kotlin官网的例子<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> Example <span class="token punctuation">{</span>        <span class="token keyword">fun</span> <span class="token function">printFunctionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Class method"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">fun</span> Example<span class="token punctuation">.</span><span class="token function">printFunctionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Extension function"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printFunctionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这将输出 Class method</span><span class="token punctuation">}</span></code></pre><p>但是 <code>@HidesMembers</code> 的确能让扩展函数覆盖成员函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Box<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">val</span> t1<span class="token operator">:</span> T<span class="token punctuation">,</span> <span class="token keyword">val</span> t2<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">fun</span> <span class="token function">forEach</span><span class="token punctuation">(</span>fn<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">fn</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span>      <span class="token function">fn</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation builtin">@HidesMembers</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Box<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"嘻嘻"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> box <span class="token operator">=</span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">)</span>   box<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 嘻嘻</span><span class="token punctuation">}</span></code></pre><p>你看 Kotlin 标准库里就是这么做的：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// kotlin标准库代码摘抄</span><span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>internal<span class="token punctuation">.</span>HidesMembers<span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Iterable<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>element <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token function">action</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这是为了隐藏来自 <code>java.lang.Iterable</code> 的 <code>forEach</code>。</p><p>不过这并不意味着我们可以随便用这个注解来做些七七八八的事情，在 Kotlin 编译器的源码里有这么一行代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// @HidesMembers annotation only has effect for members with these names</span><span class="token keyword">val</span> HIDES_MEMBERS_NAME_LIST <span class="token operator">=</span> <span class="token function">setOf</span><span class="token punctuation">(</span>Name<span class="token punctuation">.</span><span class="token function">identifier</span><span class="token punctuation">(</span><span class="token string">"forEach"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Name<span class="token punctuation">.</span><span class="token function">identifier</span><span class="token punctuation">(</span><span class="token string">"addSuppressed"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>意思是只有标识名是 <code>forEach</code> 和 <code>addSuppressed</code> 的成员才能用这个注解，是白名单制！</p><p>PS：强行覆盖的初衷是好的，但是偶尔也会带来一些副作用，比如 <a href="https://youtrack.jetbrains.com/issue/KT-39091" target="_blank" rel="noopener">KT-39091</a> 这是来自某开发者的吐槽。</p><h3 id="InlineOnly"><a href="#InlineOnly" class="headerlink" title="@InlineOnly"></a>@InlineOnly</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">package</span> kotlin<span class="token punctuation">.</span>internal<span class="token annotation builtin">@Target</span><span class="token punctuation">(</span>AnnotationTarget<span class="token punctuation">.</span>FUNCTION<span class="token punctuation">,</span> AnnotationTarget<span class="token punctuation">.</span>PROPERTY<span class="token punctuation">,</span> AnnotationTarget<span class="token punctuation">.</span>PROPERTY_GETTER<span class="token punctuation">,</span> AnnotationTarget<span class="token punctuation">.</span>PROPERTY_SETTER<span class="token punctuation">)</span><span class="token annotation builtin">@Retention</span><span class="token punctuation">(</span>AnnotationRetention<span class="token punctuation">.</span>BINARY<span class="token punctuation">)</span><span class="token keyword">internal</span> <span class="token keyword">annotation</span> <span class="token keyword">class</span> InlineOnly</code></pre><blockquote><p>Specifies that this function should not be called directly without inlining.</p></blockquote><p><code>kotlin.internal.InlineOnly</code> 这个注解只能给内联函数（或者内联属性）用，用在其他地方是没有效果的。</p><p>这个注解是希望调用内联函数必须能够内联，它的具体效果是将其所标记的内联函数的可见性修饰符在编译时改成 <code>private</code>（当然编译后也是 <code>private</code>）。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 编译前</span><span class="token annotation builtin">@InlineOnly</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">someFun9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 编译后</span><span class="token annotation builtin">@InlineOnly</span><span class="token keyword">private</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">someFun9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 不要纠结细节，意思意思就可以了</span></code></pre><p>这样可以阻止来自 Java 方面的调用。因为用 Java 调用 Kotlin 的内联方法并不会有内联效果。</p><h3 id="本文完"><a href="#本文完" class="headerlink" title="本文完"></a>本文完</h3><p>我觉得剩下的那几个不用讲了。</p><p>啊，还有个名字很长的可以稍微提一下。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"LATEINIT_INTRINSIC_CALL_ON_NON_LATEINIT"</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">println</span><span class="token punctuation">(</span><span class="token operator">::</span>fakeLateInit<span class="token punctuation">.</span>isInitialized<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"MUST_BE_INITIALIZED"</span><span class="token punctuation">)</span><span class="token keyword">var</span> fakeLateInit<span class="token operator">:</span> String   <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">throw</span> <span class="token function">Exception</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span></code></pre><p>把 <code>main</code> 函数上面的注解删掉就能看到那个名字很长的注解的用处了。</p><p>顺便讲一下那三个 magic inference annotations 的八卦。几年前 JB 员工就说过会在未来哪天将这几个注解转正成 <code>public</code> 的，但是直到现在还是老样子。那 JB 员工这几年都在干什么？都在修这些注解的 bug 呀。现在用 1.3.72，把 New Inference 一打开，就能看到 @Exact 的 bug。另外他们还在考虑给 @OnlyInputTypes 换一个更好的名字，以及更好的编译错误信息（逃</p><p>本文真的完了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin Suppress 的非常规用法</title>
      <link href="/2018/12/09/kotlin-suppress/"/>
      <url>/2018/12/09/kotlin-suppress/</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，有个叫 <a href="https://aisia.moe/java6api-cn/java/lang/SuppressWarnings.html">SuppressWarnings</a> 的注解，用于忽略特定的编译器警告。Kotlin 中也有一个类似功能的注解，叫做 <a href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-suppress/" target="_blank" rel="noopener">Suppress</a>，本文主要讲讲这个注解有什么用。<a id="more"></a></p><h2 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h2><p>有时候会写出这样的一些代码，在Kotlin编译器的眼里可能会出现问题，但是实际上却非常正确，跑起来不会出任何问题。</p><p>然后你就得到了一个编译器警告（warning），甚至是编译错误（error）。</p><p>比较常见的，比如说 unchecked cast：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> some<span class="token operator">:</span> List<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">=</span> emptyList<span class="token operator">&lt;</span>Nothing<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>some <span class="token keyword">as</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token comment" spellcheck="true">// Unchecked cast: List&lt;*> to List&lt;String></span></code></pre><p>然后就可以使用 Suppress 取消这个 warning：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> some<span class="token operator">:</span> List<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">=</span> emptyList<span class="token operator">&lt;</span>Nothing<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span>some <span class="token keyword">as</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span></code></pre><p>这是很简单的破事水，没有任何讨论的价值。</p><p>然后下面是正文。</p><p>好孩子不要模仿！很危险的！</p><h2 id="非常规用法"><a href="#非常规用法" class="headerlink" title="非常规用法"></a>非常规用法</h2><p>这破注释竟然能消除 error！</p><p>比如说这样的代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token keyword">as</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span></code></pre><p>编译器会告诉你这样是不对的，然后向你丢出了一个 error：</p><pre><code>Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?</code></pre><p>然后就可以使用 <code>Suppress</code> 让编译器闭嘴！</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNSAFE_CALL"</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token keyword">as</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span></code></pre><p>然后就可以顺利的通过编译，编译后跑一跑，就可以轻松地拿到一个空指针异常：</p><pre><code>Exception in thread &quot;main&quot; java.lang.NullPointerException    at .......</code></pre><p>很简单，有了 <code>Suppress</code>，你就可以让这些可以本来通过编译器生成java字节码，但是因为各种各样的原因（例如类型安全）被ban掉的代码，顺利通过编译。</p><p>下面给几个可能有用的例子。</p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span>any<span class="token operator">:</span> Any<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">when</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Cannot check for instance of erased type: Array&lt;String></span>      <span class="token keyword">is</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span>any<span class="token punctuation">.</span>size<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这是我吐槽过的「Java能做但是Kotlin做不了的事」系列之一。在Java你可以检查一个对象是不是某个特定的数组类型 <code>if (any instanceof String[])</code>，但是Kotlin把这个问题一刀切了，导致Kotlin不能直接做这样的type check。</p><p>不考虑Kotlin的其他target（如js），在Jvm平台上有如下的迂回：</p><pre class=" language-kotlin"><code class="language-kotlin">any <span class="token keyword">is</span> Array<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">&amp;&amp;</span> any<span class="token punctuation">.</span>isArrayOf<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>就是很丑罢了。</p><p>在Kotlin的早期代码，这样的 type check 是允许的，但是后来为了保证类型安全，ban 掉了这样的写法。这个时候可以用 <code>Suppress</code> 把这个后门打开。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span>any<span class="token operator">:</span> Any<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"CANNOT_CHECK_FOR_ERASED"</span><span class="token punctuation">)</span>   <span class="token keyword">when</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">is</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span>any<span class="token punctuation">.</span>size<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// Smart cast to Array&lt;String></span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>读者可以想想为什么要ban掉这样的代码，毕竟这种代码有可能会出现类型安全问题，要格外小心！</p><p>PS：这个其实也是可以对非数组的泛型使用的，例如这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"CANNOT_CHECK_FOR_ERASED"</span><span class="token punctuation">)</span><span class="token keyword">when</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">is</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span>any<span class="token punctuation">.</span>size<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// Smart cast to List&lt;String></span><span class="token punctuation">}</span></code></pre><p>这里实际上等价于以下代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">when</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">is</span> List<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>any <span class="token keyword">as</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>并不是大家都想要的真泛型（不信可以传个 <code>List&lt;Int&gt;</code> 什么的进去试试），只是上面的代码可以享受到 Smart Cast 罢了。</p><p>可想而知，这样的代码也是有类型安全问题的。</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>可以在非顶层空间定义类型别名。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"TOPLEVEL_TYPEALIASES_ONLY"</span><span class="token punctuation">)</span><span class="token keyword">class</span> Some <span class="token punctuation">{</span>   typealias Str <span class="token operator">=</span> String   <span class="token keyword">val</span> a<span class="token operator">:</span> Str <span class="token operator">=</span> <span class="token string">""</span>   <span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      typealias int <span class="token operator">=</span> Int      <span class="token keyword">val</span> some<span class="token operator">:</span> int <span class="token operator">=</span> <span class="token number">1</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>主要是为了限制类型别名的作用域。另外把类型别名定义在顶层一定会生成一个 <code>文件名Kt</code> 的 class，可以用这个方法避免这种情况的发生。</p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>Kotlin 在远古版本 <a href="https://blog.jetbrains.com/kotlin/2015/09/kotlin-m13-is-out/" target="_blank" rel="noopener">M13</a> 新增了 <code>lateinit</code> 修饰符，当时是可以对只读属性（val）和可变属性（var）使用。</p><p>然后在下一个版本 <a href="https://blog.jetbrains.com/kotlin/2015/10/kotlin-m14-is-out/" target="_blank" rel="noopener">M14</a> 就残忍地 ban 掉了 <code>lateinit val</code>。</p><p>现在你可以用 <code>Suppress</code> 绕开编译器对 <code>lateinit val</code> 的限制。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"INAPPLICABLE_LATEINIT_MODIFIER"</span><span class="token punctuation">)</span><span class="token keyword">lateinit</span> <span class="token keyword">val</span> lateInitVal<span class="token operator">:</span> String</code></pre><p><code>lateinit val</code> 的用处可以看上面 M13 的链接里面的说明。它的 backing field 并不是定义为 <code>final</code> 的，它和 <code>lateinit var</code> 的区别只是没有 setter，所以一般是配合各种注入框架来使用的。</p><p>但是没有 setter 并不能阻止我们直接对它进行赋值：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"INAPPLICABLE_LATEINIT_MODIFIER"</span><span class="token punctuation">)</span><span class="token keyword">lateinit</span> <span class="token keyword">val</span> some<span class="token operator">:</span> String<span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"VAL_REASSIGNMENT"</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   some <span class="token operator">=</span> <span class="token string">"1"</span>   <span class="token function">println</span><span class="token punctuation">(</span>some<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出 1</span>   some <span class="token operator">=</span> <span class="token string">"2"</span>   <span class="token function">println</span><span class="token punctuation">(</span>some<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出 2</span><span class="token punctuation">}</span></code></pre><p>嘻嘻~</p><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p>Kotlin Collection Literals 半成品。这个特性是JetBrains他们在17年4月份的时候做的关于Kotlin未来特性的一份<a href="https://drive.google.com/file/d/0BwAovUlww0CmVmNQTXd4TTdKYUU/view" target="_blank" rel="noopener">调查问卷</a>的第6个特性。简单地说是用一些特殊的语法来创建各种集合，而不是（丑陋的）<code>listOf</code>、<code>mapOf</code> 等标准库函数。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNSUPPORTED"</span><span class="token punctuation">)</span><span class="token keyword">val</span> bs<span class="token operator">:</span> BooleanArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span></code></pre><p>但是这是个未完成的功能，目前只支持数组，在未来计划支持 List、Map 和 Set 的创建。所以为了避免不必要的兼容性麻烦，在正常情况下只允许在注解里这样用。要想在其他地方用，就像上面代码那样加上 <code>Suppress</code> 注解。</p><h3 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h3><p>可以用来解决某些与 Java 互操作时 package private 可见性带来的问题。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是 Java 代码</span><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 仅包内可见</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 这是 Kotlin 代码</span><span class="token keyword">package</span> test<span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"EXPOSED_SUPER_CLASS"</span><span class="token punctuation">)</span><span class="token keyword">class</span> TestImpl <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>当去掉那行 Suppress 注解时编译无法通过。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>想知道更多的 Suppress 选项的话，可以去翻 Kotlin 的源码。</p><p>这种奇技淫巧是无法得到官方支持的，也许下次更新就挂掉了，所以如果用了那就后果自负吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin Experimental API</title>
      <link href="/2018/10/03/kotlin-experimental-api/"/>
      <url>/2018/10/03/kotlin-experimental-api/</url>
      
        <content type="html"><![CDATA[<p>本文随便讲讲Kotlin Experimental API。<a id="more"></a></p><p>为了防止篇幅太大，本文会省略一些无关紧要的东西。</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>首先我们知道在Kotlin的1.2版本里协程是实验性的，协程的那个包名里面有个十分显眼的experimental字样，用于告诉使用者这破玩意处于实验阶段。</p><p>然后，JB那帮人嫌这个标识方法很不方便，等到协程正式发布后会给迁移带来一定的麻烦。同时用包名声明实验性的这个方法太过粗犷，他们想要一种细粒度的（比如说可以对单个类甚至是单个函数）标记实验性质的机制。</p><p>所以就有了 Kotlin Experimental API。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>Kotlin 1.3 版本的标准库里新增了几个注解，如下</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin 标准库里的东西</span><span class="token annotation builtin">@Target</span><span class="token punctuation">(</span>ANNOTATION_CLASS<span class="token punctuation">)</span><span class="token keyword">annotation</span> <span class="token keyword">class</span> <span class="token function">Experimental</span><span class="token punctuation">(</span><span class="token keyword">val</span> level<span class="token operator">:</span> Level <span class="token operator">=</span> Level<span class="token punctuation">.</span>ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> Level <span class="token punctuation">{</span> WARNING<span class="token punctuation">,</span> ERROR <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">annotation</span> <span class="token keyword">class</span> <span class="token function">UseExperimental</span><span class="token punctuation">(</span>vararg <span class="token keyword">val</span> markerClass<span class="token operator">:</span> KClass<span class="token operator">&lt;</span><span class="token keyword">out</span> Annotation<span class="token operator">></span><span class="token punctuation">)</span></code></pre><p>Experimental是个元注解，只能打在注解类上。比如说，我想在代码中引入一项新的实验性功能，名字叫 zzz，就可以像这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Experimental</span><span class="token keyword">annotation</span> <span class="token keyword">class</span> zzz</code></pre><p>这样zzz就成为了一个「实验性标记」，声明了一个名为 zzz 的范畴。如果某些成员是 zzz 这个实验性功能的内容，就可以使用 zzz 标记它。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token label symbol">@zzz</span><span class="token keyword">fun</span> <span class="token function">someFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token label symbol">@zzz</span><span class="token keyword">class</span> SomeClass</code></pre><p>这样 SomeClass 和 someFun 就是 实验性功能 zzz 的成员了，如果你在其他地方使用了它们，编译器会提醒你正在使用的东西是实验性的。至于怎么提醒，看上面 Experimental 这个注解有一个参数 level，表示提醒的方式，在编译时是发出警告（warring）还是丢出错误（error），默认是编译错误。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">someFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Error: This declaration is experimental and its usage must be marked with '@zzz' or '@UseExperimental(zzz::class)'</span><span class="token punctuation">}</span></code></pre><p>如果要消除这个警告或者错误，就要使用UseExperimental这个注解，表示你已经意识到你正在使用的东西是实验性的。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@UseExperimental</span><span class="token punctuation">(</span>zzz<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">someFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ok</span><span class="token punctuation">}</span></code></pre><p>简单的说，在 @UseExperimental(zzz::class) 的作用域内，你可以随意调用 zzz 这个实验性功能的成员。比如说在 kt 文件开头处加上 @file:UseExperimental(zzz::class)，你就可以在整个文件里随便调用 zzz 的成员。</p><p>或者可以将 test 也一并纳入 zzz 的范畴，将 test 也声明为实验性功能。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token label symbol">@zzz</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">someFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ok</span><span class="token punctuation">}</span></code></pre><p>由此可见，此功能其实非常简单。一个是GPL式传播，另一个则能截断实验性的传播。</p><p>另外，Kotlin编译器新添加了两个编译器参数，-Xexperimental和-Xuse-experimental，对整个模块有效。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 编译器参数 -Xuse-experimental=zzz</span><span class="token comment" spellcheck="true">// 等号后接那个注解的完全限定名</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">someFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// もok</span><span class="token punctuation">}</span></code></pre><p>目前 Kotlin Experimental API 也是处在实验性阶段，如果你用到最上那两个标准库里的注解，需要使用编译器参数消除警告。</p><h2 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h2><p>在Kotlin 1.3版本目前有3个实验性功能，contract和unsigned integer，所以你想使用这两个功能的话，就会用到上述的 Experimental API。</p><p>库作者也可以受益于这项功能（但是如果有改api的话该炸还是会炸的（</p><p>本文完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 1.3 前瞻之 Inline Class</title>
      <link href="/2018/07/03/inline-class/"/>
      <url>/2018/07/03/inline-class/</url>
      
        <content type="html"><![CDATA[<blockquote><p>啊啦啦，垃圾 Kotlin，你又偷拿人家东西了！<a id="more"></a></p></blockquote><p>这几年各路语言的发展就是把 Haskell 吃剩下的再拿出来吃一遍，那么 Kotlin 也不例外（进入高级引战模式）。如果你精通 Haskell 或者 Scala，那太棒了，你不需要浪费时间阅读这篇辣鸡水文，请点击右上角的关闭按钮。</p><p>虽然说本文讲的是 Kotlin 1.3 版本的新特性，但是理论上 1.2.50 也能用（处于开发阶段，有大量 Bug，不建议日常使用）。如果想要体验这个实验性特性需要添加编译器参数 <code>-XXLanguage:+InlineClasses</code>。本文使用的 Kotlin 版本为 1.2.60-eap-7。</p><p>本文写于 Kotlin 1.2 的时代，由于 Inline Class 这个特性尚未正式实装，实际情况可能会有所变动，届时本文可能会有部分过时内容，然后针对 Kotlin 1.3 补充一些内容。</p><p>本文不会详细介绍各个细节，只抓重点讲。并且由于我太鶸，也许本文通篇错漏百出也说不定。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JB他们在17年4月份的时候，做了一份调查问卷，<a href="https://drive.google.com/file/d/0BwAovUlww0CmVmNQTXd4TTdKYUU/view" target="_blank" rel="noopener">Kotlin Future Features Survey</a>，内容是选出最希望实装的语言特性（20选3），后来得出的<a href="https://blog.jetbrains.com/kotlin/2017/06/kotlin-future-features-survey-results/" target="_blank" rel="noopener">调查结果</a>是 Inline Class 排第五。现在这个功能得以实装也算是众望所归了。</p><p>不过吃惊的是我没想到JB那帮人做得那么快，我还以为这特性要等到 Kotlin 2.0 才能摸出来。</p><h2 id="什么是-Inline-Class"><a href="#什么是-Inline-Class" class="headerlink" title="什么是 Inline Class"></a>什么是 Inline Class</h2><p>Inline Class，翻译成中文就是「内联类」。我们知道 Kotlin 有内联函数，可以消除函数调用的开销。那么内联类，则是可以消除创建对象的开销。</p><p>很强，是吧。如果不懂的话请往下看。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Duck</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span></code></pre><p>以上代码就声明了一个最简单的内联类。</p><p>内联类必须有一个主构造函数，并且在主构造函数里必须有且只有一个 val 属性，除此之外，不能再拥有其他的字段。（var 属性目前还没做好所以不能用。）</p><p>可以给内联类添加泛型、次级构造函数、方法以及没有 backing field 的属性，还可以实现接口：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Duck</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">"ywwuyi"</span><span class="token punctuation">)</span>   <span class="token keyword">fun</span> <span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Nothing <span class="token operator">=</span> <span class="token keyword">throw</span> <span class="token function">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">var</span> i<span class="token operator">:</span> Int      <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1551</span>      <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>   <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用起来就根普通的类一样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> duck <span class="token operator">=</span> <span class="token function">Duck</span><span class="token punctuation">(</span><span class="token string">"ywwuyi"</span><span class="token punctuation">)</span>   <span class="token function">println</span><span class="token punctuation">(</span>duck<span class="token punctuation">.</span>name<span class="token punctuation">)</span>   <span class="token function">println</span><span class="token punctuation">(</span>duck<span class="token punctuation">.</span>i<span class="token punctuation">)</span>   duck<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">6655</span>   duck<span class="token punctuation">.</span><span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>聪明的同学可能已经猜到了内联类的所谓「消除创建对象的开销」指的是什么。在经过编译器的处理后，以上代码就变成了下面这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> duck <span class="token operator">=</span> <span class="token string">"ywwuyi"</span>   <span class="token function">println</span><span class="token punctuation">(</span>duck<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出 1551</span>   <span class="token function">println</span><span class="token punctuation">(</span>Duck$Erased<span class="token punctuation">.</span><span class="token function">getI</span><span class="token punctuation">(</span>duck<span class="token punctuation">)</span><span class="token punctuation">)</span>   Duck$Erased<span class="token punctuation">.</span><span class="token function">setI</span><span class="token punctuation">(</span>duck<span class="token punctuation">,</span> <span class="token number">6655</span><span class="token punctuation">)</span>   Duck$Erased<span class="token punctuation">.</span><span class="token function">talk</span><span class="token punctuation">(</span>duck<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>整个类实例被“内联”掉了，只剩下它里面包裹的值。对成员方法的调用变成了对静态函数的调用（类似于扩展函数）。</p><p>也就是说，Inline class 可以给某个类型的值创建一个装箱类（就像上面的 Duck 包装了一个 Int 类型的值），并且这个装箱类能够被内联，“箱子”不复存在，只剩下那个被装箱的值。换句话说，内联类看起来就像是一个“零开销”的 wrapper。</p><h2 id="用途举例"><a href="#用途举例" class="headerlink" title="用途举例"></a>用途举例</h2><p>垃圾没用.jpg、进入胡说八道模式.jpg。</p><h3 id="严格的类型别名"><a href="#严格的类型别名" class="headerlink" title="严格的类型别名"></a>严格的类型别名</h3><p>我们知道 Kotlin 有类型别名，能给某个类型取一个另外的名字。例如我们想用类型别名弄一个长度单位「米」：</p><pre class=" language-kotlin"><code class="language-kotlin">typealias Meter <span class="token operator">=</span> Double</code></pre><p>但是 Meter 和 Double 其实是同一个类型，你并不能阻止将一个 Meter 赋值给一个 Double 类型的变量，你也并不能阻止两者相加。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> a<span class="token operator">:</span> Meter <span class="token operator">=</span> <span class="token function">getMeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> b<span class="token operator">:</span> Double <span class="token operator">=</span> <span class="token function">getMeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b</code></pre><p>但是如果这里使用内联类就不一样了：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Meter</span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> Double<span class="token punctuation">)</span> <span class="token punctuation">{</span>   operator <span class="token keyword">fun</span> <span class="token function">plus</span><span class="token punctuation">(</span>m<span class="token operator">:</span> Meter<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Meter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+</span> m<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">Meter</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>   <span class="token keyword">val</span> b <span class="token operator">=</span> <span class="token function">Meter</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span>   <span class="token keyword">val</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token comment" spellcheck="true">// ok, c的类型为Meter</span>   a <span class="token operator">=</span> <span class="token number">3.0</span>       <span class="token comment" spellcheck="true">// 编译错误：type mismatch</span><span class="token punctuation">}</span></code></pre><p>由于 Meter 是内联类，所以上面的代码实际上并不会创建 Meter 类的实例，在运行时只是在操纵 double，但是却保证了井水不犯河水，Meter 和 Double 各不相干。你甚至可以用内联类定义一套计量单位。</p><h3 id="任何你想得到的包装类（wrapper）"><a href="#任何你想得到的包装类（wrapper）" class="headerlink" title="任何你想得到的包装类（wrapper）"></a>任何你想得到的包装类（wrapper）</h3><p>“无痛”创建任何 wrapper，不用担心开销。</p><p>例如嫌原来的方法名字太丑，那就包一层：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Aa <span class="token punctuation">{</span>   <span class="token keyword">fun</span> <span class="token function">a1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">fun</span> <span class="token function">a2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Fuck</span><span class="token punctuation">(</span><span class="token keyword">val</span> a<span class="token operator">:</span> Aa<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">fuck1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">a1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">fuck2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">a2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>例如属性代理：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> InlinedDelegate<span class="token operator">&lt;</span><span class="token keyword">out</span> T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> ReadOnlyProperty<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">override</span> <span class="token keyword">inline</span> operator <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// do everything you like</span>      <span class="token keyword">return</span> value   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> Test <span class="token punctuation">{</span>    <span class="token keyword">val</span> some<span class="token operator">:</span> String <span class="token keyword">by</span> <span class="token function">InlinedDelegate</span><span class="token punctuation">(</span><span class="token string">"just for test"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>etc.</p><h3 id="无符号整型"><a href="#无符号整型" class="headerlink" title="无符号整型"></a>无符号整型</h3><p>无符号整型（unsigned integer）也是 <a href="https://drive.google.com/file/d/0BwAovUlww0CmVmNQTXd4TTdKYUU/view" target="_blank" rel="noopener">Kotlin Future Features Survey</a> 里面出现过的 feature（第12号），由于内联类的实装，无符号整型因此可以很好地实现，而不会有过大的开销。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">ULong</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> <span class="token keyword">data</span><span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token operator">:</span> Comparable<span class="token operator">&lt;</span>ULong<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* balabala */</span> <span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> a <span class="token operator">=</span> 2_147_483_648<span class="token punctuation">.</span><span class="token function">toUInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// a 的类型为 UInt</span>   <span class="token keyword">val</span> b <span class="token operator">=</span> 1_000_000_000   <span class="token keyword">val</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token comment" spellcheck="true">// c 的类型为 UInt</span>   <span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3147483648</span><span class="token punctuation">}</span></code></pre><p>同时还新增了无符号整形字面量来简化声明。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 结尾的u意味着这是一个无符号整形</span><span class="token keyword">val</span> uintMask <span class="token operator">=</span> 0xFFFF_FFFFu <span class="token comment" spellcheck="true">// UInt</span><span class="token keyword">val</span> ulongUpperPartMask <span class="token operator">=</span> 0xFFFF_FFFF_0000_0000uL <span class="token comment" spellcheck="true">// ULong</span></code></pre><p>无符号整型将在 Kotlin 1.3 实装。</p><h3 id="Try-Result-Monad（伪）"><a href="#Try-Result-Monad（伪）" class="headerlink" title="Try/Result Monad（伪）"></a>Try/Result Monad（伪）</h3><p>函数式风格的错误处理，世面上已经有太多类似的玩意了（Arrow 的 <a href="https://arrow-kt.io/docs/datatypes/try/" target="_blank" rel="noopener">Try<t></t></a>，隔壁 Scala 的 <a href="https://www.scala-lang.org/api/current/scala/util/Try.html" target="_blank" rel="noopener">Try[T]</a>，河对面 Haskell 的 <a href="https://wiki.haskell.org/Exception" target="_blank" rel="noopener">Exceptional e t</a>）。</p><p>所以 Kotlin 官方团队打算把类似的东西塞进标准库里，预计将在 Kotlin 1.3 版本实装。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> Result<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 省略一万字</span><span class="token punctuation">}</span></code></pre><p>不过具体的情况还很微妙，Roman 大爷说并不打算做得和 Arrow 的那个一样，而是做成一个功能十分有限的玩意，连 flatMap 都要你自己写出来。<del>没有 flatMap 的 Monad 还能叫做 Monad 么？</del></p><p>目前来看，只是用于精简协程中的 Continuation<t> 接口用。</t></p><p>更多的用处由于篇幅关系省略不写，摸了~</p><p>补充：Kotlin 1.3 实装后，看起来野心蛮大，在之后的版本也许会针对 Result<t> 重载 <code>?.</code>、<code>!!</code> 等操作符。</t></p><h2 id="编译器的魔术"><a href="#编译器的魔术" class="headerlink" title="编译器的魔术"></a>编译器的魔术</h2><p>这里是 Kotlin 1.2 版本的内联类的实现细节。</p><p>在你声明一个内联类的时候，编译器会为你生成两个类，一个类是内联类本体，另一个是为内联进行支持的辅助类。例如：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> Cloneable <span class="token punctuation">{</span>   <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">"quin"</span><span class="token punctuation">)</span>   <span class="token keyword">fun</span> <span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"rua~"</span><span class="token punctuation">)</span>   <span class="token keyword">val</span> next<span class="token operator">:</span> Int <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">}</span></code></pre><p>经过编译器之手，就变成了如下这样（细节已省略）：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> Cloneable <span class="token punctuation">{</span>   <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">"quin"</span><span class="token punctuation">)</span>   <span class="token keyword">fun</span> <span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Dog$Erased<span class="token punctuation">.</span><span class="token function">talk</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>   <span class="token keyword">val</span> next<span class="token operator">:</span> Int <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Dog$Erased<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>   <span class="token keyword">fun</span> <span class="token function">unbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> name<span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span>$Erased <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">talk</span><span class="token punctuation">(</span>String $<span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"rua~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getNext</span><span class="token punctuation">(</span>String $<span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token number">22</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Dog <span class="token function">box</span><span class="token punctuation">(</span>String v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对于用到内联类的地方，例如</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span>dog<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>   dog<span class="token punctuation">.</span>next   <span class="token function">test2</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> dog<span class="token punctuation">,</span> dog<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">test2</span><span class="token punctuation">(</span>dog1<span class="token operator">:</span> Dog<span class="token operator">?</span><span class="token punctuation">,</span> dog2<span class="token operator">:</span> Cloneable<span class="token punctuation">,</span> dog3<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>   dog1<span class="token operator">!!</span><span class="token punctuation">.</span><span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span>dog3 <span class="token keyword">as</span> Dog<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></code></pre><p>内联后变成这样（细节已省略）：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span>dog<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>   Dog$Erased<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span>   <span class="token function">test2</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> Dog$Erased<span class="token punctuation">.</span><span class="token function">box</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">,</span> Dog$Erased<span class="token punctuation">.</span><span class="token function">box</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">test2</span><span class="token punctuation">(</span>dog1<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">,</span> dog2<span class="token operator">:</span> Cloneable<span class="token punctuation">,</span> dog3<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>   Dog$Erased<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span>dog1<span class="token operator">!!</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span>dog3 <span class="token keyword">as</span> Dog<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>从上面可以看出，并不是所有的用处都能内联掉，在需要的时候仍然会将其装箱。</p><p>更多的细节由于篇幅关系省略不写，摸了~</p><p>补充：对于 Kotlin 1.3，不会再生成一个名为 ***$Erased 的合成类，而是将这些静态方法放在了同一个类里。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>未来可能支持内联枚举（inline enum），就像这样（随便找了<a href="https://developer.android.google.cn/reference/android/support/annotation/IntDef" target="_blank" rel="noopener">一段 Java 代码</a>用 Kotlin 重写）：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">enum</span> <span class="token function">NavigationMode</span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">NAVIGATION_MODE_STANDARD</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token function">NAVIGATION_MODE_LIST</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token function">NAVIGATION_MODE_TABS</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">val</span> navigationMode<span class="token operator">:</span> NavigationMode</code></pre><p>另外未来可能支持 reified 泛型参数，比如这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> Reified<span class="token operator">&lt;</span><span class="token keyword">reified</span> T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">val</span> some<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Reified<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">,</span> b<span class="token operator">:</span> Reified<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 编译后</span><span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Int<span class="token punctuation">,</span> b<span class="token operator">:</span> String<span class="token punctuation">)</span></code></pre><p>更多的补充说明由于摸了的关系省略不写~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin Contracts DSL</title>
      <link href="/2018/03/25/kotlin-contracts-dsl/"/>
      <url>/2018/03/25/kotlin-contracts-dsl/</url>
      
        <content type="html"><![CDATA[<p>从 Kotlin 1.2 版本开始，如果你查看 <code>apply</code>、<code>let</code> 等函数的源码，你会发现比 1.1 版本多了几行不明觉厉的代码<a id="more"></a>：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> T<span class="token punctuation">.</span><span class="token function">let</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> R<span class="token punctuation">)</span><span class="token operator">:</span> R <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// kotlin 1.2 加了下面三行代码</span>   contract <span class="token punctuation">{</span>      <span class="token function">callsInPlace</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> InvocationKind<span class="token punctuation">.</span>EXACTLY_ONCE<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// kotlin 1.2 加了上面三行代码</span>   <span class="token keyword">return</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>很好，接下来就讲讲那几行多出来的代码到底有什么用。</p><p>本文使用的 Kotlin 版本为 1.2.31。</p><h2 id="简单的需求"><a href="#简单的需求" class="headerlink" title="简单的需求"></a>简单的需求</h2><p>假设我们有这样一段代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> text<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      text <span class="token operator">=</span> <span class="token string">"我永远喜欢燕结芽"</span>   <span class="token punctuation">}</span>   <span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// error, cannot smart cast to String</span><span class="token punctuation">}</span></code></pre><p>稍有常识的人都会看出，如果我们的代码继续执行，这个可空类型的 <code>text</code> 变量，在最后一行那里不可能为 <code>null</code>。</p><p>但是编译器傻乎乎地向你丢出了一个编译错误：Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?</p><p>原因在于编译器不能深入分析每个函数（在这个例子中是 <code>isNullOrEmpty</code>）的数据流，无法得知「<code>test</code> 不为空」的事实，也就无法进行 Smart Cast 了。</p><p>所以如果要享受到 Smart Cast 的便利的话，可以手动将 <code>isNullOrEmpty</code> 内联展开：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">if</span><span class="token punctuation">(</span>text <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> text<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   text <span class="token operator">=</span> <span class="token string">"我永远喜欢燕结芽"</span><span class="token punctuation">}</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ok, smart cast to String</span></code></pre><p>但是这很麻烦，而且还不好看。为了解决这个问题，于是就有了 Contracts DSL。</p><h2 id="Contracts-DSL"><a href="#Contracts-DSL" class="headerlink" title="Contracts DSL"></a>Contracts DSL</h2><p>Contracts DSL 可以为编译器提供关于函数行为的附加信息，帮助编译器分析函数的实际运行情况，从而让更多正确的代码能通过编译（例如上面的例子）。</p><p>我们可以查看一下 isNullOrEmpty 的源码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> CharSequence<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{</span>   contract <span class="token punctuation">{</span>      <span class="token function">returns</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token function">implies</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token label symbol">@isNullOrEmpty</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">}</span></code></pre><p>这里简单解释一下 <code>contract</code> 代码块里面的那行代码，表示「如果返回值为<code>false</code>，那么<code>this</code>（函数的接收者）不为<code>null</code>」。</p><p>因为这个东西目前还是个实验性特性，处于内部评估的状态，尚未对外公开发布，所以是默认关闭的。如果启用了该特性，那么编译器就能解析获取 Contracts DSL 所表达的信息，用于数据流分析。</p><p>在 Kotlin 1.2 版本，为了开启这个特性，我们需要给编译器传入提供额外的编译参数：</p><pre><code>-Xeffect-system-Xread-deserialized-contracts</code></pre><p>然后下面的代码就能够正常通过编译：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 如果未开启 contract, 则会出现注释里的编译错误</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> str<span class="token operator">:</span> String<span class="token operator">?</span>   run <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// captured value initialization is forbidden due to possible reassignment</span>      str <span class="token operator">=</span> <span class="token string">"でないと、私のすごいとこ 見せられないじゃん"</span>   <span class="token punctuation">}</span>   <span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// str not initialized</span>   <span class="token keyword">val</span> notNull1<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> str   <span class="token function">requireNotNull</span><span class="token punctuation">(</span>notNull1<span class="token punctuation">)</span>   <span class="token function">println</span><span class="token punctuation">(</span>notNull1<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cannot smart cast to Any</span>   <span class="token keyword">val</span> notNull2<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> str   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>notNull2<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">println</span><span class="token punctuation">(</span>notNull2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cannot smart cast to String</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>虽然在 IDEA 里这些代码仍然会被标上红色下划线表示有错，但是加上编译器参数后的确能通过编译，也能够正常运行。</p><p>就拿上面例子的 <code>run</code> 函数说起，看看源码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token operator">></span> <span class="token function">run</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> R<span class="token punctuation">)</span><span class="token operator">:</span> R <span class="token punctuation">{</span>   contract <span class="token punctuation">{</span>      <span class="token function">callsInPlace</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> InvocationKind<span class="token punctuation">.</span>EXACTLY_ONCE<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>编译器可以知道「传入的 lambda 会立即在“原地”执行有且仅有一次」，那么 <code>str</code> 一定会被初始化，而且不会被重新赋值。编译通过！</p><p>在 Kotlin 1.2 版本里 Contracts DSL 位于 <code>kotlin.internal.contracts</code> 这个包内，是 <code>internal</code> 的，一般用户还无法直接拿来写自己的 contract。</p><p>这个特性已经在 Kotlin 1.3 版本实装。</p><h2 id="试着编写自己的-contract"><a href="#试着编写自己的-contract" class="headerlink" title="试着编写自己的 contract"></a>试着编写自己的 contract</h2><p>在 1.2 版本编写自定义 contract 的方法：</p><p>将 1.2 版本标准库里的 contract 源码文件复制出来，丢到自己项目的源码文件夹里（也就是和自己的代码放在一起），包名保持 <code>kotlin.internal.contracts</code> 不要变，然后再加上编译器参数：</p><pre><code>-Xeffect-system-Xread-deserialized-contracts-Xallow-kotlin-package</code></pre><p>然后随便写了一下，看起来就像这个截图这样：</p><img src="/2018/03/25/kotlin-contracts-dsl/201803300824.jpg" title="看起来还行"><p>实际体验的话，那个 <code>implies()</code> 目前只支持几个基本的模式（空检验、类型检验等，以后应该会增加新的模式），IDEA 的报错也是时好时坏（一切以编译结果为准）。</p><p>而且我尝试写了如下的 contract：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> T<span class="token operator">></span> Any<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">isInstanceOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{</span>   contract <span class="token punctuation">{</span>      <span class="token function">returns</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token function">implies</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token label symbol">@isInstanceOf</span> <span class="token keyword">is</span> T<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token keyword">is</span> T<span class="token punctuation">}</span></code></pre><p>也不知道是我太鶸还是 Kotlin 太辣鸡，上面这个 contract 看起来不起作用。</p><p>嘛反正是处于实验阶段的特性，也不强求什么，至少比没有强（</p><p>1.3 版本正式发布后，已经不需要搞七搞八，可以自由使用了。</p><p>2020/7/13更新：在 Kotlin 1.4-M1 版本中，上面的带有 reified 的泛型参数的 contract 已经可以使用了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么我不用 Gradle Kotlin DSL</title>
      <link href="/2018/02/26/why-not-gradle-kts-dsl/"/>
      <url>/2018/02/26/why-not-gradle-kts-dsl/</url>
      
        <content type="html"><![CDATA[<p>一图流。</p><p>Groovy：优雅，简洁，美观！</p><img src="/2018/02/26/why-not-gradle-kts-dsl/20180226191232.jpg" title="Groovy"><p>Kotlin DSL：你看看这何等鬼畜的用法！</p><img src="/2018/02/26/why-not-gradle-kts-dsl/20180226191238.jpg" title="Kotlin"><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin协程 - 先入个门吧</title>
      <link href="/2018/02/08/kotlin-coroutine-kepa/"/>
      <url>/2018/02/08/kotlin-coroutine-kepa/</url>
      
        <content type="html"><![CDATA[<p>你们要的协程文，嗯。封面图id：66548341。<a id="more"></a></p><iframe src="//music.163.com/outchain/player?type=2&id=1311345114&auto=0&height=32" width="298" height="52" frameborder="0" allowfullscreen></iframe><p>（我终于学会嵌入网易云音乐了，音量注意）</p><p>因为是入门嘛，所以本文保证不会出现任何与 <a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener">kotlinx.coroutines</a> 相关的内容。</p><p>本文写于Kotlin1.2的时代，1.3有点变化。所以修订一下本水文，增加一些内容，将原来的过时内容修改为1.3版本的内容，删减一些无关紧要的破事水。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>事先说明一点，本文的<strong>协程</strong>，专指<strong>Kotlin语言的协程</strong>，仅对Kotlin有效。本文完全不涉及其他编程语言的协程或类似的概念。</p><p>话说为什么我要在已经有那么多篇优秀的协程文的情况下再水一篇呢？</p><p>首先，因为我太鶸了，bennyhuo的<a href="https://blog.kotliner.cn/2017/01/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Kotlin%20Coroutine/" target="_blank" rel="noopener">那篇文章</a>根本看不懂，一开始上来就抛出一堆难以理解的专业名词，比如线程、Lua、CoroutineContext 等等，再加上那一堆根本看不懂的 Lua 代码以及 UML 类图，萌新一脸懵逼，直接被劝退，根本不留情面。所以我决定自己写一篇（自己能看懂的）。</p><p>其次，在Kotlin1.3版本更新之后，Kotlin官网上的参考文档的协程部分，完全套用了 kotlinx.coroutines 这个官方协程库的教程，对基本语法、标准库内容避而不谈。个人认为这并不合适，了解协程的原理、协程的本质也是十分重要的一环，就酱紫。</p><p>本水文不保证其他读者能看懂！（逃</p><h2 id="Kotlin-协程有什么用"><a href="#Kotlin-协程有什么用" class="headerlink" title="Kotlin 协程有什么用"></a>Kotlin 协程有什么用</h2><blockquote><p>Kotlin 1.1 的关键新特性是<em>协程</em>，它带来了 <code>future</code>/<code>await</code>、 <code>yield</code> 以及类似的编程模式的支持。Kotlin 的设计中的关键特性是协程执行的实现是语言库的一部分，而不是语言的一部分，所以你不必绑定任何特定的编程范式或并发库。</p></blockquote><p>很多人都会纳闷这Kotlin的协程到底有什么用，有什么好处。</p><p>在Kotlin官网上的参考文档里讲到「协程实际上是一个轻量级的线程，可以挂起并稍后恢复」，并且使用 kotlinx.coroutines 里的 launch 函数作为例子：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">repeat</span><span class="token punctuation">(</span>100_000<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 启动大量的协程</span>   launch <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果你找过其他官方资料，还能发现有将 launch 与 Thread.start 对比的例子，大多是在“我轻松开10W个协程，你开1K个线程试试”云云。</p><p>然而这只是其中一个优点，并且容易使人感觉「协程只是线程池和线程调度的封装罢了」，未能感受到协程真正魅力所在，十分可惜。</p><p>针对上述问题，一个比较好的答案是：</p><p><strong>Kotlin协程是 callback 的语法糖，它的主要好处是能让你写不需要 callback 的异步代码。换言之，把异步代码写得看起来就想同步的一样。</strong></p><p>直接拿官方的一段代码来做例子，假设有一段回调地狱代码如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 将数据从通道异步读入`buf`, 完成后运行lambda</span>inChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这个lambda在读取完成时执行</span>    bytesRead <span class="token operator">-></span>    <span class="token operator">..</span><span class="token punctuation">.</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    <span class="token function">process</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> bytesRead<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 从`buf`异步写入通道, 完成后运行lambda</span>    outChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这个lambda在写入完成时执行</span>        <span class="token operator">..</span><span class="token punctuation">.</span>        <span class="token operator">..</span><span class="token punctuation">.</span>        outFile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再假设上述异步API（即read和write）有支持Kotlin协程的版本（用Kotlin协程对异步API封装为aRead和aWrite），则可以用协程将上面代码改写成如下形式：</p><pre class=" language-kotlin"><code class="language-kotlin">launch <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当异步读取进行时挂起协程</span>    <span class="token keyword">val</span> bytesRead <span class="token operator">=</span> inChannel<span class="token punctuation">.</span><span class="token function">aRead</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 只有在读取完成时才执行至这一行</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    <span class="token function">process</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> bytesRead<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 当异步写入进行时挂起协程 </span>    outChannel<span class="token punctuation">.</span><span class="token function">aWrite</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 只有在写入完成时才执行至这一行</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    outFile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>看起来就像是没有回调、就像是同步代码一样。然而，协程仅仅是 callback 的语法糖，上面的代码仍然是包含了两个回调的异步代码，但是看起来却无比舒服。</p><p>那么，Kotlin协程是如何做到的呢？</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>先说说Kotlin标准库在1.3版本新增了一个类 <code>Result&lt;T&gt;</code>。</p><p><code>Result&lt;T&gt;</code> 是一个用于表示 Kotlin 函数执行成功和失败结果的 discriminated union（也叫 tagged union 或者是 algebraic data type），即 <code>Success T | Failure Throwable</code>，很简单。</p><p>不懂也没关系。</p><h3 id="suspend-关键字"><a href="#suspend-关键字" class="headerlink" title="suspend 关键字"></a>suspend 关键字</h3><p>Kotlin在1.1版本新增加了 suspend 关键字，可以用来修饰函数或者 lambda 表达式的类型：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ↑ 你看这辣鸡代码高亮 ↓</span><span class="token keyword">val</span> suspendLambda<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 上面这个suspend lambda的类型需要显式标明</span><span class="token comment" spellcheck="true">// 不然其类型会推导成普通的lambda而不是suspend lambda</span></code></pre><p>从Kotlin1.2.30版本开始，可以这样声明 suspend lambda，能够自动推导类型。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Kotlin 1.2.30 以降</span><span class="token keyword">val</span> suspendLambda2 <span class="token operator">=</span> suspend <span class="token punctuation">{</span>    <span class="token string">"Hello world!"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// suspendLambda2 的类型将被自动推导为 suspend () -> String</span><span class="token comment" spellcheck="true">// PS：在这里suspend是一个伪关键字</span></code></pre><p>现在，你得到了 suspend 函数和 suspend lambda。被标记为 suspend 的函数/lambda 只能在 suspend 函数/lambda 中被调用。</p><p>在Kotlin1.3版本，新增了 suspend main 功能。</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello coroutine"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="创建和启动协程"><a href="#创建和启动协程" class="headerlink" title="创建和启动协程"></a>创建和启动协程</h3><p>创建并启动一个协程十分简单，你只需要两件宝具：一个 <em>suspend lambda</em>，以及一个 <em>Continuation</em>：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span><span class="token keyword">val</span> suspendLambda <span class="token operator">=</span> suspend <span class="token punctuation">{</span>   <span class="token string">"Hello world!"</span><span class="token punctuation">}</span><span class="token keyword">val</span> completion <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">override</span> <span class="token keyword">val</span> context <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> EmptyCoroutineContext   <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span> Result<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getOrThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>使用 Kotlin 标准库中的 <code>createCoroutine</code> 函数来创建协程：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> coroutine<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token operator">=</span> suspendLambda<span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span>completion<span class="token punctuation">)</span></code></pre><p>这样你就得到了一个未启动的协程，然后调用 <code>resume</code> 扩展方法启动这个协程：</p><pre class=" language-kotlin"><code class="language-kotlin">coroutine<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 打印出 Hello world!</span></code></pre><p>或者使用标准库里的 <code>startCoroutine</code> 函数来创建并立即启动一个协程：</p><pre class=" language-kotlin"><code class="language-kotlin">suspendLambda<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>completion<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 打印出 Hello world!</span></code></pre><p>很简单。另外对于有带接收者的 suspend lambda，有与之相对应的库函数。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 创建协程</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span>completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">(</span>suspend R<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span>receiver<span class="token operator">:</span> R<span class="token punctuation">,</span> completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token comment" spellcheck="true">// 创建并启动协程</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Unit<span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">(</span>suspend R<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>receiver<span class="token operator">:</span> R<span class="token punctuation">,</span> completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Unit<span class="token comment" spellcheck="true">// 常用的扩展方法</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>Result<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">resumeWithException</span><span class="token punctuation">(</span>exception<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>Result<span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span>exception<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="协程挂起和恢复执行"><a href="#协程挂起和恢复执行" class="headerlink" title="协程挂起和恢复执行"></a>协程挂起和恢复执行</h3><p>想要暂停一个协程的执行，可以使用标准库里面的 <code>suspendCoroutine</code> 函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> suspendLambda <span class="token operator">=</span> suspend <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before suspend"</span><span class="token punctuation">)</span>    suspendCoroutine<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after suspend"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>suspendLambda<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Any<span class="token operator">></span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 输出：</span><span class="token comment" spellcheck="true">// before suspend</span></code></pre><p>如果需要恢复协程，例如等待3秒后继续执行：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> suspendLambda <span class="token operator">=</span> suspend <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before suspend"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> int<span class="token operator">:</span> Int <span class="token operator">=</span> suspendCoroutine <span class="token punctuation">{</span> c <span class="token operator">-></span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token number">1551</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after suspend, resume with <span class="token interpolation variable">$int</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>suspendLambda<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Any<span class="token operator">></span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 输出（两行输出间隔3秒）：</span><span class="token comment" spellcheck="true">// before suspend</span><span class="token comment" spellcheck="true">// after suspend, resume with 1551</span></code></pre><p><code>suspendCoroutine</code> 函数的签名如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> suspend <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suspendCoroutine</span><span class="token punctuation">(</span><span class="token keyword">crossinline</span> block<span class="token operator">:</span> <span class="token punctuation">(</span>Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> T</code></pre><p>如果你知道这上面的各段代码在执行的过程中究竟发生了什么，那太棒了，你不需要浪费时间阅读这篇辣鸡水文，请点击右上角的关闭按钮。</p><h2 id="概念摘出：Continuation"><a href="#概念摘出：Continuation" class="headerlink" title="概念摘出：Continuation"></a>概念摘出：Continuation</h2><p>Continuation（续延）究竟是一个什么概念？一般来讲，Continuation 表示的是「剩余的计算」的概念，换句话说就是「接下来要执行的代码」。举个例子来说，假设我们有这样一段代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1551</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span></code></pre><p>我们知道这段代码会先执行 <code>1551.toString()</code>，然后再执行 <code>_.length</code>，最后执行 <code>println(_)</code> 将结果打印出来。</p><p>当 <code>1551.toString()</code> 求值之后，需要将其结果传递至 <code>println(_.length)</code>。</p><p>可以看到，<code>println(_.length)</code> 需要一个 String 类型的值才能执行。这时我们可以将 <code>println(_.length)</code> 改写成一个 lambda 表达式：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token punctuation">{</span> s<span class="token operator">:</span> String <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>这个 lambda 表达式（或者说是闭包）就可以是 <code>1551.toString()</code> 的 Continuation，即「剩余的计算」。</p><p>这样，我们就可以通过把 <code>&quot;1551&quot;</code> 传给这个 lambda 来重新构建原始的形式：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token punctuation">{</span> s<span class="token operator">:</span> String <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token string">"1551"</span><span class="token punctuation">)</span></code></pre><p>也就是执行该 lambda 表达式的 <code>invoke</code> 方法以执行「剩余的计算」。</p><p>那么 <code>1551.toString().length</code> 的 Continuation 又是什么呢？很简单，是 <code>{ i: Int -&gt; println(i) }</code>。</p><p>以上讲的就是 Continuation 的一般概念。Kotlin 里面的 Continuation 长什么样子？大概像这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">val</span> context<span class="token operator">:</span> CoroutineContext   <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span> Result<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 常用的扩展方法</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">=</span>      <span class="token function">resumeWith</span><span class="token punctuation">(</span>Result<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">resumeWithException</span><span class="token punctuation">(</span>exception<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token operator">=</span>      <span class="token function">resumeWith</span><span class="token punctuation">(</span>Result<span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span>exception<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>这样我们就可以将 Kotlin 的 Continuation 与上面的 lambda 表达式建立一些对应关系，Continuation的 <code>resumeWith</code> 就相当与 lambda 表达式的 <code>invoke</code>，所以当你拿到一个 Continuation 时，<code>resumeWith</code> 方法即是「剩余的计算」的入口。</p><p>PS：「剩余的计算」这个概念，是不是跟 callback 很像呢~</p><h3 id="上文基础操作的简要解释"><a href="#上文基础操作的简要解释" class="headerlink" title="上文基础操作的简要解释"></a>上文基础操作的简要解释</h3><p>来看上文创建协程的例子：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> suspendLambda <span class="token operator">=</span> suspend <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token keyword">val</span> completion <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token keyword">val</span> coroutine<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token operator">=</span> suspendLambda<span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span>completion<span class="token punctuation">)</span>coroutine<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行已创建好的协程</span></code></pre><p>例中 <code>createCoroutine</code> 函数接受一个 Contiuation 类型的参数 completion，表示「协程执行完之后要执行的代码」。而 suspendLambda 则是协程的主体。</p><p><code>createCoroutine</code> 函数负责把这两个东西整合成一个表示「整个协程所有需要执行的代码」的 Contiuation，称为初始 Continuation（initial continuation）。对其调用 resume 则开始运行。</p><p>当 suspendLambda 执行完毕后，将其结果传至 completion 的 <code>resume</code> 扩展方法；若 suspendLambda 的执行过程中抛出了异常，则执行 completion 的 <code>resumeWithException</code> 扩展方法。</p><p>再看上文 <code>suspendCoroutine</code> 函数的例子：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> suspendLambda <span class="token operator">=</span> suspend <span class="token punctuation">{</span>   <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before suspend"</span><span class="token punctuation">)</span>   <span class="token keyword">val</span> int<span class="token operator">:</span> Int <span class="token operator">=</span> suspendCoroutine <span class="token punctuation">{</span> cont <span class="token operator">-></span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>      cont<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token number">1551</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after suspend, resume with <span class="token interpolation variable">$int</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>suspendCoroutine</code> 会将协程挂起（suspend），并且 <code>suspendCoroutine</code> 这个函数接收一个lambda表达式作为参数，这个 lambda 的 cont 参数即是表示「协程挂起后剩下的还没执行的代码」。</p><p>针对这个例子，如果要用lambda表达式来表示 cont 这个 Continuation，则是：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token punctuation">{</span> i<span class="token operator">:</span> Int <span class="token operator">-></span>   <span class="token keyword">val</span> int <span class="token operator">=</span> i   <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after suspend, resume with <span class="token interpolation variable">$int</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在线程睡了3000毫秒后，调用 <code>resume</code> 方法将这个协程继续执行下去，<code>suspendCoroutine</code> 的返回值即是通过 <code>resume</code> 方法传入的值（本例中为<code>1551</code>），于是变量<code>int</code>得到值<code>1551</code>，并在之后打印出来。</p><p>超简单~！</p><h2 id="编译器的魔术"><a href="#编译器的魔术" class="headerlink" title="编译器的魔术"></a>编译器的魔术</h2><blockquote><p><strong>「别逗我了。那种东西怎么会是魔法！」</strong></p></blockquote><p>那么 Kotlin 的协程是怎么实现的呢？</p><p>协程完全通过编译技术实现（不需要来自 VM 或 OS 端的支持），挂起通过代码来生效。（本句话抄自 Kotlin 中文网）</p><h3 id="CPS-转换"><a href="#CPS-转换" class="headerlink" title="CPS 转换"></a>CPS 转换</h3><blockquote><p>「CPST 就是 Gödel–Gentzen 变换的 Curry–Howard 像而已，这有什么难理解的？」</p></blockquote><p>在编译时，每一个 suspend 函数会被编译器加上一个 Continuation 参数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 编译前</span>suspend <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> U<span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 编译后</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> U<span class="token punctuation">,</span> c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span></code></pre><p>这叫做 CPS 转换（Continuation-Passing-Style Transformation）。</p><p>因此我们可以认为每个 suspend 函数都有一个 Continuation 类型的隐式参数，每个 suspend 函数都能通过这个参数拿到一个 Continuation，代表着「该函数之后将要执行的代码」。</p><p>PS：<code>suspendFunction</code> 经过CPS转换后，返回值的那个 <code>Any?</code> 其实是个类似于 union type（并集类型）的玩意。它其实是 <code>T | COROUTINE_SUSPENDED</code>，意为返回值可能为 <code>T</code> 类型的值，也可能是一个 <code>COROUTINE_SUSPENDED</code>。但是辣鸡 Kotlin 没有 union type，所以只能用 <code>Any?</code> ，使用的时候再做类型强转。（看看人家 <a href="http://dotty.epfl.ch/docs/reference/union-types.html" target="_blank" rel="noopener">Scala</a> 和 <a href="https://ceylon-lang.org/documentation/1.3/tour/types/#union_types" target="_blank" rel="noopener">Ceylon</a> ，做得多好）</p><p>PPS：如果你喜欢翻看源码，你会发现在 Kotlin 标准库的协程部分以及 <a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener">kotlinx.coroutines</a> 里面能经常见到这种用 <code>Any?</code> 表示的 union types。</p><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>我们知道 Continuation 就相当于一个闭包，经过 CPS 转换，每次调用 suspend 函数都需要传一个 Continuation 进去。为了避免创建过多的闭包和匿名类，Kotlin 选择使用<strong>状态机</strong>（state machines）来实现 Continuation。</p><p>由于懒，我直接把 KEEP 里面的例子抄了过来：</p><p>suspend 函数会被编译成一个状态机，例如一个 suspend 函数里有以下代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> y <span class="token operator">=</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 挂起点 1</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> z <span class="token operator">=</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 挂起点 2</span><span class="token function">c</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span></code></pre><p>其中的2个 suspend 函数调用点（简称挂起点，suspension point）将这段代码分成3个状态：</p><p>状态0：第一个挂起点之前（初始状态）</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></code></pre><p>状态1：第一个挂起点之后，至第二个挂起点之前</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> y <span class="token operator">=</span> _<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">bar</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> y<span class="token punctuation">)</span></code></pre><p>状态2：第二个挂起点之后</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> z <span class="token operator">=</span> _<span class="token function">c</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span></code></pre><p>代码会被编译成一个匿名类，它具有一个实现状态机的方法，一个保存状态机当前状态的字段，以及各个状态的局部变量的字段，看起来像这样：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 伪代码，简化模型，实际情况会比这个要复杂一些</span><span class="token keyword">class</span> 状态机匿名类 <span class="token keyword">extends</span> <span class="token class-name">CoroutineImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Continuation</span><span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这个int用来保存状态机当前的状态</span>    <span class="token keyword">int</span> label <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">// 用来保存suspend方法中的局部变量</span>    A a <span class="token operator">=</span> null    Y y <span class="token operator">=</span> null    <span class="token comment" spellcheck="true">// 实现状态机的方法</span>    <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span>Object data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>label <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> L0        <span class="token keyword">if</span> <span class="token punctuation">(</span>label <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> L1        <span class="token keyword">if</span> <span class="token punctuation">(</span>label <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> L2        <span class="token keyword">else</span> <span class="token keyword">throw</span> <span class="token function">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 英文不翻译了，懒~</span>      L0<span class="token operator">:</span>        <span class="token comment" spellcheck="true">// data is expected to be `null` at this invocation</span>        a <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        label <span class="token operator">=</span> <span class="token number">1</span>        data <span class="token operator">=</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'this' is passed as a continuation </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> COROUTINE_SUSPENDED<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// return if suspendFunction had suspended execution</span>      L1<span class="token operator">:</span>        <span class="token comment" spellcheck="true">// external code has resumed this coroutine passing the result of suspendFunction() as data </span>        y <span class="token operator">=</span> <span class="token punctuation">(</span>Y<span class="token punctuation">)</span> data        <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        label <span class="token operator">=</span> <span class="token number">2</span>        data <span class="token operator">=</span> <span class="token function">suspendFunction</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'this' is passed as a continuation</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> COROUTINE_SUSPENDED<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// return if suspendFunction had suspended execution</span>      L2<span class="token operator">:</span>        <span class="token comment" spellcheck="true">// external code has resumed this coroutine passing the result of suspendFunction() as data </span>        Z z <span class="token operator">=</span> <span class="token punctuation">(</span>Z<span class="token punctuation">)</span> data        <span class="token function">c</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span>        label <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true">// No more steps are allowed</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们可以看到每次调用 suspendFunction 时，传进去的 Continuation 都是同一个对象，即状态机本身；并且通过 label 来控制状态和代码跳转，使其符合「剩下的计算」的语义。</p><p>PS：并不是所有的 suspend 函数都会编译成一个状态机，存在一种尾调用优化（tail call optimization）的机制。举个例子：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do something before calling f2"</span><span class="token punctuation">)</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// &lt;==这里</span><span class="token punctuation">}</span>suspend <span class="token keyword">fun</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span></code></pre><p>f1函数内部唯一的一个 suspend 调用是在函数尾部的位置（即 tail suspension invocation），这时不会编译成状态机，而是这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">f1</span><span class="token punctuation">(</span>c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> Unit<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do something before calling f2"</span><span class="token punctuation">)</span>    <span class="token function">f2</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">f2</span><span class="token punctuation">(</span>c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span><span class="token keyword">in</span> Unit<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span></code></pre><p>即尾调用优化。（亲爱的读者可以思考一下为什么可以这么做）</p><p>另外，如果 suspend 函数里面没有调用任何 suspend 函数，那么也不会被编译成状态机。</p><h3 id="具有Kotlin特色的Call-CC"><a href="#具有Kotlin特色的Call-CC" class="headerlink" title="具有Kotlin特色的Call/CC"></a>具有Kotlin特色的Call/CC</h3><p>前面提到，编译器会给每一个 suspend 函数添加一个 Continuation 类型的参数，但是我们在代码里是看不到这个参数的，我们要怎么样才能拿到这个参数呢？</p><p>于是乎，Kotlin 厚颜无耻地把 Scheme 的 Call/CC（call-with-current-continuation）抄了过来并加以魔改，放在 <code>kotlin.coroutines.intrinsics</code> 这个包里，就是这玩意：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> suspend <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suspendCoroutineUninterceptedOrReturn</span><span class="token punctuation">(</span>   <span class="token keyword">crossinline</span> block<span class="token operator">:</span> <span class="token punctuation">(</span>Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> T<span class="token comment" spellcheck="true">// 不要问我为什么这玩意的名字这么长</span></code></pre><p>这个函数是 Kotlin 协程中<strong>最为重要</strong>的函数，是一个固有函数（intrinsic function，即编译器特殊对待的函数），其实现无法用 Kotlin 代码表示，需要编译器在编译的时候进行替换。如果你去看了它的源码，你会看到类似与这样的东西：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> suspend <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suspendCoroutineUninterceptedOrReturn</span><span class="token punctuation">(</span>   <span class="token keyword">crossinline</span> block<span class="token operator">:</span> <span class="token punctuation">(</span>Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> <span class="token keyword">throw</span> <span class="token function">NotImplementedError</span><span class="token punctuation">(</span><span class="token string">"Implementation is intrinsic"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 等号后面也有可能是一个 `null!!`</span></code></pre><p>在经过 CPS 转换后，我们来看一下这个函数的真面目：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">suspendCoroutineUninterceptedOrReturn</span><span class="token punctuation">(</span>   <span class="token keyword">crossinline</span> block<span class="token operator">:</span> <span class="token punctuation">(</span>Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token operator">?</span><span class="token punctuation">,</span> c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">block</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span></code></pre><p>简单明了，直接将这个新增的 Continuation 参数传给了 lambda，这样我们就可以通过这个 lambda 来操纵由 CPS 转换得来的 Continuation。</p><p>上文讲过，这里所有的 Any? 其实都是 <code>T | COROUTINE_SUSPENDED</code> ，<code>COROUTINE_SUSPENDED</code> 的定义也在这个包里：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> COROUTINE_SUSPENDED<span class="token operator">:</span> Any <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> CoroutineSingletons<span class="token punctuation">.</span>COROUTINE_SUSPENDED<span class="token annotation builtin">@PublishedApi</span><span class="token keyword">internal</span> <span class="token keyword">enum</span> <span class="token keyword">class</span> CoroutineSingletons <span class="token punctuation">{</span>   COROUTINE_SUSPENDED<span class="token punctuation">,</span> UNDECIDED<span class="token punctuation">,</span> RESUMED <span class="token punctuation">}</span></code></pre><p>从上文的那个状态机伪代码里面可以看到，对于每个 suspend 函数的调用，都会检查其返回值是不是 <code>COROUTINE_SUSPENDED</code>。如果不是，那么状态机就开始执行下一个状态的代码；如果是 <code>COROUTINE_SUSPENDED</code>，就直接返回，停止执行代码，即协程挂起。可以写个demo来验证一下：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> suspendCoroutineUninterceptedOrReturn <span class="token punctuation">{</span> c <span class="token operator">-></span>    COROUTINE_SUSPENDED<span class="token punctuation">}</span><span class="token keyword">val</span> suspendLambda<span class="token operator">:</span> <span class="token function">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before suspend"</span><span class="token punctuation">)</span>    <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after suspend"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>suspendLambda<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Any<span class="token operator">></span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>结果只有 before suspend 被打印了出来。如果要继续执行下去，则需要通过 Continuation，调用其 <code>resume</code> 扩展方法：</p><pre class=" language-kotlin"><code class="language-kotlin">suspend <span class="token keyword">fun</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token operator">=</span> suspendCoroutineUninterceptedOrReturn <span class="token punctuation">{</span> c <span class="token operator">-></span>    thread <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5_000<span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    COROUTINE_SUSPENDED<span class="token punctuation">}</span></code></pre><p>这时候我们可以看到，before suspend 先被打印出来，5秒种后，after suspend 再被打印出来。</p><p>f3函数经过 CPS 转换、suspend 函数的尾调用优化以及 <code>suspendCoroutineUninterceptedOrReturn</code> 的内联，最终会变成如下的样子：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">f3</span><span class="token punctuation">(</span>c<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>    thread <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//  ↑ 这个Any?其实是 ↓</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5_000<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//       Unit | COROUTINE_SUSPENDED</span>        c<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> COROUTINE_SUSPENDED<span class="token punctuation">}</span></code></pre><p>看起来就像是在直接操纵编译时添加的 Continuation 参数。</p><p>本节比较长，给个小结：<code>suspendCoroutineUninterceptedOrReturn</code> 能够让你直接操纵通过CPS转换得来的 Continuation 参数。</p><pre class=" language-kotlin"><code class="language-kotlin">suspendCoroutineUninterceptedOrReturn <span class="token punctuation">{</span> cont <span class="token operator">-></span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>这个函数接收一个 lambda 参数，在这个 lambda 里面，你将面临两种选择：直接返回需要的结果（不挂起协程）或者返回 <code>COROUTINE_SUSPENDED</code>（挂起协程）。如果你选择挂起协程，你需要在合适的地方与时机调用（从lambda的参数得到的）Continuation 的 <code>resume</code> 扩展方法将需要的结果传入以便继续执行协程。</p><p>Kotlin 标准库里面的 <code>suspendCoroutine</code> 即是对 <code>suspendCoroutineUninterceptedOrReturn</code> 的封装，使其更易于使用。读者可以对比一下两者的函数签名以及文档上的注意事项。一般情况下使用 <code>suspendCoroutine</code> 即可满足需求。</p><p>PS：不知道从什么时候开始的，<code>kotlin.coroutines.intrinsics</code> 这个包以及里面的所有东西，都不会出现在 Intellij IDEA 的自动补全的列表里了。你需要手动 import 这个包，才能享受到自动补全的便利。</p><p>PPS：本文完。</p><h2 id="你学到了什么"><a href="#你学到了什么" class="headerlink" title="你学到了什么"></a>你学到了什么</h2><ul><li>Kotlin协程的一些（不常用的）标准库函数的使用方法</li><li>编译器都做了什么事（的一部分）</li><li><code>suspendCoroutineUninterceptedOrReturn</code> 有什么用</li></ul><p>下一篇协程文？不存在的。</p><p>课后作业：我在 Codewars 上面出了<a href="https://www.codewars.com/kata/tricky-kotlin-number-8-simple-for-comprehension" target="_blank" rel="noopener">一道题</a>，要求实现简单的控制流，很简单。如果你能看懂这篇文章，那么这道题对于你来说应该是十分简单的。（千里冰封julao仅用了不到十分钟的时间就做出来了）</p><p>反编译Tip：Intellij IDEA的Kotlin插件有将Kotlin代码的字节码反编译至Java的功能，但是在面对协程相关的代码时大多数情况下都不好用。请不要想太多，老老实实用其他反编译工具，我用的是这个<a href="https://github.com/skylot/jadx" target="_blank" rel="noopener">jadx</a>，版本0.6.1。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Coroutine </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin的一些技巧和迂回操作</title>
      <link href="/2018/01/07/kotlin-jiqiao/"/>
      <url>/2018/01/07/kotlin-jiqiao/</url>
      
        <content type="html"><![CDATA[<p>RT，不定期更新。</p><p>目录：</p><ul><li><a href="#扩展属性的backing-field">扩展属性的backing field</a><a id="more"></a></li><li><a href="#不依赖getter和setter的lateinit属性">不依赖getter和setter的lateinit属性</a><!--more--></li><li><a href="#解除内联类的一些限制">解除内联类的一些限制</a></li><li><a href="#开启残废的SAM转换功能">开启残废的SAM转换功能</a></li><li><a href="#如何添加编译器参数">如何添加编译器参数</a></li><li><a href="#不需要import就能使用的顶层函数">不需要import就能使用的顶层函数</a></li><li><a href="#递归的Lambda表达式">递归的Lambda表达式</a></li><li><a href="#阻止编译器添加对非空类型的NullCheck">阻止编译器添加对非空类型的NullCheck</a></li><li><a href="#给主构造器内的属性自定义getter和setter">给主构造器内的属性自定义getter和setter</a></li><li><a href="#流的读取">流的读取</a></li><li><a href="#限制扩展的作用域（防止污染命名空间）">限制扩展的作用域</a></li><li><a href="#链式调用时输出中间值">链式调用时输出中间值</a></li></ul><h2 id="扩展属性的backing-field"><a href="#扩展属性的backing-field" class="headerlink" title="扩展属性的backing field"></a>扩展属性的backing field</h2><p>众所周知扩展属性是没有backing field的，它其实就是扩展函数的特殊形式。但是总有人想要给某个类扩展一个真正的field，就像下面那样。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Some <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// unresolved reference: field</span><span class="token keyword">var</span> Some<span class="token punctuation">.</span>rua <span class="token operator">:</span> String   <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> field   <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      field <span class="token operator">=</span> value   <span class="token punctuation">}</span></code></pre><p>这种需求针对不同的实际情况有不同的解决方法，下面给出一个非最优但是比较通用的方法。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> ruaMap<span class="token operator">:</span> MutableMap<span class="token operator">&lt;</span>Some<span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这个TODO别直接抄了</span><span class="token keyword">var</span> Some<span class="token punctuation">.</span>rua <span class="token operator">:</span> String   <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> ruaMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token operator">?:</span> <span class="token string">""</span>   <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> ruaMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token operator">=</span> value <span class="token punctuation">}</span></code></pre><p>我们总要找个地方将数据存起来，这里选择了一个全局的Map来解决存储问题。</p><p>需要注意的是，这里对Map的类型有要求：因为不能干扰jvm的垃圾回收机制，所以需要是WeakReferenceMap；因为每个实例都需要保存一份自己的数据，所以需要是IdentityMap；如果在多线程环境跑这代码，需要是ConcurrentMap。综上你需要一个<code>ConcurrentWeakIdentityMap</code>来解决这个问题。</p><h2 id="不依赖getter和setter的lateinit属性"><a href="#不依赖getter和setter的lateinit属性" class="headerlink" title="不依赖getter和setter的lateinit属性"></a>不依赖getter和setter的lateinit属性</h2><p>lateinit属性之所以无法自定义getter和setter，是因为需要在getter插入空检测，并且保证setter能给backing field赋值。</p><p>迂回方法如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>contracts<span class="token punctuation">.</span>ExperimentalContracts<span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>contracts<span class="token punctuation">.</span>contract<span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>contracts<span class="token punctuation">.</span>InvocationKind<span class="token annotation builtin">@OptIn</span><span class="token punctuation">(</span>ExperimentalContracts<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">trick</span><span class="token punctuation">(</span>willNotBeInvoked<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>   contract <span class="token punctuation">{</span> <span class="token function">callsInPlace</span><span class="token punctuation">(</span>willNotBeInvoked<span class="token punctuation">,</span> InvocationKind<span class="token punctuation">.</span>EXACTLY_ONCE<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">undefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> T <span class="token operator">=</span> <span class="token keyword">throw</span> <span class="token function">Exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> Some <span class="token punctuation">{</span>   <span class="token keyword">var</span> lateInit<span class="token operator">:</span> String   <span class="token keyword">init</span> <span class="token punctuation">{</span>      trick <span class="token punctuation">{</span> lateInit <span class="token operator">=</span> <span class="token function">undefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> lateInit<span class="token operator">:</span> String<span class="token keyword">val</span> no_use <span class="token operator">=</span> trick <span class="token punctuation">{</span> lateInit <span class="token operator">=</span> <span class="token function">undefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>原理：利用contract欺骗Kotlin编译器，让它以为属性已被正常初始化（然而并不），属性停留在未被初始化的阶段，从而模拟 lateinit 的功能。当然安全性需要由敲代码的人来保证了。</p><p>因为是假的lateinit，所以反射 Some::lateInit.isLateinit 将返回 false。</p><p>用途：当你需要给lateinit属性自定义getter或setter时、或者需要一个lateinit的@JvmField。</p><p>2020/7/13更新：</p><p>更新一个不使用contract的方法，比较简单：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Some <span class="token punctuation">{</span>   <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"MUST_BE_INITIALIZED_OR_BE_ABSTRACT"</span><span class="token punctuation">)</span>   <span class="token keyword">var</span> lateInit<span class="token operator">:</span> String<span class="token punctuation">}</span><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"MUST_BE_INITIALIZED"</span><span class="token punctuation">)</span><span class="token keyword">var</span> lateInit<span class="token operator">:</span> String</code></pre><p>利用我<a href="https://aisia.moe/2018/12/09/kotlin-suppress/">那篇文章</a>介绍的方法，用<code>Suppress</code>注解消除Kotlin编译器的编译错误，让属性保持在未初始化的状态。</p><p>以上两种方法都需要注意如果直接读取未初始化的属性，会得到<code>null</code>，所以在使用时要格外小心，确保属性的初始化。</p><h2 id="解除内联类的一些限制"><a href="#解除内联类的一些限制" class="headerlink" title="解除内联类的一些限制"></a>解除内联类的一些限制</h2><p>不开后门的话，Kotlin1.3的新功能<strong>内联类</strong>的作用将十分有限。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 非公有构造器，以及泛型</span><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS"</span><span class="token punctuation">)</span><span class="token keyword">inline</span> <span class="token keyword">class</span> Some<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">private</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">val</span> s<span class="token operator">:</span> T<span class="token punctuation">)</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 非顶层声明</span><span class="token keyword">class</span> Outer <span class="token punctuation">{</span>   <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"INLINE_CLASS_NOT_TOP_LEVEL"</span><span class="token punctuation">)</span>   <span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Inner</span><span class="token punctuation">(</span><span class="token keyword">val</span> s<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>可能有Bug（逃</p><h2 id="开启残废的SAM转换功能"><a href="#开启残废的SAM转换功能" class="headerlink" title="开启残废的SAM转换功能"></a>开启残废的SAM转换功能</h2><p>Kotlin 1.4 版本是默认开启的，所以不用管。</p><p>Kotlin 1.3 版本有用，没试过更旧的版本。</p><p>添加编译器参数：</p><pre><code>-XXLanguage:+NewInference-XXLanguage:+SamConversionForKotlinFunctions</code></pre><p>以下代码能通过编译：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>runnable<span class="token operator">:</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Runnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>   test <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然而如下代码仍然不能通过编译：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> CanRun <span class="token punctuation">{</span>   <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>runnable<span class="token operator">:</span> CanRun<span class="token punctuation">)</span> <span class="token punctuation">{</span>   test <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 这里报错</span><span class="token punctuation">}</span></code></pre><h2 id="如何添加编译器参数"><a href="#如何添加编译器参数" class="headerlink" title="如何添加编译器参数"></a>如何添加编译器参数</h2><h3 id="使用-Gradle"><a href="#使用-Gradle" class="headerlink" title="使用 Gradle"></a>使用 Gradle</h3><pre class=" language-Groovy"><code class="language-Groovy">// build.gradlecompileKotlin {    ...    kotlinOptions.freeCompilerArgs += ["-foo", "-bar"]}compileTestKotlin {    // 单元测试代码的kotlin编译任务，同上}</code></pre><p>PS：使用Gradle的话，请注意IDEA的 <code>Delegate IDE build/run actions to gradle</code> 这个选项是否勾选的区别。</p><p>PPS：对于自定义源文件集（source set）这些任务称呼取决于 <code>compile&lt;Name&gt;Kotlin</code> 模式。比如说安卓项目，例如 <code>compileDebugKotlin</code>、 <code>compileReleaseUnitTestKotlin</code> 等。</p><h3 id="使用-Gradle-Kotlin-Dsl："><a href="#使用-Gradle-Kotlin-Dsl：" class="headerlink" title="使用 Gradle Kotlin Dsl："></a>使用 Gradle Kotlin Dsl：</h3><p>因为我本身不使用Gradle Kotlin Dsl，所以不保证下面的写法在未来还能用。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// build.gradle.kts</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>kotlin<span class="token punctuation">.</span>gradle<span class="token punctuation">.</span>tasks<span class="token punctuation">.</span>KotlinCompiletasks<span class="token punctuation">.</span>withType<span class="token operator">&lt;</span>KotlinCompile<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    kotlinOptions<span class="token punctuation">.</span>freeCompilerArgs <span class="token operator">+=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"-foo"</span><span class="token punctuation">,</span> <span class="token string">"-bar"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 或者是下面这样</span><span class="token keyword">val</span> compileKotlin<span class="token operator">:</span> KotlinCompile <span class="token keyword">by</span> taskskotlinOptions<span class="token punctuation">.</span>freeCompilerArgs <span class="token operator">+=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"-foo"</span><span class="token punctuation">,</span> <span class="token string">"-bar"</span><span class="token punctuation">)</span></code></pre><h3 id="IDEA项目，不使用Maven、Gradle构建工具"><a href="#IDEA项目，不使用Maven、Gradle构建工具" class="headerlink" title="IDEA项目，不使用Maven、Gradle构建工具"></a>IDEA项目，不使用Maven、Gradle构建工具</h3><p>有两个地方：一个是对整个Project有效的全局设置；另一个对单独Module有效，可以覆盖全局设置。（善用设置里的搜索功能）</p><p>全局设置：File -&gt; Settings -&gt; 找到 Kotlin Compiler -&gt; Additional command line parameters</p><p>Module设置：File -&gt; Project Structure -&gt; Module -&gt; 找到目标Module里面的Kotlin设置 -&gt; Additional command line parameters</p><p>如果Module设置没有Kotlin的话，可以点击「+」按钮手动加上 Kotlin 设置。</p><h2 id="不需要import就能使用的顶层函数"><a href="#不需要import就能使用的顶层函数" class="headerlink" title="不需要import就能使用的顶层函数"></a>不需要import就能使用的顶层函数</h2><p>一个顶层函数，除非你在同一个文件里使用，否则就需要 import 或者使用完全限定名。问题是有些人就是嫌烦，想要所谓的“全局函数”，就像 Kotlin 标准库里的 <code>println</code> 一样。</p><p>其实很简单，只需要写得跟 <code>println</code> 一样就行了：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">package</span> kotlin<span class="token keyword">fun</span> <span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>因为 kotlin 包下的东西都是自动导入的，所以只需要将你的扩展函数也丢到 kotlin 这个包里，就不需要自己动手导入啦。</p><p>需要传入编译器参数 <code>-Xallow-kotlin-package</code> 来允许使用 kotlin 开头的包名。</p><h2 id="递归的Lambda表达式"><a href="#递归的Lambda表达式" class="headerlink" title="递归的Lambda表达式"></a>递归的Lambda表达式</h2><p>在某个 Kotlin 裙里看到有人在问：</p><blockquote><p>是不是lambda无法递归</p></blockquote><p>举个例子，我们可以写一个简单的递归函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1551"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印出很多1551</span></code></pre><p>如果要写成 Lambda 呢？这样的代码会报错：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> a<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1551"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>我们自然是不能直接写这样的代码的，它会说 <code>a</code> 没有定义。解决方法当然是使用 <code>lateinit</code>：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">lateinit</span> <span class="token keyword">var</span> a<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unita <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1551"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印出很多1551</span></code></pre><p>更进一步：匿名 Lambda 表达式的递归</p><p>正统的「<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener">Lambda演算</a>」里面的函数全部都是匿名函数，需要使用「<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator" target="_blank" rel="noopener">不动点组合子</a>」实现递归：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 这是kotlin-js</span><span class="token keyword">val</span> z <span class="token operator">=</span> <span class="token punctuation">{</span> f<span class="token operator">:</span> dynamic <span class="token operator">-></span>   <span class="token punctuation">{</span> g<span class="token operator">:</span> dynamic <span class="token operator">-></span> <span class="token function">g</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> dynamic <span class="token operator">-></span> f <span class="token punctuation">{</span> y<span class="token operator">:</span> dynamic <span class="token operator">-></span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">val</span> a <span class="token operator">=</span> z <span class="token punctuation">{</span> f<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">-></span>   <span class="token punctuation">{</span>      <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1551"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 求斐波那契数列第n项的函数</span><span class="token keyword">val</span> fib<span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-></span> Int <span class="token operator">=</span> z <span class="token punctuation">{</span> f<span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-></span> Int <span class="token operator">-></span>   <span class="token punctuation">{</span> x<span class="token operator">:</span> Int <span class="token operator">-></span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span>      <span class="token keyword">else</span> <span class="token function">f</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出斐波那契数列前10项</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token function">rangeTo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fib<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>上面的那一坨 <code>val z</code> 即是「Z组合子」。（读者可以思考一下为什么这里我给了 Kotlin-js 的例子是而不是 Kotlin-jvm（逃</p><h2 id="阻止编译器添加对非空类型的NullCheck"><a href="#阻止编译器添加对非空类型的NullCheck" class="headerlink" title="阻止编译器添加对非空类型的NullCheck"></a>阻止编译器添加对非空类型的NullCheck</h2><p>总所周知，当一个函数的参数是非空类型时，Kotlin编译器会在方法入口处加一行检查入参是否为空的代码。比如说 <code>main</code> 函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>经过编译后，再反编译成Java：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Intrinsics<span class="token punctuation">.</span><span class="token function">checkParameterIsNotNull</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token string">"args"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可恶！辣鸡编译器自作主张！我不想要这行代码！</p><p>如果不想编译器生成这些代码，需要添加编译器参数，如下</p><pre><code>-Xno-call-assertions-Xno-param-assertions-Xno-receiver-assertions</code></pre><h2 id="给主构造器内的属性自定义getter和setter"><a href="#给主构造器内的属性自定义getter和setter" class="headerlink" title="给主构造器内的属性自定义getter和setter"></a>给主构造器内的属性自定义getter和setter</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">SomeClass</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span></code></pre><p>众所周知 Kotlin 不允许给声明在主构造器里面的属性写自定义getter、setter，主要是为了防止有好事者乱写，破坏规则就不好了。所以迂回操作如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">SomeClass</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">var</span> _name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> name<span class="token operator">:</span> String        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> _name        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> _name <span class="token operator">=</span> value <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解释：<code>private</code>的<code>_name</code>不会生成getter和setter，你再把你想写的getter和setter添上就好。这样<code>SomeClass</code>里面就有3样东西：<code>String _name</code>，<code>String getName()</code>和<code>void setName(String)</code>（以及data class根据<code>_name</code>自动生成的那些）。</p><p>缺点很明显，toString 生成的字符串会比较丑。</p><h2 id="流的读取"><a href="#流的读取" class="headerlink" title="流的读取"></a>流的读取</h2><p>普通青年：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// java 代码</span><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>InputStream in<span class="token punctuation">,</span> OutputStream out<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">int</span> read<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>read <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>文艺青年：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>`<span class="token keyword">in</span>`<span class="token operator">:</span> InputStream<span class="token punctuation">,</span> <span class="token keyword">out</span><span class="token operator">:</span> OutputStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> read<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> read <span class="token operator">=</span> `<span class="token keyword">in</span>`<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>read <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>二逼青年：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>`<span class="token keyword">in</span>`<span class="token operator">:</span> InputStream<span class="token punctuation">,</span> <span class="token keyword">out</span><span class="token operator">:</span> OutputStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> read<span class="token operator">:</span> Int <span class="token operator">=</span> `<span class="token keyword">in</span>`<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>read <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span>        read <span class="token operator">=</span> `<span class="token keyword">in</span>`<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>天哪，真是太完美了：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>`<span class="token keyword">in</span>`<span class="token operator">:</span> InputStream<span class="token punctuation">,</span> <span class="token keyword">out</span><span class="token operator">:</span> OutputStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> read<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>`<span class="token keyword">in</span>`<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span> read <span class="token operator">=</span> it <span class="token punctuation">}</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 Kotlin 1.3 版本正式启用了 contracts 功能后，上面这种写法能应对更多情况。</p><h2 id="限制扩展的作用域（防止污染命名空间）"><a href="#限制扩展的作用域（防止污染命名空间）" class="headerlink" title="限制扩展的作用域（防止污染命名空间）"></a>限制扩展的作用域（防止污染命名空间）</h2><p>注意：此方法被官方定义为bug并在1.3.70版本被修复。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">object</span> StringExtension <span class="token punctuation">{</span>   <span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fuck <span class="token interpolation variable">$this</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>当你把扩展丢进一个object里面，那么在IDEA里的自动补全列表就不会出现那个扩展。你需要把这个扩展方法完整地敲出来，IDEA才会提示你引入它。</p><p>或者你可以用一些方法将object塞进接收者里：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">with</span><span class="token punctuation">(</span>StringExtension<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token string">"kotlin"</span><span class="token punctuation">.</span><span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里会出现自动补全</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当然把扩展塞进object里的缺点就很明显了，没有自动补全可能一辈子都想不起来有这个扩展方法。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 以下是夏姬八写，别模仿，只是为了展示某些可能性</span><span class="token keyword">interface</span> Extension<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T <span class="token operator">:</span> Extension<span class="token punctuation">,</span> R<span class="token operator">></span> T<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>block<span class="token operator">:</span> T<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> R<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">object</span> StringExtension <span class="token operator">:</span> Extension <span class="token punctuation">{</span>   <span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fuck <span class="token interpolation variable">$this</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">object</span> IntExtension <span class="token punctuation">{</span>   <span class="token keyword">fun</span> Int<span class="token punctuation">.</span><span class="token function">love</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love <span class="token interpolation variable">$this</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token annotation builtin">@OptIn</span><span class="token punctuation">(</span>ExperimentalContracts<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">importIntExtensionTo</span><span class="token punctuation">(</span>any<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   contract <span class="token punctuation">{</span> <span class="token function">returns</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">implies</span> <span class="token punctuation">(</span>any <span class="token keyword">is</span> IntExtension<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   StringExtension<span class="token punctuation">.</span><span class="token function">use</span> <span class="token punctuation">{</span> <span class="token string">"kotlin"</span><span class="token punctuation">.</span><span class="token function">fuck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>   <span class="token function">with</span><span class="token punctuation">(</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">importIntExtensionTo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>      <span class="token number">42</span><span class="token punctuation">.</span><span class="token function">love</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="链式调用时输出中间值"><a href="#链式调用时输出中间值" class="headerlink" title="链式调用时输出中间值"></a>链式调用时输出中间值</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> printlnBy <span class="token punctuation">{</span> it <span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span> T<span class="token punctuation">.</span><span class="token function">printlnBy</span><span class="token punctuation">(</span>selector<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> U<span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">selector</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> it <span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">printlnBy</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// &lt;==这里</span>            <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> it <span class="token operator">and</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">}</span>            <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// &lt;==还有这里</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：</span><span class="token comment" spellcheck="true">// 18</span><span class="token comment" spellcheck="true">// 6</span></code></pre><p>注意副作用，别随便乱用！</p><p>如果是集合操作，可以考虑使用 <code>onEach</code> 这个高阶函数，例如<code>onEach { println(it) }</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【水】Kotlin Puzzlers 改</title>
      <link href="/2017/12/28/kotlin-puzzlers/"/>
      <url>/2017/12/28/kotlin-puzzlers/</url>
      
        <content type="html"><![CDATA[<p>《Java Puzzlers》（中文名《Java 解惑》）里面讲解了许多 Java 语言的大坑，相信各位julao应该都看过。Kotlin 作为「a better Java」，在填补一些坑的同时，不可避免地引入了许多新坑。<a id="more"></a>本来本鶸进行了一段时间的取材，想要写一篇《Kotlin Puzzlers》的，可谁知 已经有人早就把我的饭碗抢走了，而且素材比我还多，可恶！</p><p>这篇文章就是本鶸看完录像（油土鳖上面有）以及 Github 上的完整内容后，将一些比较坑的谜题拿出来报复社会，蛐蛐一篇观后感而已。</p><p>题型为选择题，本辣鸡博客没有NGA的折叠，没有萌百的黑幕，为了防止一眼瞄到答案而造成剧透，本文对答案（以及解释）的摆放位置做了调整，例如第一题的答案被我放在了第二题的位置（以此类推）。各位看客从上到下开始阅读就好了。</p><p>使用的 Kotlin 版本为1.2。</p><h2 id="没有坑到我的谜题"><a href="#没有坑到我的谜题" class="headerlink" title="没有坑到我的谜题"></a>没有坑到我的谜题</h2><p>虽然没有被坑，比较简单，但是值得注意的题。一些更加简单的题目就不放上来了。想刷一遍完整题库的同学可以到 GitHub 上面找。</p><h3 id="强力返回-Power-Return"><a href="#强力返回-Power-Return" class="headerlink" title="强力返回 ~ Power Return"></a>强力返回 ~ Power Return</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>  <span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token keyword">return</span> <span class="token keyword">throw</span> <span class="token keyword">return</span> <span class="token string">"Hello"</span>  <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </code></pre><pre><code>这会打印出什么？a) Hellob) 两个Helloc) 这破代码根本没法通过编译d) 以上答案都不对</code></pre><p>本题答案（以及解释）在下一题那里。（以此类推）</p><h3 id="计划生育-One-Chile-Policy"><a href="#计划生育-One-Chile-Policy" class="headerlink" title="计划生育 ~ One Chile Policy"></a>计划生育 ~ One Chile Policy</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">fun</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">class</span> Parent <span class="token operator">:</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token string">"parent"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">fun</span> <span class="token function">child</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">Node</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>  <span class="token keyword">val</span> child1 <span class="token operator">=</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token string">"child1"</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token keyword">val</span> child2 <span class="token operator">=</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token string">"child2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) child1 和 child2b) child1 和 parentc) parent 和 child2d) 以上答案都不对</code></pre><p>上一题的答案：a</p><p>要记住，<code>return ***</code> 和 <code>throw ***</code> 都是表达式，其结果的类型为 <code>Nothing</code>，<code>Nothing</code> 类型是任意类型的子类型，所以 <code>Nothing</code> 可以被抛出，可以被返回，可以赋值给任意类型的变量。事实上 <code>hello()</code> 在 <code>return &quot;Hello&quot;</code> 的时候已经结束了，剩下的 <code>throw</code>、<code>val result</code>、<code>println()</code> 什么的都是不可到达代码（unreachable code），不会被运行。</p><p>PS：你甚至可以写出这样的代码：<code>throw throw throw Exception()</code></p><h3 id="两只拉姆达跑得快-Two-Lambda"><a href="#两只拉姆达跑得快-Two-Lambda" class="headerlink" title="两只拉姆达跑得快 ~ Two Lambda"></a>两只拉姆达跑得快 ~ Two Lambda</h3><pre class=" language-kotlin"><code class="language-kotlin">typealias L <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span>one<span class="token operator">:</span> L <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> two<span class="token operator">:</span> L <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">one</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span>  <span class="token function">two</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>foo <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) oneoneb) twotwoc) onetwod) 以上答案都不对</code></pre><p>上一题的答案：b</p><p>事实上是 <code>child1</code> 和 <code>parent</code>。<code>Kotlin</code> 的这些扩展方法如 <code>apply</code>、<code>let</code>、<code>also</code> 等等都是适用于所有类型的，包括可空类型。<code>child2</code> 那行 <code>apply</code> 函数接收的拉姆达表达式的类型其实是 <code>Node?.() -&gt; Unit</code>，如果 <code>child2</code>那行代码是写在 <code>Parent</code> 类的外面的话，你就会发现这行代码根本没法通过编译，这里面调用的 <code>lookup</code> 实际上是 <code>parent</code> 的 <code>lookup</code>。（你可以把 <code>apply</code> 换成 <code>also</code> 试试。）</p><h3 id="衔尾蛇-Cyclic-Object-Constructions"><a href="#衔尾蛇-Cyclic-Object-Constructions" class="headerlink" title="衔尾蛇 ~ Cyclic Object Constructions"></a>衔尾蛇 ~ Cyclic Object Constructions</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">val</span> x<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">)</span><span class="token keyword">object</span> B <span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token keyword">object</span> C <span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span>x<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) nullnullb) C@********nullc) ExceptionInInitializerErrord) 这破代码根本没法通过编译</code></pre><p>上一题的答案：d</p><p>实际上是 <code>twoone</code>。第一句的语法只有在拉姆达表达式是最后一个参数的时候才能写的，所以是 <code>two</code>。第二句是普通的方法调用，先填上第一个参数，第二个参数使用默认值。</p><p>PS：想要朴素地实现 <code>foo { } { }</code> 这样的调用的话应该是办不到的吧。(如果能做到请赶快告诉我！)</p><h3 id="哇，好长-Breaking-Lines"><a href="#哇，好长-Breaking-Lines" class="headerlink" title="哇，好长 ~ Breaking Lines"></a>哇，好长 ~ Breaking Lines</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> anExtremelyLongAndBoringStatementThatBarelyFitsOnALine <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">val</span> anotherExtremelyLongStatementThatBarelyFitsOnALine <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">val</span> someList <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> result <span class="token operator">=</span> someList<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span>        anExtremelyLongAndBoringStatementThatBarelyFitsOnALine            <span class="token operator">+</span> anotherExtremelyLongStatementThatBarelyFitsOnALine<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) [1]b) [2]c) [4]d) [1, 4]</code></pre><p>上一题的答案：b</p><p><code>B</code> 初始化需要 <code>C</code>，<code>C</code> 初始化需要 <code>B</code>。咦，<code>B</code> 还没初始化完成呢，那么哪来的 <code>B</code> 呢，只能是 <code>null</code> 了啊！</p><p>更详细的解释可以看这里：<a href="https://github.com/Kotlin/kotlin-spec/blob/spec-old/kotlin-spec.asc#singleton-objects" target="_blank" rel="noopener">https://github.com/Kotlin/kotlin-spec/blob/spec-old/kotlin-spec.asc#singleton-objects</a></p><h3 id="换个名字你就不认识我了-Good-Child-Has-Many-Names"><a href="#换个名字你就不认识我了-Good-Child-Has-Many-Names" class="headerlink" title="换个名字你就不认识我了 ~ Good Child Has Many Names"></a>换个名字你就不认识我了 ~ Good Child Has Many Names</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> C <span class="token punctuation">{</span>  <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">}</span><span class="token keyword">class</span> D <span class="token operator">:</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">sum</span><span class="token punctuation">(</span>y<span class="token operator">:</span> Int<span class="token punctuation">,</span> x<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">val</span> d<span class="token operator">:</span> D <span class="token operator">=</span> <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> c<span class="token operator">:</span> C <span class="token operator">=</span> d<span class="token function">print</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) 22b) 11c) 21d) 这破代码根本没法通过编译</code></pre><p>上一题的答案：b</p><p>之前裙里有julao问过类似的问题所以我没被坑到。你可以把代码丢到IDEA里面，光标定位到加号前面，按下 <code>Ctrl+B</code> 或者 <code>Ctrl+Q</code>，看看那个加号是什么意思吧。解决方法：把加号放在上一行的后面可破。</p><h3 id="排序-Sorting"><a href="#排序-Sorting" class="headerlink" title="排序 ~ Sorting"></a>排序 ~ Sorting</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">arrayListOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">val</span> sortedList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>sortedList<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) [1, 5, 3, 2, 4]b) [1, 2, 3, 4, 5]c) kotlin.Unitd) 这破代码根本没法通过编译</code></pre><p>上一题的答案：c</p><p>命名参数是静态分配的。</p><h3 id="致命的顺序-The-Order"><a href="#致命的顺序-The-Order" class="headerlink" title="致命的顺序 ~ The Order"></a>致命的顺序 ~ The Order</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Order <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">val</span> c<span class="token operator">:</span> String  <span class="token keyword">init</span> <span class="token punctuation">{</span>    <span class="token function">the</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    c <span class="token operator">=</span> <span class="token string">""</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">the</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>length<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">Order</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) 0b) nullc) 这破代码根本没法通过编译d) 以上答案都不对</code></pre><p>上一题的答案：c</p><p>参见 <a href="https://zhuanlan.zhihu.com/p/27234651" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27234651</a></p><p>本题的答案：d</p><p>JVM 不想理你并向你抛出了一只 NPE。Java 也有这个问题，Scala 不熟悉不清楚。同样是 JVM 平台上的语言，Ceylon 就没有这个问题，Ceylon 官网的文档有这个问题的说明，可以参考一下（趁机吹一波 Ceylon）。</p><p><a href="https://ceylon-lang.org/documentation/1.3/tour/initialization/#definite_assignment_and_definite_initialization" target="_blank" rel="noopener">https://ceylon-lang.org/documentation/1.3/tour/initialization/#definite_assignment_and_definite_initialization</a></p><p>Kotlin 官方人员曾表示过修复这个缺陷是一件十分困难的事。</p><h2 id="那些坑了我的迷题"><a href="#那些坑了我的迷题" class="headerlink" title="那些坑了我的迷题"></a>那些坑了我的迷题</h2><p>我果然是鶸，错了这么多，进入自卑模式~</p><h3 id="区间测试-Inclusive-Range"><a href="#区间测试-Inclusive-Range" class="headerlink" title="区间测试 ~ Inclusive Range"></a>区间测试 ~ Inclusive Range</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> i <span class="token operator">=</span> <span class="token number">10.5</span><span class="token keyword">when</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"in"</span><span class="token punctuation">)</span>  <span class="token operator">!</span><span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"!in"</span><span class="token punctuation">)</span>  <span class="token keyword">else</span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"else"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre><code>这会打印出什么？a) inb) !inc) elsed) 这破代码根本没法通过编译</code></pre><p>据说这道题在 Kotlin 1.0 版本和 1.2 版本里有不同的表现。（我懒得试旧版本了）</p><h3 id="极性不定-Weird-Chaining"><a href="#极性不定-Weird-Chaining" class="headerlink" title="极性不定 ~ Weird Chaining"></a>极性不定 ~ Weird Chaining</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">printNumberSign</span><span class="token punctuation">(</span>num<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">"negative"</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">"positive"</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token string">"zero"</span>  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">printNumberSign</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token function">printNumberSign</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token function">printNumberSign</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) negative; zero; positiveb) negative; zeroc) negative; positived) zero; positive</code></pre><p>上一题的答案：a</p><p>实际上是把 <code>i</code> 转成 <code>Int</code> 再进行的比较。</p><h3 id="Dollar-In-Multiline-Literals"><a href="#Dollar-In-Multiline-Literals" class="headerlink" title="$_$ ~ Dollar In Multiline Literals"></a>$_$ ~ Dollar In Multiline Literals</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> multiline <span class="token operator">=</span> <span class="token raw-string string">"""        To win \<span class="token interpolation variable">$999</span>.999 execute "rm -fr \<span class="token interpolation variable">$HOME</span>/kotlin-puzzlers/*"        """</span><span class="token punctuation">.</span><span class="token function">trimIndent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span>multiline<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) To win \$999.999 execute &quot;rm -fr \$HOME/kotlin-puzzlers/*&quot;b) To win 999.999 execute &quot;rm -fr \/home/user/kotlin-puzzlers/*&quot;c) To win $999.999 execute &quot;rm -fr $HOME/kotlin-puzzlers/*&quot;d) 这破代码根本没法通过编译</code></pre><p>上一题的答案：d</p><p>相当于：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token string">"negative"</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token string">"positive"</span> <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token string">"zero"</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>秒懂！</p><p>解决方法：用小括号将那串 <code>if else</code> 括起来再接 <code>let</code> 可破。</p><h3 id="你的名字是-Property-Override"><a href="#你的名字是-Property-Override" class="headerlink" title="你的名字是 ~ Property Override"></a>你的名字是 ~ Property Override</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> Named <span class="token punctuation">{</span>  <span class="token keyword">open</span> <span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> field <span class="token operator">?:</span> <span class="token string">"&lt;unnamed>"</span><span class="token punctuation">}</span><span class="token keyword">class</span> Person<span class="token operator">:</span> <span class="token function">Named</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">override</span> <span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span>name    <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> field <span class="token operator">=</span> <span class="token string">"Mr <span class="token interpolation variable">$value</span>"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">val</span> person <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Anton"</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) Antonb) Mr Antonc) &lt;unnamed&gt;d) null</code></pre><p>上一题的答案：d</p><p>这种 raw string 里面美元符号 <code>$</code> 一直都是表示模板表达式，而且不能被转义，所以 <code>$HOME</code> 这里糟了。（你问为什么 <code>$999.999</code> 没糟？因为 <code>999.999</code> 不是合法的变量名啊，你在 <code>999.999</code> 两边加上反引号试试。）</p><p>解决方法：”””${‘$’}HOME”””</p><h3 id="冰雪聪明-Custom-Getter-Smartcast"><a href="#冰雪聪明-Custom-Getter-Smartcast" class="headerlink" title="冰雪聪明 ~ Custom Getter Smartcast"></a>冰雪聪明 ~ Custom Getter Smartcast</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> SmartCastable <span class="token punctuation">{</span>    <span class="token keyword">val</span> list<span class="token operator">:</span> List<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> <span class="token keyword">set</span><span class="token operator">:</span> Set<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableSetOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>         <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> field<span class="token punctuation">}</span><span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token function">SmartCastable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span>list <span class="token keyword">is</span> MutableList<span class="token punctuation">)</span>    sc<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span>set <span class="token keyword">is</span> MutableSet<span class="token punctuation">)</span>    sc<span class="token punctuation">.</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">${</span>sc<span class="token punctuation">.</span>list<span class="token delimiter variable">}</span></span>, <span class="token interpolation"><span class="token delimiter variable">${</span>sc<span class="token punctuation">.</span>set<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) [1, 2, 3], [1, 2, 3]b) [1, 2, 3, 4], [1, 2, 3, 4]c) UnsupportedOperationExceptiond) 这破代码根本没法通过编译</code></pre><p>上一题的答案：c</p><p>这里有两个 <code>backing field</code>，<code>Named</code> 类的那个 <code>get</code> 方法操纵了父类的 <code>backing field</code>，<code>set</code> 方法操纵的是自己的 <code>backing field</code>。</p><p>解决方法：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Person<span class="token operator">:</span> <span class="token function">Named</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token operator">?</span>        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span>name        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Mr <span class="token interpolation variable">$value</span>"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="最小值-MinInt"><a href="#最小值-MinInt" class="headerlink" title="最小值 ~ MinInt"></a>最小值 ~ MinInt</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">printInt</span><span class="token punctuation">(</span>n<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">printInt</span><span class="token punctuation">(</span><span class="token operator">-</span>2_147_483_648<span class="token punctuation">.</span><span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) -2147483647b) -2147483649c)  2147483647d) 以上答案都不对</code></pre><p>上一题的答案：d</p><p><code>sc.set</code> 有一个自定义 <code>getter</code>，编译器没法判断这个 <code>getter</code> 返回的是否是同一个对象，所以无法进行智能转换（smart cast）。</p><p>解决方法：这时候别声明只有 <code>getter</code> 的属性，声明有 <code>backing field</code> 的属性就好。或者像这样：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> <span class="token keyword">set</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>set<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">set</span> <span class="token keyword">is</span> MutableSet<span class="token punctuation">)</span>    <span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><h3 id="人类衰退之后-Population-To-Mars"><a href="#人类衰退之后-Population-To-Mars" class="headerlink" title="人类衰退之后 ~ Population To Mars"></a>人类衰退之后 ~ Population To Mars</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">Population</span><span class="token punctuation">(</span><span class="token keyword">var</span> cities<span class="token operator">:</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Int<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">val</span> 帝都 <span class="token keyword">by</span> cities  <span class="token keyword">val</span> 魔都 <span class="token keyword">by</span> cities  <span class="token keyword">val</span> 妖都 <span class="token keyword">by</span> cities<span class="token punctuation">}</span><span class="token keyword">val</span> population <span class="token operator">=</span> <span class="token function">Population</span><span class="token punctuation">(</span><span class="token function">mapOf</span><span class="token punctuation">(</span>    <span class="token string">"帝都"</span> <span class="token keyword">to</span> 864_816<span class="token punctuation">,</span>    <span class="token string">"魔都"</span> <span class="token keyword">to</span> 413_782<span class="token punctuation">,</span>    <span class="token string">"妖都"</span> <span class="token keyword">to</span> 43_005<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 许多年过去了，地球毁灭了，只有少数幸存者抵达了火星（大吉大利今晚吃鸡）！</span>population<span class="token punctuation">.</span>cities <span class="token operator">=</span> <span class="token function">emptyMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">with</span><span class="token punctuation">(</span>population<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"$帝都; $魔都; $妖都"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre><code>这会打印出什么？a) 0; 0; 0b) 864816; 413782; 43005c) NullPointerExceptiond) NoSuchElementException</code></pre><p>上一题的答案：d</p><p>破代码没法通过编译。实际的求值顺序是：<code>-(2_147_483_648.inc())</code>，这TM是个 <code>Long</code>。这个一元操作符的优先级比普通方法调用低。</p><h3 id="反物质-AntiMatter"><a href="#反物质-AntiMatter" class="headerlink" title="反物质 ~ AntiMatter"></a>反物质 ~ AntiMatter</h3><pre class=" language-kotlin"><code class="language-kotlin">operator <span class="token keyword">fun</span> Nothing<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Unitoperator <span class="token keyword">fun</span> Unit<span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">val</span> foo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token operator">!!</span><span class="token operator">!!</span><span class="token operator">!</span>foo<span class="token operator">!!</span><span class="token operator">!!</span><span class="token punctuation">)</span></code></pre><pre><code>这会打印出什么？a) nullb) kotlin.Unitc) KotlinNullPointerExceptiond) 这破代码根本没法通过编译</code></pre><p>上一题的答案：b</p><p>用于委托代理的那个 <code>Map</code> 被保存在了一个 <code>private final</code> 的 <code>field</code> 里面，正常手段没法赋新值。</p><p>本题的答案：d</p><p><code>null</code> 的类型是 <code>Nothing?</code>（而且是这个类型的唯一值）。<code>***!!</code> 这个非空断言比 <code>not()</code> 的优先级要高，所以 <code>foo!!!!</code> 的类型是 <code>Nothing</code>，<code>Nothing</code> 是所有类型的子类型，所以编译器没法判断该调用哪个扩展方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些辣鸡代码，别学。</p><img src="/2017/12/28/kotlin-puzzlers/20171206120238.jpg" title="辣鸡Kotlin">]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于此博客，以及博主，还有那些七七八八的事</title>
      <link href="/2017/04/27/about/"/>
      <url>/2017/04/27/about/</url>
      
        <content type="html"><![CDATA[<h1 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h1><p>讲道理，我搭好 Hexo 才发现，如果使用 Jekyll 的话，只要将页面源码 Push 到 Github 上，是可以自动生成页面并发布的。<br><a id="more"></a><br>全栽在 CI 上了（用的是 AppVeyor），首先是太久没用 Git，忘记子模块怎么用了，坑了好久。之后是 Git 一些操作重定向 stdout 到 stderr 导致 PowerShell ISE 报错，于是 CI 那边就挂掉了。然后是 Gitlab 的神奇 Bug，一次 Push 让 CI 那边连续 Build 了 5 次……</p><p>于是 3 天的人生就浪费掉了。<del>其实如果不搞持续集成的话就没那么多事。</del>虽然说结果都一样，但是总感觉有那么点不爽，我特么怎么就选了 Hexo 呢。越想越恼火。不排除以后换成 Jekyll 的可能性，不过主题一定是要换的。</p><p>2017年5月29日，主题由 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a> 变更为 <a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">material</a>。</p><p>2018年1月20日，域名已部署，HTTPS已部署。</p><h1 id="关于博客-The-History-of-RenTou"><a href="#关于博客-The-History-of-RenTou" class="headerlink" title="关于博客 ~ The History of RenTou"></a>关于博客 ~ The History of RenTou</h1><p>emmm…</p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>唔，感觉没啥好说的呢。</p><p><del>人头会社三元老之一，精神病院第13号床位所有者。</del></p><p><del>不务正业的辣鸡。</del></p><p>噫，就这样。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>这个博客是有评论系统的，看不到的话那应该是被墙了，请使用科学姿势查看。（或者等我换成其他系统（懒癌不允许我这么做（不！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
