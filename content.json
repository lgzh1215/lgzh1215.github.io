{"meta":{"title":"萌夜雀的人头会社","subtitle":null,"description":"要和谐, 要有爱","author":"Dexlind","url":"https://aisia.moe"},"pages":[{"title":"about","date":"2017-05-28T18:28:59.000Z","updated":"2020-05-26T15:26:05.743Z","comments":true,"path":"about/index.html","permalink":"https://aisia.moe/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"categories","date":"2017-04-18T17:12:52.000Z","updated":"2020-05-26T15:26:05.743Z","comments":true,"path":"categories/index.html","permalink":"https://aisia.moe/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2020-05-26T15:26:05.759Z","updated":"2020-05-26T15:26:05.759Z","comments":true,"path":"tags/index.html","permalink":"https://aisia.moe/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"timeline","date":"2020-05-26T15:26:05.759Z","updated":"2020-05-26T15:26:05.759Z","comments":true,"path":"timeline/index.html","permalink":"https://aisia.moe/timeline/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Kotlin Suppress 的非常规用法","slug":"kotlin-suppress","date":"2018-12-09T01:40:02.000Z","updated":"2020-05-26T15:26:05.743Z","comments":true,"path":"2018/12/09/kotlin-suppress/","link":"","permalink":"https://aisia.moe/2018/12/09/kotlin-suppress/","excerpt":"在 Java 中，有个叫 SuppressWarnings 的注解，用于忽略特定的编译器警告。Kotlin 中也有一个类似功能的注解，叫做 Suppress，本文主要讲讲这个注解有什么用。","text":"在 Java 中，有个叫 SuppressWarnings 的注解，用于忽略特定的编译器警告。Kotlin 中也有一个类似功能的注解，叫做 Suppress，本文主要讲讲这个注解有什么用。 常规用法有时候会写出这样的一些代码。这些在Kotlin编译器的眼里可能出现问题的代码，实际上却非常正确，跑起来不会出任何问题。 然后你就得到了一个编译器警告（warning），甚至是编译错误（error）。 比较常见的，比如说 unchecked cast： val some: List&lt;*> = emptyList&lt;Nothing>() some as List&lt;String> // Unchecked cast: List&lt;*> to List&lt;String> 然后就可以使用 Suppress 取消这个 warning： val some: List&lt;*> = emptyList&lt;Nothing>() @Suppress(\"UNCHECKED_CAST\") some as List&lt;String> 再举个例子： sealed class Base { @Suppress(\"LeakingThis\") val code = calculate() abstract fun calculate(): Int class Derived : Base() { override fun calculate() = 42 } } 上面这代码并不会出现 warning 的具体说明里的问题，所以使用了 Suppress 解决这个 warning。 这是很简单的破事水，没有任何讨论的价值。 然后下面是正文。 好孩子不要模仿！很危险的！ 非常规用法这破注释竟然能消除 error！ 比如说这样的代码： println((null as String?).length) 编译器会告诉你这样是不对的，然后向你丢出了一个 error： Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String? 然后就可以使用 Suppress 让编译器闭嘴！ @Suppress(\"UNSAFE_CALL\") println((null as String?).length) 然后就可以顺利的通过编译，编译后跑一跑，就可以轻松地拿到一个空指针异常： Exception in thread &quot;main&quot; java.lang.NullPointerException at ....... 很简单，有了 Suppress，你就可以让这些可以本来通过编译器生成java字节码，但是因为各种各样的原因（例如类型安全）被ban掉的代码，顺利通过编译。 下面给几个可能有用的例子。 例1fun some(any: Any) { when(any) { is Array&lt;String> -> println(any.size) } } 这是我吐槽过的「Java能做但是Kotlin做不了的事」系列之一。不考虑Kotlin的其他target（如js），在Jvm平台上有如下的迂回： any is Array&lt;*> &amp;&amp; any.isArrayOf&lt;String>() 就是很丑罢了。 在Kotlin的早期代码，这样的type check是允许的，因为某些原因ban掉了（读者可以想想为什么要ban掉这样的代码）。这个时候可以用 Suppress 把这个后门打开。 @Suppress(\"CANNOT_CHECK_FOR_ERASED\") 例2类型别名。 class Some { @Suppress(\"TOPLEVEL_TYPEALIASES_ONLY\") typealias Str = String val a: Str = \"\" } 一目了然，不解释。 例3Kotlin 在远古版本 M13 新增了 lateinit 修饰符，可以对只读属性和可变属性使用。 然后 M14 版本就残忍地 ban 掉了 lateinit val。 @Suppress(\"INAPPLICABLE_LATEINIT_MODIFIER\") lateinit val lateInitVal: String lateinit val 的用处可以看上面 M13 的链接里面的说明。 例4Kotlin Collection Literals 半成品。 @Suppress(\"UNSUPPORTED\") val bs: BooleanArray = [true, false, true] 这是个未完成的功能，目前只支持数组。以后可以支持 List、Map 和 Set，所以为了避免不必要的兼容性麻烦，在正常情况下只允许在注解里这样用。要想在其他地方用，就像上面代码那样。 结尾想知道更多的Suppress选项的话，可以去翻Kotlin的源码。 这种无法得到官方支持的奇技淫巧，也许下次更新就挂掉了，所以如果用了那就后果自负吧。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"Kotlin Experimental API","slug":"kotlin-experimental-api","date":"2018-10-03T03:55:15.000Z","updated":"2020-05-26T15:26:05.743Z","comments":true,"path":"2018/10/03/kotlin-experimental-api/","link":"","permalink":"https://aisia.moe/2018/10/03/kotlin-experimental-api/","excerpt":"本文随便讲讲Kotlin Experimental API。","text":"本文随便讲讲Kotlin Experimental API。 为了防止篇幅太大，本文会省略一些无关紧要的东西。 简单介绍首先我们知道在Kotlin的1.2版本里协程是实验性的，协程的那个包名里面有个十分显眼的experimental字样，用于告诉使用者这破玩意处于实验阶段。 然后，JB那帮人嫌这个标识方法很不方便，等到协程正式发布后会给迁移带来一定的麻烦。同时用包名声明实验性的这个方法太过粗犷，他们想要一种细粒度的（比如说可以对单个类甚至是单个函数）标记实验性质的机制。 所以就有了 Kotlin Experimental API。 简单使用Kotlin 1.3 版本的标准库里新增了几个注解，如下 // Kotlin 标准库里的东西 @Target(ANNOTATION_CLASS) annotation class Experimental(val level: Level = Level.ERROR) { enum class Level { WARNING, ERROR } } annotation class UseExperimental(vararg val markerClass: KClass&lt;out Annotation>) Experimental是个元注解，只能打在注解类上。比如说，我想在代码中引入一项新的实验性功能，名字叫 zzz，就可以像这样： @Experimental annotation class zzz 这样zzz就成为了一个「实验性标记」，声明了一个名为 zzz 的范畴。如果某些成员是 zzz 这个实验性功能的内容，就可以使用 zzz 标记它。 @zzz fun someFun() {} @zzz class SomeClass 这样 SomeClass 和 someFun 就是 实验性功能 zzz 的成员了，如果你在其他地方使用了它们，编译器会提醒你正在使用的东西是实验性的。至于怎么提醒，看上面 Experimental 这个注解有一个参数 level，表示提醒的方式，在编译时是发出警告（warring）还是丢出错误（error），默认是编译错误。 fun test() { someFun() // Error: This declaration is experimental and its usage must be marked with '@zzz' or '@UseExperimental(zzz::class)' } 如果要消除这个警告或者错误，就要使用UseExperimental这个注解，表示你已经意识到你正在使用的东西是实验性的。 @UseExperimental(zzz::class) fun test() { someFun() // ok } 简单的说，在@UseExperimental(zzz::class)的作用域内，你可以随意调用zzz 这个实验性功能的成员。比如说在kt文件开头处加上@file:UseExperimental(zzz::class)，则对整个文件有效。 或者可以将 test 也一并纳入 zzz 的范畴，将 test 也声明为实验性功能。 @zzz fun test() { someFun() // ok } 由此可见，此功能其实非常简单。一个是GPL式传播，另一个则能截断实验性的传播。 另外，Kotlin编译器新添加了两个编译器参数，-Xexperimental和-Xuse-experimental，对整个模块有效。 // 编译器参数 -Xuse-experimental=zzz // 等号后接那个注解的完全限定名 fun test() { someFun() // もok } 目前 Kotlin Experimental API 也是处在实验性阶段，如果你用到最上那两个标准库里的注解，需要使用编译器参数消除警告。 有什么用在Kotlin 1.3版本目前有3个实验性功能，contract和unsigned integer，所以你想使用这两个功能的话，就会用到上述的 Experimental API。 库作者也可以受益于这项功能（但是如果有改api的话该炸还是会炸的（ 本文完。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"Kotlin 1.3 前瞻之 Inline Class","slug":"inline-class","date":"2018-07-03T14:14:08.000Z","updated":"2020-05-26T15:26:05.743Z","comments":true,"path":"2018/07/03/inline-class/","link":"","permalink":"https://aisia.moe/2018/07/03/inline-class/","excerpt":"\n啊啦啦，垃圾 Kotlin，你又偷拿人家东西了！","text":"啊啦啦，垃圾 Kotlin，你又偷拿人家东西了！ 这几年各路语言的发展就是把 Haskell 吃剩下的再拿出来吃一遍，那么 Kotlin 也不例外（进入高级引战模式）。如果你精通 Haskell 或者 Scala，那太棒了，你不需要浪费时间阅读这篇辣鸡水文，请点击右上角的关闭按钮。 虽然说本文讲的是 Kotlin 1.3 版本的新特性，但是理论上 1.2.50 也能用（处于开发阶段，有大量 Bug，不建议日常使用）。如果想要体验这个实验性特性需要添加编译器参数 -XXLanguage:+InlineClasses。本文使用的 Kotlin 版本为 1.2.60-eap-7。 本文写于 Kotlin 1.2 的时代，由于 Inline Class 这个特性尚未正式实装，实际情况可能会有所变动，届时本文可能会有部分过时内容，然后针对 Kotlin 1.3 补充一些内容。 本文不会详细介绍各个细节，只抓重点讲。并且由于我太鶸，也许本文通篇错漏百出也说不定。 前言JB他们在17年4月份的时候，做了一份调查问卷，Kotlin Future Features Survey，内容是选出最希望实装的语言特性（20选3），后来得出的调查结果是 Inline Class 排第五。现在这个功能得以实装也算是众望所归了。 不过吃惊的是我没想到JB那帮人做得那么快，我还以为这特性要等到 Kotlin 2.0 才能摸出来。 什么是 Inline ClassInline Class，翻译成中文就是「内联类」。我们知道 Kotlin 有内联函数，可以消除函数调用的开销。那么内联类，则是可以消除创建对象的开销。 很强，是吧。如果不懂的话请往下看。 inline class Duck(val name: String) 以上代码就声明了一个最简单的内联类。 内联类必须有一个主构造函数，并且在主构造函数里必须有且只有一个 val 属性，除此之外，不能再拥有其他的字段。（var 属性目前还没做好所以不能用。） 可以给内联类添加泛型、次级构造函数、方法以及没有 backing field 的属性，还可以实现接口： inline class Duck(val name: String) { constructor() : this(\"ywwuyi\") fun talk(): Nothing = throw UnsupportedOperationException() var i: Int get() = 1551 set(value) = println(value) companion object { /* ... */ } } 使用起来就根普通的类一样： fun test() { val duck = Duck(\"ywwuyi\") println(duck.name) println(duck.i) duck.i = 6655 duck.talk() } 聪明的同学可能已经猜到了内联类的所谓「消除创建对象的开销」指的是什么。在经过编译器的处理后，以上代码就变成了下面这样： fun test() { val duck = \"ywwuyi\" println(duck) // 输出 1551 println(Duck$Erased.getI(duck)) Duck$Erased.setI(duck, 6655) Duck$Erased.talk(duck); } 整个类实例被“内联”掉了，只剩下它里面包裹的值。对成员方法的调用变成了对静态函数的调用（类似于扩展函数）。 也就是说，Inline class 可以给某个类型的值创建一个装箱类（就像上面的 Duck 包装了一个 Int 类型的值），并且这个装箱类能够被内联，“箱子”不复存在，只剩下那个被装箱的值。换句话说，内联类看起来就像是一个“零开销”的 wrapper。 用途举例垃圾没用.jpg、进入胡说八道模式.jpg。 严格的类型别名我们知道 Kotlin 有类型别名，能给某个类型取一个另外的名字。例如我们想用类型别名弄一个长度单位「米」： typealias Meter = Double 但是 Meter 和 Double 其实是同一个类型，你并不能阻止将一个 Meter 赋值给一个 Double 类型的变量，你也并不能阻止两者相加。 val a: Meter = getMeter() val b: Double = getMeter() val c = a + b 但是如果这里使用内联类就不一样了： inline class Meter(val value: Double) { operator fun plus(m: Meter) = Meter(this.value + m.value) } fun test2() { var a = Meter(1.0) val b = Meter(2.0) val c = a + b // ok, c的类型为Meter a = 3.0 // 编译错误：type mismatch } 由于 Meter 是内联类，所以上面的代码实际上并不会创建 Meter 类的实例，在运行时只是在操纵 double，但是却保证了井水不犯河水，Meter 和 Double 各不相干。你甚至可以用内联类定义一套计量单位。 任何你想得到的包装类（wrapper）“无痛”创建任何 wrapper，不用担心开销。 例如嫌原来的方法名字太丑，那就包一层： interface Aa { fun a1() fun a2() } inline class Fuck(val a: Aa) { inline fun fuck1() = a.a1() inline fun fuck2() = a.a2() } 例如属性代理： inline class InlinedDelegate&lt;out T>(val value: T): ReadOnlyProperty&lt;Any?, T> { override inline operator fun getValue(thisRef: Any?, property: KProperty&lt;*>): T { // do everything you like return value } } class Test { val some: String by InlinedDelegate(\"just for test\") } etc. 无符号整型无符号整型（unsigned integer）也是 Kotlin Future Features Survey 里面出现过的 feature（第12号），由于内联类的实装，无符号整型因此可以很好地实现，而不会有过大的开销。 inline class ULong(private val data: Long) : Comparable&lt;ULong> { /* balabala */ } fun test() { val a = 2_147_483_648.toUInt() // a 的类型为 UInt val b = 1_000_000_000 val c = a + b // c 的类型为 UInt println(c) // 3147483648 } 同时还新增了无符号整形字面量来简化声明。 // 结尾的u意味着这是一个无符号整形 val uintMask = 0xFFFF_FFFFu // UInt val ulongUpperPartMask = 0xFFFF_FFFF_0000_0000uL // ULong 无符号整型将在 Kotlin 1.3 实装。 Try/Result Monad（伪）函数式风格的错误处理，世面上已经有太多类似的玩意了（Arrow 的 Try，隔壁 Scala 的 Try[T]，河对面 Haskell 的 Exceptional e t）。 所以 Kotlin 官方团队打算把类似的东西塞进标准库里，预计将在 Kotlin 1.3 版本实装。 inline class Result&lt;T>(val value: Any?) { // 省略一万字 } 不过具体的情况还很微妙，Roman 大爷说并不打算做得和 Arrow 的那个一样，而是做成一个功能十分有限的玩意，连 flatMap 都要你自己写出来。没有 flatMap 的 Monad 还能叫做 Monad 么？ 目前来看，只是用于精简协程中的 Continuation 接口用。 更多的用处由于篇幅关系省略不写，摸了~ 补充：Kotlin 1.3 实装后，看起来野心蛮大，在之后的版本也许会针对 Result 重载 ?.、!! 等操作符。 编译器的魔术这里是 Kotlin 1.2 版本的内联类的实现细节。 在你声明一个内联类的时候，编译器会为你生成两个类，一个类是内联类本体，另一个是为内联进行支持的辅助类。例如： inline class Dog(val name: String) : Cloneable { constructor() : this(\"quin\") fun talk() = println(\"rua~\") val next: Int get() = 22 } 经过编译器之手，就变成了如下这样（细节已省略）： inline class Dog(val name: String) : Cloneable { constructor() : this(\"quin\") fun talk() = Dog$Erased.talk(name) val next: Int get() = Dog$Erased.getNext(name) fun unbox() = name } public static final class Dog$Erased { public static final void talk(String $this) { System.out.println(\"rua~\"); } public static final int getNext(String $this) { return 22; } public static final Dog box(String v) { return new Dog(v); } } 对于用到内联类的地方，例如 fun test1(dog: Dog) { dog.next test2(dog, dog, dog) } fun &lt;T> test2(dog1: Dog?, dog2: Cloneable, dog3: T) { dog1!!.talk() (dog3 as Dog).name } 内联后变成这样（细节已省略）： fun test1(dog: String) { Dog$Erased.getNext(dog) test2(dog, Dog$Erased.box(dog), Dog$Erased.box(dog)) } fun &lt;T> test2(dog1: String?, dog2: Cloneable, dog3: T) { Dog$Erased.getNext(dog1!!) (dog3 as Dog).unbox() } 从上面可以看出，并不是所有的用处都能内联掉，在需要的时候仍然会将其装箱。 更多的细节由于篇幅关系省略不写，摸了~ 补充：对于 Kotlin 1.3，不会再生成一个名为 ***$Erased 的合成类，而是将这些静态方法放在了同一个类里。 补充说明未来可能支持内联枚举（inline enum），就像这样（随便找了一段 Java 代码用 Kotlin 重写）： inline enum NavigationMode(val value: Int) { NAVIGATION_MODE_STANDARD(0), NAVIGATION_MODE_LIST(1), NAVIGATION_MODE_TABS(2); } abstract val navigationMode: NavigationMode 另外未来可能支持 reified 泛型参数，比如这样： inline class Reified&lt;reified T>(val some: T) fun foo(a: Reified&lt;Int>, b: Reified&lt;String>) // 编译后 fun foo(a: Int, b: String) 更多的补充说明由于摸了的关系省略不写~","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"Kotlin Contracts DSL","slug":"kotlin-contracts-dsl","date":"2018-03-25T08:31:53.000Z","updated":"2020-05-26T15:26:05.743Z","comments":true,"path":"2018/03/25/kotlin-contracts-dsl/","link":"","permalink":"https://aisia.moe/2018/03/25/kotlin-contracts-dsl/","excerpt":"从 Kotlin 1.2 版本开始，如果你查看 apply、let 等函数的源码，你会发现比 1.1 版本多了几行不明觉厉的代码","text":"从 Kotlin 1.2 版本开始，如果你查看 apply、let 等函数的源码，你会发现比 1.1 版本多了几行不明觉厉的代码： public inline fun &lt;T, R> T.let(block: (T) -> R): R { // kotlin 1.2 加了下面三行代码 contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } // kotlin 1.2 加了上面三行代码 return block(this) } 很好，接下来就讲讲那几行多出来的代码到底有什么用。 本文使用的 Kotlin 版本为 1.2.31。 简单的需求假设我们有这样一段代码： fun some() { var text: String? = getText() if(text.isNullOrEmpty()) { text = \"我永远喜欢燕结芽\" } println(text.length) // error, cannot smart cast to String } 稍有常识的人都会看出，如果我们的代码继续执行，这个可空类型的 text 变量，在最后一行那里不可能为 null。 但是编译器傻乎乎地向你丢出了一个编译错误：Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String? 原因在于编译器不能深入分析每个函数（在这个例子中是 isNullOrEmpty）的数据流，无法得知「test 不为空」的事实，也就无法进行 Smart Cast 了。 所以如果要享受到 Smart Cast 的便利的话，可以手动将 isNullOrEmpty 内联展开： if(text == null || text.isEmpty()) { text = \"我永远喜欢燕结芽\" } println(text.length) // ok, smart cast to String 但是这很麻烦，而且还不好看。为了解决这个问题，于是就有了 Contracts DSL。 Contracts DSLContracts DSL 可以为编译器提供关于函数行为的附加信息，帮助编译器分析函数的实际运行情况，从而让更多正确的代码能通过编译（例如上面的例子）。 我们可以查看一下 isNullOrEmpty 的源码： public inline fun CharSequence?.isNullOrEmpty(): Boolean { contract { returns(false) implies (this@isNullOrEmpty != null) } return this == null || this.length == 0 } 这里简单解释一下 contract 代码块里面的那行代码，表示「如果返回值为false，那么this（函数的接收者）不为null」。 因为这个东西目前还是个实验性特性，处于内部评估的状态，尚未对外公开发布，所以是默认关闭的。如果启用了该特性，那么编译器就能解析获取 Contracts DSL 所表达的信息，用于数据流分析。 在 Kotlin 1.2 版本，为了开启这个特性，我们需要给编译器传入提供额外的编译参数： -Xeffect-system -Xread-deserialized-contracts 然后下面的代码就能够正常通过编译： // 如果未开启 contract, 则会出现注释里的编译错误 fun test() { val str: String? run { // captured value initialization is forbidden due to possible reassignment str = \"でないと、私のすごいとこ 見せられないじゃん\" } println(str) // str not initialized val notNull1: Any? = str requireNotNull(notNull1) println(notNull1.hashCode()) // cannot smart cast to Any val notNull2: String? = str if (!notNull2.isNullOrEmpty()) { println(notNull2.length) // cannot smart cast to String } } 虽然在 IDEA 里这些代码仍然会被标上红色下划线表示有错，但是加上编译器参数后的确能通过编译，也能够正常运行。 就拿上面例子的 run 函数说起，看看源码： public inline fun &lt;R> run(block: () -> R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block() } 编译器可以知道「传入的 lambda 会立即在“原地”执行有且仅有一次」，那么 str 一定会被初始化，而且不会被重新赋值。编译通过！ 在 Kotlin 1.2 版本里 Contracts DSL 位于 kotlin.internal.contracts 这个包内，是 internal 的，一般用户还无法直接拿来写自己的 contract。 这个特性已经在 Kotlin 1.3 版本实装。 试着编写自己的 contract在 1.2 版本编写自定义 contract 的方法： 将 1.2 版本标准库里的 contract 源码文件复制出来，丢到自己项目的源码文件夹里（也就是和自己的代码放在一起），包名保持 kotlin.internal.contracts 不要变，然后再加上编译器参数： -Xeffect-system -Xread-deserialized-contracts -Xallow-kotlin-package 然后随便写了一下，看起来就像这个截图这样： 实际体验的话，那个 implies() 目前只支持几个基本的模式（空检验、类型检验等，以后应该会增加新的模式），IDEA 的报错也是时好时坏（一切以编译结果为准）。 而且我尝试写了如下的 contract： inline fun &lt;reified T> Any?.isInstanceOf(): Boolean { contract { returns(true) implies (this@isInstanceOf is T) } return this is T } 也不知道是我太鶸还是 Kotlin 太辣鸡，上面这个 contract 看起来不起作用。 嘛反正是处于实验阶段的特性，也不强求什么，至少比没有强（ 1.3 版本正式发布后，已经不需要搞七搞八，可以自由使用了。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"为什么我不用 Gradle Kotlin DSL","slug":"why-not-gradle-kts-dsl","date":"2018-02-26T11:11:00.000Z","updated":"2020-05-26T15:26:05.741Z","comments":true,"path":"2018/02/26/why-not-gradle-kts-dsl/","link":"","permalink":"https://aisia.moe/2018/02/26/why-not-gradle-kts-dsl/","excerpt":"一图流。\nGroovy：优雅，简洁，美观！\n\nKotlin DSL：你看看这何等鬼畜的用法！\n","text":"一图流。 Groovy：优雅，简洁，美观！ Kotlin DSL：你看看这何等鬼畜的用法！","raw":null,"content":null,"categories":[],"tags":[{"name":"Others","slug":"Others","permalink":"https://aisia.moe/tags/Others/"}]},{"title":"Kotlin协程 - 先入个门吧","slug":"kotlin-coroutine-kepa","date":"2018-02-08T15:16:58.000Z","updated":"2018-11-20T16:31:05.000Z","comments":true,"path":"2018/02/08/kotlin-coroutine-kepa/","link":"","permalink":"https://aisia.moe/2018/02/08/kotlin-coroutine-kepa/","excerpt":"你们要的协程文，嗯。封面图id：66548341。","text":"你们要的协程文，嗯。封面图id：66548341。 （我终于学会嵌入网易云音乐了，音量注意） 因为是入门嘛，所以本文保证不会出现任何与 kotlinx.coroutines 相关的内容。 本文写于Kotlin1.2的时代，1.3有点变化。所以修订一下本水文，增加一些内容，将原来的过时内容修改为1.3版本的内容，删减一些无关紧要的破事水。 前言事先说明一点，本文的协程，专指Kotlin语言的协程，仅对Kotlin有效。本文完全不涉及其他编程语言的协程或类似的概念。 话说为什么我要在已经有那么多篇优秀的协程文的情况下再水一篇呢？ 首先，因为我太鶸了，bennyhuo的那篇文章根本看不懂，一开始上来就抛出一堆难以理解的专业名词，比如线程、Lua、CoroutineContext 等等，再加上那一堆根本看不懂的 Lua 代码以及 UML 类图，萌新一脸懵逼，直接被劝退，根本不留情面。所以我决定自己写一篇（自己能看懂的）。 其次，在Kotlin1.3版本更新之后，Kotlin官网上的参考文档的协程部分，完全套用了 kotlinx.coroutines 这个官方协程库的教程，对基本语法、标准库内容避而不谈。个人认为这并不合适，了解协程的原理、协程的本质也是十分重要的一环，就酱紫。 本水文不保证其他读者能看懂！（逃 Kotlin 协程有什么用 Kotlin 1.1 的关键新特性是协程，它带来了 future/await、 yield 以及类似的编程模式的支持。Kotlin 的设计中的关键特性是协程执行的实现是语言库的一部分，而不是语言的一部分，所以你不必绑定任何特定的编程范式或并发库。 很多人都会纳闷这Kotlin的协程到底有什么用，有什么好处。 在Kotlin官网上的参考文档里讲到「协程实际上是一个轻量级的线程，可以挂起并稍后恢复」，并且使用 kotlinx.coroutines 里的 launch 函数作为例子： repeat(100_000) { // 启动大量的协程 launch { ... } } 如果你找过其他官方资料，还能发现有将 launch 与 Thread.start 对比的例子，大多是在“我轻松开10W个协程，你开1K个线程试试”云云。 然而这只是其中一个优点，并且容易使人感觉「协程只是线程池和线程调度的封装罢了」，未能感受到协程真正魅力所在，十分可惜。 针对上述问题，一个比较好的答案是： Kotlin协程是 callback 的语法糖，它的主要好处是能让你写不需要 callback 的异步代码。换言之，把异步代码写得看起来就想同步的一样。 直接拿官方的一段代码来做例子，假设有一段回调地狱代码如下： // 将数据从通道异步读入`buf`, 完成后运行lambda inChannel.read(buf) { // 这个lambda在读取完成时执行 bytesRead -> ... ... process(buf, bytesRead) // 从`buf`异步写入通道, 完成后运行lambda outChannel.write(buf) { // 这个lambda在写入完成时执行 ... ... outFile.close() } } 再假设上述异步API（即read和write）有支持Kotlin协程的版本（用Kotlin协程对异步API封装为aRead和aWrite），则可以用协程将上面代码改写成如下形式： launch { // 当异步读取进行时挂起协程 val bytesRead = inChannel.aRead(buf) // 只有在读取完成时才执行至这一行 ... ... process(buf, bytesRead) // 当异步写入进行时挂起协程 outChannel.aWrite(buf) // 只有在写入完成时才执行至这一行 ... ... outFile.close() } 看起来就像是没有回调、就像是同步代码一样。然而，协程仅仅是 callback 的语法糖，上面的代码仍然是包含了两个回调的异步代码，但是看起来却无比舒服。 那么，Kotlin协程是如何做到的呢？ 基本操作先说说Kotlin标准库在1.3版本新增了一个类 Result&lt;T&gt;。 Result&lt;T&gt; 是一个用于表示 Kotlin 函数执行成功和失败结果的 discriminated union（也叫 tagged union 或者是 algebraic data type），即 Success T | Failure Throwable，很简单。 不懂也没关系。 suspend 关键字Kotlin在1.1版本新增加了 suspend 关键字，可以用来修饰函数或者 lambda 表达式的类型： suspend fun suspendFunction(): String { …… } // ↑ 你看这辣鸡代码高亮 ↓ val suspendLambda: suspend () -> Unit = { …… } // 上面这个suspend lambda的类型需要显式标明 // 不然其类型会推导成普通的lambda而不是suspend lambda 从Kotlin1.2.30版本开始，可以这样声明 suspend lambda，能够自动推导类型。 // Kotlin 1.2.30 以降 val suspendLambda2 = suspend { \"Hello world!\" } // suspendLambda2 的类型将被自动推导为 suspend () -> String // PS：在这里suspend是一个伪关键字 现在，你得到了 suspend 函数和 suspend lambda。被标记为 suspend 的函数/lambda 只能在 suspend 函数/lambda 中被调用。 在Kotlin1.3版本，新增了 suspend main 功能。 suspend fun main() { println(\"hello coroutine\") } 创建和启动协程创建并启动一个协程十分简单，你只需要两件宝具：一个 suspend lambda，以及一个 Continuation： import kotlin.coroutines.* val suspendLambda = suspend { \"Hello world!\" } val completion = object : Continuation&lt;String> { override val context get() = EmptyCoroutineContext override fun resumeWith(result: Result&lt;String>): Unit = println(result.getOrThrow()) } 使用 Kotlin 标准库中的 createCoroutine 函数来创建协程： val coroutine: Continuation&lt;Unit> = suspendLambda.createCoroutine(completion) 这样你就得到了一个未启动的协程，然后调用 resume 扩展方法启动这个协程： coroutine.resume(Unit) // 打印出 Hello world! 或者使用标准库里的 startCoroutine 函数来创建并立即启动一个协程： suspendLambda.startCoroutine(completion) // 打印出 Hello world! 很简单。另外对于有带接收者的 suspend lambda，有与之相对应的库函数。 // 创建协程 fun &lt;T> (suspend () -> T).createCoroutine(completion: Continuation&lt;T>): Continuation&lt;Unit> fun &lt;R, T> (suspend R.() -> T).createCoroutine(receiver: R, completion: Continuation&lt;T>): Continuation&lt;Unit> // 创建并启动协程 fun &lt;T> (suspend () -> T).startCoroutine(completion: Continuation&lt;T>): Unit fun &lt;R, T> (suspend R.() -> T).startCoroutine(receiver: R, completion: Continuation&lt;T>): Unit // 常用的扩展方法 fun &lt;T> Continuation&lt;T>.resume(value: T) = resumeWith(Result.success(value)) fun &lt;T> Continuation&lt;T>.resumeWithException(exception: Throwable) = resumeWith(Result.failure(exception)) 协程挂起和恢复执行想要暂停一个协程的执行，可以使用标准库里面的 suspendCoroutine 函数： val suspendLambda = suspend { println(\"before suspend\") suspendCoroutine&lt;Unit> { } println(\"after suspend\") } suspendLambda.startCoroutine(object : Continuation&lt;Any> { …… }) // 输出： // before suspend 如果需要恢复协程，例如等待3秒后继续执行： val suspendLambda = suspend { println(\"before suspend\") val int: Int = suspendCoroutine { c -> Thread.sleep(3000) c.resume(1551) } println(\"after suspend, resume with $int\") } suspendLambda.startCoroutine(object : Continuation&lt;Any> { …… }) // 输出（两行输出间隔3秒）： // before suspend // after suspend, resume with 1551 suspendCoroutine 函数的签名如下： inline suspend fun &lt;T> suspendCoroutine(crossinline block: (Continuation&lt;T>) -> Unit): T 如果你知道这上面的各段代码在执行的过程中究竟发生了什么，那太棒了，你不需要浪费时间阅读这篇辣鸡水文，请点击右上角的关闭按钮。 概念摘出：ContinuationContinuation（续延）究竟是一个什么概念？一般来讲，Continuation 表示的是「剩余的计算」的概念，换句话说就是「接下来要执行的代码」。举个例子来说，假设我们有这样一段代码： println(1551.toString().length) 我们知道这段代码会先执行 1551.toString()，然后再执行 _.length，最后执行 println(_) 将结果打印出来。 当 1551.toString() 求值之后，需要将其结果传递至 println(_.length)。 可以看到，println(_.length) 需要一个 String 类型的值才能执行。这时我们可以将 println(_.length) 改写成一个 lambda 表达式： { s: String -> println(s.length) } 这个 lambda 表达式（或者说是闭包）就可以是 1551.toString() 的 Continuation，即「剩余的计算」。 这样，我们就可以通过把 &quot;1551&quot; 传给这个 lambda 来重新构建原始的形式： { s: String -> println(s.length) }.invoke(\"1551\") 也就是执行该 lambda 表达式的 invoke 方法以执行「剩余的计算」。 那么 1551.toString().length 的 Continuation 又是什么呢？很简单，是 { i: Int -&gt; println(i) }。 以上讲的就是 Continuation 的一般概念。Kotlin 里面的 Continuation 长什么样子？大概像这样： interface Continuation&lt;in T> { val context: CoroutineContext fun resumeWith(result: Result&lt;T>) } // 常用的扩展方法 fun &lt;T> Continuation&lt;T>.resume(value: T) = resumeWith(Result.success(value)) fun &lt;T> Continuation&lt;T>.resumeWithException(exception: Throwable) = resumeWith(Result.failure(exception)) 这样我们就可以将 Kotlin 的 Continuation 与上面的 lambda 表达式建立一些对应关系，Continuation的 resumeWith 就相当与 lambda 表达式的 invoke，所以当你拿到一个 Continuation 时，resumeWith 方法即是「剩余的计算」的入口。 PS：「剩余的计算」这个概念，是不是跟 callback 很像呢~ 上文基础操作的简要解释来看上文创建协程的例子： val suspendLambda = suspend { ... } val completion = object : Continuation&lt;String> { ... } val coroutine: Continuation&lt;Unit> = suspendLambda.createCoroutine(completion) coroutine.resume(Unit) // 执行已创建好的协程 例中 createCoroutine 函数接受一个 Contiuation 类型的参数 completion，表示「协程执行完之后要执行的代码」。而 suspendLambda 则是协程的主体。 createCoroutine 函数负责把这两个东西整合成一个表示「整个协程所有需要执行的代码」的 Contiuation，称为初始 Continuation（initial continuation）。对其调用 resume 则开始运行。 当 suspendLambda 执行完毕后，将其结果传至 completion 的 resume 扩展方法；若 suspendLambda 的执行过程中抛出了异常，则执行 completion 的 resumeWithException 扩展方法。 再看上文 suspendCoroutine 函数的例子： val suspendLambda = suspend { println(\"before suspend\") val int: Int = suspendCoroutine { cont -> Thread.sleep(3000) cont.resume(1551) } println(\"after suspend, resume with $int\") } suspendCoroutine 会将协程挂起（suspend），并且 suspendCoroutine 这个函数接收一个lambda表达式作为参数，这个 lambda 的 cont 参数即是表示「协程挂起后剩下的还没执行的代码」。 针对这个例子，如果要用lambda表达式来表示 cont 这个 Continuation，则是： { i: Int -> val int = i println(\"after suspend, resume with $int\") } 在线程睡了3000毫秒后，调用 resume 方法将这个协程继续执行下去，suspendCoroutine 的返回值即是通过 resume 方法传入的值（本例中为1551），于是变量int得到值1551，并在之后打印出来。 超简单~！ 编译器的魔术 「别逗我了。那种东西怎么会是魔法！」 那么 Kotlin 的协程是怎么实现的呢？ 协程完全通过编译技术实现（不需要来自 VM 或 OS 端的支持），挂起通过代码来生效。（本句话抄自 Kotlin 中文网） CPS 转换 「CPST 就是 Gödel–Gentzen 变换的 Curry–Howard 像而已，这有什么难理解的？」 在编译时，每一个 suspend 函数会被编译器加上一个 Continuation 参数： // 编译前 suspend fun &lt;T, U> suspendFunction(arg: U): T { …… } // 编译后 fun &lt;T, U> suspendFunction(arg: U, c: Continuation&lt;in T>): Any? { …… } 这叫做 CPS 转换（Continuation-Passing-Style Transformation）。 因此我们可以认为每个 suspend 函数都有一个 Continuation 类型的隐式参数，每个 suspend 函数都能通过这个参数拿到一个 Continuation，代表着「该函数之后将要执行的代码」。 PS：suspendFunction 经过CPS转换后，返回值的那个 Any? 其实是个类似于 union type（并集类型）的玩意。它其实是 T | COROUTINE_SUSPENDED，意为返回值可能为 T 类型的值，也可能是一个 COROUTINE_SUSPENDED。但是辣鸡 Kotlin 没有 union type，所以只能用 Any? ，使用的时候再做类型强转。（看看人家 Scala 和 Ceylon ，做得多好） PPS：如果你喜欢翻看源码，你会发现在 Kotlin 标准库的协程部分以及 kotlinx.coroutines 里面能经常见到这种用 Any? 表示的 union types。 状态机我们知道 Continuation 就相当于一个闭包，经过 CPS 转换，每次调用 suspend 函数都需要传一个 Continuation 进去。为了避免创建过多的闭包和匿名类，Kotlin 选择使用状态机（state machines）来实现 Continuation。 由于懒，我直接把 KEEP 里面的例子抄了过来： suspend 函数会被编译成一个状态机，例如一个 suspend 函数里有以下代码： val a = a() val y = suspendFunction(foo(a)) // 挂起点 1 b() val z = suspendFunction(bar(a, y)) // 挂起点 2 c(z) 其中的2个 suspend 函数调用点（简称挂起点，suspension point）将这段代码分成3个状态： 状态0：第一个挂起点之前（初始状态） val a = a() foo(a) 状态1：第一个挂起点之后，至第二个挂起点之前 val y = _ b() bar(a, y) 状态2：第二个挂起点之后 val z = _ c(z) 代码会被编译成一个匿名类，它具有一个实现状态机的方法，一个保存状态机当前状态的字段，以及各个状态的局部变量的字段，看起来像这样： // 伪代码，简化模型，实际情况会比这个要复杂一些 class 状态机匿名类 extends CoroutineImpl implements Continuation&lt;Object> { // 这个int用来保存状态机当前的状态 int label = 0 // 用来保存suspend方法中的局部变量 A a = null Y y = null // 实现状态机的方法 void resume(Object data) { if (label == 0) goto L0 if (label == 1) goto L1 if (label == 2) goto L2 else throw IllegalStateException() // 英文不翻译了，懒~ L0: // data is expected to be `null` at this invocation a = a() label = 1 data = suspendFunction(foo(a), this) // 'this' is passed as a continuation if (data == COROUTINE_SUSPENDED) return // return if suspendFunction had suspended execution L1: // external code has resumed this coroutine passing the result of suspendFunction() as data y = (Y) data b() label = 2 data = suspendFunction(bar(a, y), this) // 'this' is passed as a continuation if (data == COROUTINE_SUSPENDED) return // return if suspendFunction had suspended execution L2: // external code has resumed this coroutine passing the result of suspendFunction() as data Z z = (Z) data c(z) label = -1 // No more steps are allowed return } } 我们可以看到每次调用 suspendFunction 时，传进去的 Continuation 都是同一个对象，即状态机本身；并且通过 label 来控制状态和代码跳转，使其符合「剩下的计算」的语义。 PS：并不是所有的 suspend 函数都会编译成一个状态机，存在一种尾调用优化（tail call optimization）的机制。举个例子： suspend fun f1() { println(\"do something before calling f2\") f2() // &lt;==这里 } suspend fun f2() { …… } f1函数内部唯一的一个 suspend 调用是在函数尾部的位置（即 tail suspension invocation），这时不会编译成状态机，而是这样： fun f1(c: Continuation&lt;in Unit>): Any? { println(\"do something before calling f2\") f2(c) } fun f2(c: Continuation&lt;in Unit>): Any? { …… } 即尾调用优化。（亲爱的读者可以思考一下为什么可以这么做） 另外，如果 suspend 函数里面没有调用任何 suspend 函数，那么也不会被编译成状态机。 具有Kotlin特色的Call/CC前面提到，编译器会给每一个 suspend 函数添加一个 Continuation 类型的参数，但是我们在代码里是看不到这个参数的，我们要怎么样才能拿到这个参数呢？ 于是乎，Kotlin 厚颜无耻地把 Scheme 的 Call/CC（call-with-current-continuation）抄了过来并加以魔改，放在 kotlin.coroutines.intrinsics 这个包里，就是这玩意： inline suspend fun &lt;T> suspendCoroutineUninterceptedOrReturn( crossinline block: (Continuation&lt;T>) -> Any? ): T // 不要问我为什么这玩意的名字这么长 这个函数是 Kotlin 协程中最为重要的函数，是一个固有函数（intrinsic function，即编译器特殊对待的函数），其实现无法用 Kotlin 代码表示，需要编译器在编译的时候进行替换。如果你去看了它的源码，你会看到类似与这样的东西： inline suspend fun &lt;T> suspendCoroutineUninterceptedOrReturn( crossinline block: (Continuation&lt;T>) -> Any? ): T = throw NotImplementedError(\"Implementation is intrinsic\") // 等号后面也有可能是一个 `null!!` 在经过 CPS 转换后，我们来看一下这个函数的真面目： inline fun &lt;T> suspendCoroutineUninterceptedOrReturn( crossinline block: (Continuation&lt;T>) -> Any?, c: Continuation&lt;T> ): Any? = block(c) 简单明了，直接将这个新增的 Continuation 参数传给了 lambda，这样我们就可以通过这个 lambda 来操纵由 CPS 转换得来的 Continuation。 上文讲过，这里所有的 Any? 其实都是 T | COROUTINE_SUSPENDED ，COROUTINE_SUSPENDED 的定义也在这个包里： val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED @PublishedApi internal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED } 从上文的那个状态机伪代码里面可以看到，对于每个 suspend 函数的调用，都会检查其返回值是不是 COROUTINE_SUSPENDED。如果不是，那么状态机就开始执行下一个状态的代码；如果是 COROUTINE_SUSPENDED，就直接返回，停止执行代码，即协程挂起。可以写个demo来验证一下： suspend fun f3(): Unit = suspendCoroutineUninterceptedOrReturn { c -> COROUTINE_SUSPENDED } val suspendLambda: suspend () -> Unit = { println(\"before suspend\") f3() println(\"after suspend\") } suspendLambda.startCoroutine(object : Continuation&lt;Any> { …… }) 结果只有 before suspend 被打印了出来。如果要继续执行下去，则需要通过 Continuation，调用其 resume 扩展方法： suspend fun f3(): Unit = suspendCoroutineUninterceptedOrReturn { c -> thread { Thread.sleep(5_000) c.resume(Unit) } COROUTINE_SUSPENDED } 这时候我们可以看到，before suspend 先被打印出来，5秒种后，after suspend 再被打印出来。 f3函数经过 CPS 转换、suspend 函数的尾调用优化以及 suspendCoroutineUninterceptedOrReturn 的内联，最终会变成如下的样子： fun f3(c: Continuation&lt;Unit>): Any? { thread { // ↑ 这个Any?其实是 ↓ Thread.sleep(5_000) // Unit | COROUTINE_SUSPENDED c.resume(Unit) } return COROUTINE_SUSPENDED } 看起来就像是在直接操纵编译时添加的 Continuation 参数。 本节比较长，给个小结：suspendCoroutineUninterceptedOrReturn 能够让你直接操纵通过CPS转换得来的 Continuation 参数。 suspendCoroutineUninterceptedOrReturn { cont -> ... } 这个函数接收一个 lambda 参数，在这个 lambda 里面，你将面临两种选择：直接返回需要的结果（不挂起协程）或者返回 COROUTINE_SUSPENDED（挂起协程）。如果你选择挂起协程，你需要在合适的地方与时机调用（从lambda的参数得到的）Continuation 的 resume 扩展方法将需要的结果传入以便继续执行协程。 Kotlin 标准库里面的 suspendCoroutine 即是对 suspendCoroutineUninterceptedOrReturn 的封装，使其更易于使用。读者可以对比一下两者的函数签名以及文档上的注意事项。一般情况下使用 suspendCoroutine 即可满足需求。 PS：不知道从什么时候开始的，kotlin.coroutines.intrinsics 这个包以及里面的所有东西，都不会出现在 Intellij IDEA 的自动补全的列表里了。你需要手动 import 这个包，才能享受到自动补全的便利。 PPS：本文完。 你学到了什么 Kotlin协程的一些（不常用的）标准库函数的使用方法 编译器都做了什么事（的一部分） suspendCoroutineUninterceptedOrReturn 有什么用 下一篇协程文？不存在的。 课后作业：我在 Codewars 上面出了一道题，要求实现简单的控制流，很简单。如果你能看懂这篇文章，那么这道题对于你来说应该是十分简单的。（千里冰封julao仅用了不到十分钟的时间就做出来了） 反编译Tip：Intellij IDEA的Kotlin插件有将Kotlin代码的字节码反编译至Java的功能，但是在面对协程相关的代码时大多数情况下都不好用。请不要想太多，老老实实用其他反编译工具，我用的是这个jadx，版本0.6.1。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"},{"name":"Coroutine","slug":"Coroutine","permalink":"https://aisia.moe/tags/Coroutine/"}]},{"title":"Kotlin的一些技巧和迂回操作","slug":"kotlin-jiqiao","date":"2018-01-07T19:03:42.000Z","updated":"2018-11-20T09:35:42.000Z","comments":true,"path":"2018/01/07/kotlin-jiqiao/","link":"","permalink":"https://aisia.moe/2018/01/07/kotlin-jiqiao/","excerpt":"RT，不定期更新。\n目录：\n\n扩展属性的backing field","text":"RT，不定期更新。 目录： 扩展属性的backing field 不依赖getter和setter的lateinit属性 解除内联类的一些限制 开启残废的SAM转换功能 如何添加编译器参数 不需要import就能使用的顶层函数 递归的Lambda表达式 阻止编译器添加对非空类型的NullCheck 给主构造器内的属性自定义getter和setter 流的读取 限制扩展的作用域 链式调用时输出中间值 扩展属性的backing field众所周知扩展属性是没有backing field的，它其实就是扩展函数的特殊形式。但是总有人想要给某个类扩展一个真正的field，就像下面那样。 class Some {} // unresolved reference: field var Some.rua : String get() = field set(value) { field = value } 这种需求针对不同的实际情况有不同的解决方法，下面给出一个非最优但是比较通用的方法。 val ruaMap: MutableMap&lt;Some, String> = TODO() var Some.rua : String get() = ruaMap[this] ?: \"\" set(value) { ruaMap[this] = value } 我们总要找个地方将数据存起来，这里选择了一个全局的Map来解决存储问题。 需要注意的是，这里对Map的类型有要求：因为不能干扰jvm的垃圾回收机制，所以需要是WeakReferenceMap；因为每个实例都需要保存一份自己的数据，所以需要是IdentityMap；如果在多线程环境跑这代码，需要是ConcurrentMap。综上你需要一个ConcurrentWeakIdentityMap来解决这个问题。 不依赖getter和setter的lateinit属性lateinit属性之所以无法自定义getter和setter，是因为需要在getter插入空检测，并且保证setter能给backing field赋值。 迂回方法如下： @UseExperimental(ExperimentalContracts::class) inline fun trick(willNotBeInvoked: () -> Unit) { contract { callsInPlace(willNotBeInvoked, InvocationKind.EXACTLY_ONCE) } } fun &lt;T> undefined() : T = throw Exception() class Some { var lateInit: String init { trick { lateInit = undefined() } } } var lateInit: String val no_use = trick { lateInit = undefined() } 原理：利用contracts欺骗Kotlin编译器，让它以为属性已被正常初始化（然而并不），属性停留在未被初始化的阶段，从而模拟 lateinit 的功能。当然安全性需要由敲代码的人来保证了。 因为是假的lateinit，所以反射 Some::lateInit.isLateinit 将返回 false。 用途：自定义getter或setter、@JvmField 解除内联类的一些限制不开后门的话，Kotlin1.3的新功能内联类的作用将十分有限。 // 非公有构造器，以及泛型 @Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\") inline class Some&lt;T> private constructor(val s: T) // 非顶层声明 class Outer { @Suppress(\"INLINE_CLASS_NOT_TOP_LEVEL\") inline class Inner(val s: String) } 可能有Bug（逃 开启残废的SAM转换功能Kotlin1.3版本有用，没试过更旧的版本。 添加编译器参数： -XXLanguage:+NewInference -XXLanguage:+SamConversionForKotlinFunctions 以下代码能通过编译： fun test(runnable: java.lang.Runnable) { test {} } 然而如下代码仍然不能通过编译： interface CanRun { fun run() } fun test(runnable: CanRun) { test {} // 这里报错 } 副作用：NewInference可能存在bug，并且当出现编译错误的时候可能得到一堆难懂的报错信息。 如何添加编译器参数使用 Gradle： // build.gradle compileKotlin { ... kotlinOptions.freeCompilerArgs += [\"-foo\", \"-bar\"] } PS：使用Gradle的话，请注意IDEA的 Delegate IDE build/run actions to gradle 这个选项是否勾选的区别。 使用 Gradle Kotlin Dsl： // build.gradle.kts import org.jetbrains.kotlin.gradle.tasks.KotlinCompile tasks.withType&lt;KotlinCompile> { ... kotlinOptions.freeCompilerArgs += listOf(\"-foo\", \"-bar\") } // 或者是下面这样 val compileKotlin: KotlinCompile by tasks kotlinOptions.freeCompilerArgs += listOf(\"-foo\", \"-bar\") IDEA项目，不使用Maven、Gradle构建工具的情况： 有两个地方：一个是对整个Project有效的全局设置；另一个对单独Module有效，可以覆盖全局设置。 全局设置：File -&gt; Settings -&gt; 找到 Kotlin Compiler -&gt; Additional command line parameters Module设置：File -&gt; Project Structure -&gt; Module -&gt; 找到目标Module里面的Kotlin设置 -&gt; Additional command line parameters 如果Module设置没有Kotlin的话，可以点击「+」按钮手动加上 Kotlin 设置。 不需要import就能使用的顶层函数一个顶层函数，除非你在同一个文件里使用，否则就需要 import 或者使用完全限定名。问题是有些人就是嫌烦，想要所谓的“全局函数”，就像 Kotlin 标准库里的 println 一样。 其实很简单，只需要写得跟 println 一样就行了： package kotlin fun fuck() {} 因为 kotlin 包下的东西都是自动导入的，也就不需要自己动手导入啦。 需要传入编译器参数 -Xallow-kotlin-package 来允许使用 kotlin 开头的包名。 递归的Lambda表达式在某个 Kotlin 裙里看到有人在问： 是不是lambda无法递归 举个例子，我们可以写一个简单的递归函数： fun a() { println(\"1551\"); a() } a() // 打印出很多1551 如果要写成 Lambda 呢？这样的代码会报错： val a: () -> Unit = { println(\"1551\"); a() } 我们自然是不能直接写这样的代码的，它会说 a 没有定义。解决方法当然是使用 lateinit： lateinit var a: () -> Unit a = { println(\"1551\"); a() } a() // 打印出很多1551 更进一步：匿名 Lambda 表达式的递归 正统的「Lambda演算」里面的函数全部都是匿名函数，需要使用「不动点组合子」实现递归： // 这是kotlin-js val z = { f: dynamic -> { g: dynamic -> g(g) } { x: dynamic -> f { y: dynamic -> x(x)(y) } } } val a = z { f: () -> Unit -> { println(\"1551\"); f() } } // 求斐波那契数列第n项的函数 val fib: (Int) -> Int = z { f: (Int) -> Int -> { x: Int -> if (x &lt;= 2) 1 else f(x - 1) + f(x - 2) } } // 输出斐波那契数列前10项 println((1.rangeTo(10).map(fib))) 上面的那一坨 val z 即是「Z组合子」。（读者可以思考一下为什么这里我给了 Kotlin-js 的例子是而不是 Kotlin-jvm（逃 阻止编译器添加对非空类型的NullCheck总所周知，当一个函数的参数是非空类型时，Kotlin编译器会在方法入口处加一行检查入参是否为空的代码。比如说 main 函数： fun main(args: Array&lt;String>) {} 经过编译后，再反编译成Java： public static final void main(@NotNull String[] args) { Intrinsics.checkParameterIsNotNull(args, \"args\"); } 可恶！辣鸡编译器自作主张！我不想要这行代码！ 如果不想编译器生成这些代码，需要添加编译器参数，如下 -Xno-call-assertions -Xno-param-assertions -Xno-receiver-assertions 给主构造器内的属性自定义getter和setterdata class SomeClass(var name: String) 众所周知 Kotlin 不允许给声明在主构造器里面的属性写自定义getter、setter，主要是为了防止有好事者乱写，破坏规则就不好了。所以迂回操作如下： data class SomeClass(private var _name: String) { var name: String get() = _name set(value) { _name = value } } 解释：private的_name不会生成getter和setter，你再把你想写的getter和setter添上就好。这样SomeClass里面就有3样东西：String _name，String getName()和void setName(String)（以及data class根据_name自动生成的那些）。 缺点很明显，toString 生成的字符串会比较丑。 流的读取普通青年： // java 代码 void someFunc(InputStream in, OutputStream out) throws IOException { int read; while ((read = in.read()) != -1) { out.write(read); } } 文艺青年： fun someFunc(`in`: InputStream, out: OutputStream) { var read: Int = -1 while ({ read = `in`.read();read }() != -1) { out.write(read) } } 二逼青年： fun someFunc(`in`: InputStream, out: OutputStream) { var read: Int = `in`.read() while (read != -1) { out.write(read) read = `in`.read() } } 天哪，真是太完美了： fun someFunc(`in`: InputStream, out: OutputStream) { var read: Int = -1 while (`in`.read().also { read = it } != -1) { out.write(read) } } 在 Kotlin 1.3 版本正式启用了 contracts 功能后，上面这种写法能应对更多情况。 限制扩展的作用域（防止污染命名空间）注意：此技巧并不稳定，可能在未来被官方干掉。 // 把扩展丢进一个object里面 object StringExtension { @JvmStatic fun String.fuck() = println(\"fuck $this\") } // 使用说明 fun test() { // 下面这行被注释掉的代码不能通过编译 // \"kotlin\".fuck() // 你要这么用，将MyExtentions塞进上下文（即this） with(StringExtention) { \"kotlin\".fuck() } } // 或者手动引入 import StringExtension.fuck fun test() { \"kotlin\".fuck() } // 以下是夏姬八写，别模仿 interface Extension inline fun &lt;T : Extension, R> T.use(block: T.() -> R) = this.block() object StringExtension : Extension { @JvmStatic fun String.fuck() = println(\"fuck $this\") } object IntExtension : Extension { @JvmStatic fun Int.love() = println(\"I love $this\") } fun test() { StringExtension.use { \"kotlin\".fuck() } IntExtension.use { 1551.love() } } 链式调用时输出中间值inline fun &lt;T> T.println(): T = printlnBy { it } inline fun &lt;T, U> T.printlnBy(selector: (T) -> U): T = this.also { println(selector(it)) } fun test() { listOf(1, 2, 3).asSequence() .map { it * 3 }.printlnBy { it.sum() } // &lt;==这里 .filter { it and 1 == 0 } .sum().println() // &lt;==还有这里 } // 输出： // 18 // 6 注意副作用，别夏姬八用！ 如果是集合操作，可以考虑使用 onEach 这个高阶函数，例如onEach { println(it) }。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"【水】Kotlin Puzzlers 改","slug":"kotlin-puzzlers","date":"2017-12-28T16:08:56.000Z","updated":"2020-05-26T15:26:05.725Z","comments":true,"path":"2017/12/28/kotlin-puzzlers/","link":"","permalink":"https://aisia.moe/2017/12/28/kotlin-puzzlers/","excerpt":"《Java Puzzlers》（中文名《Java 解惑》）里面讲解了许多 Java 语言的大坑，相信各位julao应该都看过。Kotlin 作为「a better Java」，在填补一些坑的同时，不可避免地引入了许多新坑。","text":"《Java Puzzlers》（中文名《Java 解惑》）里面讲解了许多 Java 语言的大坑，相信各位julao应该都看过。Kotlin 作为「a better Java」，在填补一些坑的同时，不可避免地引入了许多新坑。本来本鶸进行了一段时间的取材，想要写一篇《Kotlin Puzzlers》的，可谁知 已经有人早就把我的饭碗抢走了，而且素材比我还多，可恶！ 这篇文章就是本鶸看完录像（油土鳖上面有）以及 Github 上的完整内容后，将一些比较坑的谜题拿出来报复社会，蛐蛐一篇观后感而已。 题型为选择题，本辣鸡博客没有NGA的折叠，没有萌百的黑幕，为了防止一眼瞄到答案而造成剧透，本文对答案（以及解释）的摆放位置做了调整，例如第一题的答案被我放在了第二题的位置（以此类推）。各位看客从上到下开始阅读就好了。 使用的 Kotlin 版本为1.2。 没有坑到我的谜题虽然没有被坑，比较简单，但是值得注意的题。一些更加简单的题目就不放上来了。想刷一遍完整题库的同学可以到 GitHub 上面找。 强力返回 ~ Power Returnfun hello(): String { val result = return throw return \"Hello\" println(result.toString()) } println(hello()) 这会打印出什么？ a) Hello b) 两个Hello c) 这破代码根本没法通过编译 d) 以上答案都不对 本题答案（以及解释）在下一题那里。（以此类推） 计划生育 ~ One Chile Policyopen class Node(val name: String) { fun lookup() = println(name) } class Parent : Node(\"parent\") { fun child(name: String): Node? = Node(name) val child1 = child(\"child1\")?.apply { lookup() } val child2 = child(\"child2\").apply { lookup() } } Parent() 这会打印出什么？ a) child1 和 child2 b) child1 和 parent c) parent 和 child2 d) 以上答案都不对 上一题的答案：a 要记住，return *** 和 throw *** 都是表达式，其结果的类型为 Nothing，Nothing 类型是任意类型的子类型，所以 Nothing 可以被抛出，可以被返回，可以赋值给任意类型的变量。事实上 hello() 在 return &quot;Hello&quot; 的时候已经结束了，剩下的 throw、val result、println() 什么的都是不可到达代码（unreachable code），不会被运行。 PS：你甚至可以写出这样的代码：throw throw throw Exception() 两只拉姆达跑得快 ~ Two Lambdatypealias L = (String) -> Unit fun foo(one: L = {}, two: L = {}) { one(\"one\") two(\"two\") } foo { print(it) } foo({ print(it) }) 这会打印出什么？ a) oneone b) twotwo c) onetwo d) 以上答案都不对 上一题的答案：b 事实上是 child1 和 parent。Kotlin 的这些扩展方法如 apply、let、also 等等都是适用于所有类型的，包括可空类型。child2 那行 apply 函数接收的拉姆达表达式的类型其实是 Node?.() -&gt; Unit，如果 child2那行代码是写在 Parent 类的外面的话，你就会发现这行代码根本没法通过编译，这里面调用的 lookup 实际上是 parent 的 lookup。（你可以把 apply 换成 also 试试。） 衔尾蛇 ~ Cyclic Object Constructionsopen class A(val x: Any?) object B : A(C) object C : A(B) print(B.x) print(C.x) 这会打印出什么？ a) nullnull b) C@********null c) ExceptionInInitializerError d) 这破代码根本没法通过编译 上一题的答案：d 实际上是 twoone。第一句的语法只有在拉姆达表达式是最后一个参数的时候才能写的，所以是 two。第二句是普通的方法调用，先填上第一个参数，第二个参数使用默认值。 PS：想要朴素地实现 foo { } { } 这样的调用的话应该是办不到的吧。(如果能做到请赶快告诉我！) 哇，好长 ~ Breaking Linesval anExtremelyLongAndBoringStatementThatBarelyFitsOnALine = 2 val anotherExtremelyLongStatementThatBarelyFitsOnALine = 2 val someList = listOf(1) val result = someList.map { anExtremelyLongAndBoringStatementThatBarelyFitsOnALine + anotherExtremelyLongStatementThatBarelyFitsOnALine } print(result) 这会打印出什么？ a) [1] b) [2] c) [4] d) [1, 4] 上一题的答案：b B 初始化需要 C，C 初始化需要 B。咦，B 还没初始化完成呢，那么哪来的 B 呢，只能是 null 了啊！ 更详细的解释可以看这里：https://github.com/Kotlin/kotlin-spec/blob/spec-old/kotlin-spec.asc#singleton-objects 换个名字你就不认识我了 ~ Good Child Has Many Namesopen class C { open fun sum(x: Int = 1, y: Int = 2): Int = x + y } class D : C() { override fun sum(y: Int, x: Int): Int = super.sum(x, y) } val d: D = D() val c: C = d print(c.sum(x = 0)) print(d.sum(x = 0)) println() 这会打印出什么？ a) 22 b) 11 c) 21 d) 这破代码根本没法通过编译 上一题的答案：b 之前裙里有julao问过类似的问题所以我没被坑到。你可以把代码丢到IDEA里面，光标定位到加号前面，按下 Ctrl+B 或者 Ctrl+Q，看看那个加号是什么意思吧。解决方法：把加号放在上一行的后面可破。 排序 ~ Sortingval list = arrayListOf(1, 5, 3, 2, 4) val sortedList = list.sort() print(sortedList) 这会打印出什么？ a) [1, 5, 3, 2, 4] b) [1, 2, 3, 4, 5] c) kotlin.Unit d) 这破代码根本没法通过编译 上一题的答案：c 命名参数是静态分配的。 致命的顺序 ~ The Orderclass Order { private val c: String init { the() c = \"\" } private fun the() { println(c.length) } } Order() 这会打印出什么？ a) 0 b) null c) 这破代码根本没法通过编译 d) 以上答案都不对 上一题的答案：c 参见 https://zhuanlan.zhihu.com/p/27234651 本题的答案：d JVM 不想理你并向你抛出了一只 NPE。Java 也有这个问题，Scala 不熟悉不清楚。同样是 JVM 平台上的语言，Ceylon 就没有这个问题，Ceylon 官网的文档有这个问题的说明，可以参考一下（趁机吹一波 Ceylon）。 https://ceylon-lang.org/documentation/1.3/tour/initialization/#definite_assignment_and_definite_initialization Kotlin 官方人员曾表示过修复这个缺陷是一件十分困难的事。 那些坑了我的迷题我果然是鶸，错了这么多，进入自卑模式~ 区间测试 ~ Inclusive Rangeval i = 10.5 when (i) { in 1..10 -> println(\"in\") !in 1..10 -> println(\"!in\") else -> println(\"else\") } 这会打印出什么？ a) in b) !in c) else d) 这破代码根本没法通过编译 据说这道题在 Kotlin 1.0 版本和 1.2 版本里有不同的表现。（我懒得试旧版本了） 极性不定 ~ Weird Chainingfun printNumberSign(num: Int) { if (num &lt; 0) { \"negative\" } else if (num > 0) { \"positive\" } else { \"zero\" }.let { println(it) } } printNumberSign(-2) printNumberSign(0) printNumberSign(2) 这会打印出什么？ a) negative; zero; positive b) negative; zero c) negative; positive d) zero; positive 上一题的答案：a 实际上是把 i 转成 Int 再进行的比较。 $_$ ~ Dollar In Multiline Literalsval multiline = \"\"\" To win \\$999.999 execute \"rm -fr \\$HOME/kotlin-puzzlers/*\" \"\"\".trimIndent() println(multiline) 这会打印出什么？ a) To win \\$999.999 execute &quot;rm -fr \\$HOME/kotlin-puzzlers/*&quot; b) To win 999.999 execute &quot;rm -fr \\/home/user/kotlin-puzzlers/*&quot; c) To win $999.999 execute &quot;rm -fr $HOME/kotlin-puzzlers/*&quot; d) 这破代码根本没法通过编译 上一题的答案：d 相当于： if (num &lt; 0) { \"negative\" } else { if (num > 0) { \"positive\" } else { \"zero\" }.let { println(it) } } 秒懂！ 解决方法：用小括号将那串 if else 括起来再接 let 可破。 你的名字是 ~ Property Overrideopen class Named { open var name: String? = null get() = field ?: \"&lt;unnamed>\" } class Person: Named() { override var name: String? = null get() = super.name set(value) { field = \"Mr $value\" } } val person = Person() person.name = \"Anton\" println(person.name) 这会打印出什么？ a) Anton b) Mr Anton c) &lt;unnamed&gt; d) null 上一题的答案：d 这种 raw string 里面美元符号 $ 一直都是表示模板表达式，而且不能被转义，所以 $HOME 这里糟了。（你问为什么 $999.999 没糟？因为 999.999 不是合法的变量名啊，你在 999.999 两边加上反引号试试。） 解决方法：”””${‘$’}HOME””” 冰雪聪明 ~ Custom Getter Smartcastclass SmartCastable { val list: List&lt;Int> = mutableListOf(1, 2, 3) val set: Set&lt;Int> = mutableSetOf(1, 2, 3) get() = field } val sc = SmartCastable() if(sc.list is MutableList) sc.list.add(4) if(sc.set is MutableSet) sc.set.add(4) println(\"${sc.list}, ${sc.set}\") 这会打印出什么？ a) [1, 2, 3], [1, 2, 3] b) [1, 2, 3, 4], [1, 2, 3, 4] c) UnsupportedOperationException d) 这破代码根本没法通过编译 上一题的答案：c 这里有两个 backing field，Named 类的那个 get 方法操纵了父类的 backing field，set 方法操纵的是自己的 backing field。 解决方法： class Person: Named() { override var name: String? get() = super.name set(value) { super.name = \"Mr $value\" } } 最小值 ~ MinIntfun printInt(n: Int) { println(n) } printInt(-2_147_483_648.inc()) 这会打印出什么？ a) -2147483647 b) -2147483649 c) 2147483647 d) 以上答案都不对 上一题的答案：d sc.set 有一个自定义 getter，编译器没法判断这个 getter 返回的是否是同一个对象，所以无法进行智能转换（smart cast）。 解决方法：这时候别声明只有 getter 的属性，声明有 backing field 的属性就好。或者像这样： val set = sc.set if(set is MutableSet) set.add(4) 人类衰退之后 ~ Population To Marsclass Population(var cities: Map&lt;String, Int>) { val 帝都 by cities val 魔都 by cities val 妖都 by cities } val population = Population(mapOf( \"帝都\" to 864_816, \"魔都\" to 413_782, \"妖都\" to 43_005 )) // 许多年过去了，地球毁灭了，只有少数幸存者抵达了火星（大吉大利今晚吃鸡）！ population.cities = emptyMap() with(population) { println(\"$帝都; $魔都; $妖都\") } 这会打印出什么？ a) 0; 0; 0 b) 864816; 413782; 43005 c) NullPointerException d) NoSuchElementException 上一题的答案：d 破代码没法通过编译。实际的求值顺序是：-(2_147_483_648.inc())，这TM是个 Long。这个一元操作符的优先级比普通方法调用低。 反物质 ~ AntiMatteroperator fun Nothing?.not() = Unit operator fun Unit.not() = null val foo = null println(!!!!!foo!!!!) 这会打印出什么？ a) null b) kotlin.Unit c) KotlinNullPointerException d) 这破代码根本没法通过编译 上一题的答案：b 用于委托代理的那个 Map 被保存在了一个 private final 的 field 里面，正常手段没法赋新值。 本题的答案：d null 的类型是 Nothing?（而且是这个类型的唯一值）。***!! 这个非空断言比 not() 的优先级要高，所以 foo!!!! 的类型是 Nothing，Nothing 是所有类型的子类型，所以编译器没法判断该调用哪个扩展方法。 总结这些辣鸡代码，别学。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"最近观察到的Kotlin的华点","slug":"huadian","date":"2017-10-18T15:44:52.000Z","updated":"2020-05-26T15:26:05.725Z","comments":true,"path":"2017/10/18/huadian/","link":"","permalink":"https://aisia.moe/2017/10/18/huadian/","excerpt":"不定期更新。","text":"不定期更新。以下内容使用的 Kotlin 版本为 1.1.51。 2017-10-18封面换成了艾拉酱，真好啊~真好啊~ ヾ(≧▽≦*)o 一件Java能做但是Kotlin不能做的事情在Codewars上刷题的时候发现的，本来这网站上面的Kotlin题就少，而且还有大把大把不会写，能玩的就更少了。这种题目不调戏一下冰酱就可惜了。具体是这道题。 这题要求你代码中不能出现fun、{以及}的情况下让定义一个拼接两个字符串的函数。这个要求等同于禁止你使用lambda表达式、函数声明，并且限制你仅用一个表达式完成任务（根据我的理解，是这样的没错）。 那我们来找找有什么现成的有invoke()方法的东西吧。首先想到了反射，但是反射那家伙需要传入接收者作为第一个参数，rua~。既然反射不行，啊，有个更好的东西，看起来完美符合需求。 马上写好代码准备吊打冰酱，然后就是喜闻乐见的辣鸡Kotlin时间，代码如下： val concatString = MethodHandles.lookup().findVirtual(String::class.java, \"concat\", MethodType.methodType(String::class.java, String::class.java)) val str = concatString(\"我永远喜欢\", \"珂朵莉\") as String // Boom！ 然后在Java里写下同样的代码进行测试，嗯，果然是辣鸡Kotlin。 炸裂原因是Kotlin不支持所谓的签名多态性（signature polymorphism），从编译出来的字节码可以看得出来： // kotlin INVOKEVIRTUAL java/lang/invoke/MethodHandle.invoke ([Ljava/lang/Object;)Ljava/lang/Object; // java INVOKEVIRTUAL java/lang/invoke/MethodHandle.invoke (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; 运行时要成功调用该方法的话，字节码中的参数与返回值类型必须与运行时MethodHandle所代表的实际的方法类型一致，否则会抛出WrongMethodTypeException。上面那段Kotlin代码运行时就会抛出这个异常，异常信息为cannot convert MethodHandle(String,String)String to (Object[])Object，正好与上面的字节码相对应。嗯就是这样。 Kotlin编译器现在还不能支持多态签名，而且这将持续很长一段时间（官方人员说了，1.2版本也不会实现这项功能）。 解决方法：升级Kotlin版本至1.3.20并加上编译器参数-XXLanguage:+PolymorphicSignature。 2017-10-10最近翻看以前写的旧代码，发现由于Kotlin及其IDEA插件版本更新了，静态检查工具功能增强，检出了一些令人窒息的代码（例如 Check for instance is always ‘true’）。然后我在查看这些乱七八糟的代码时发现了两个问题。 编译器生成了无用的字节码(?)把问题单独抽出来就像是这样： class A&lt;T : Any>(val data: T) class B(val string: String) fun test(a: A&lt;*>) { a.data as B // 注意这行对应的字节码 a.data.string // 这里 a.data 有提示 Smart cast to B } 然后看看编译出的字节码里面都有啥： // 以上省略 L1 LINENUMBER 5 L1 ALOAD 0 INVOKEVIRTUAL A.getData ()Ljava/lang/Object; // a.data DUP IFNONNULL L2 // &lt;============================ 这里进行判空 NEW kotlin/TypeCastException DUP LDC \"null cannot be cast to non-null type B\" INVOKESPECIAL kotlin/TypeCastException.&lt;init> (Ljava/lang/String;)V ATHROW L2 CHECKCAST B // &lt;============================ 不为空则进行类型转换 POP L3 // 以下省略 大致内容就是判断 a.data 是否为 null，如果是 null 就 throw TypeCastException(&quot;null cannot be cast to non-null type B&quot;)。然而根据 A 这个类的定义，其属性 data 必定是非空的。对非空属性进行 null check 岂不是多余？难道说编译器太傻，在分析这种操作时不知道 a.data 是非空的？ 解决方法：加个问号，如下所示： fun test(a: A&lt;*>) { a.data as B? // 加了个问号，变成了B? a.data.string // 注意这里 a.data 同样有提示 Smart cast to B } 这时候字节码就是这样的： // 以上省略 L1 LINENUMBER 5 L1 ALOAD 0 INVOKEVIRTUAL A.getData ()Ljava/lang/Object; // a.data CHECKCAST B // &lt;============================ 直接进行类型转换 POP L2 // 以下省略 这回就没有多余的判空处理了。但是注意代码中的 a.data.string，IDE提示 a.data 能够 Smart cast to B。咦编译器还是蛮聪明的呢！ 检查工具提示可对代码进行负优化(?)这个问题单独抽出来就像这样： class A class B { fun getA(): A = TODO() } fun test(some: Any?): A { return if (some is B) some.getA() else A() // 注意这行 } 然后你可以看到，IDE提示你可以 Replace ‘if’ expression with elvis experssion。如果你让IDE帮你优化，就变成了这样： fun test(some: Any?): A { return (some as? B)?.getA() ?: A() // WTF??? } 不知道你们是怎么想的，至少对于我来说可读性下降，而且很明显生成的字节码也变复杂了。明显是负优化，吧？ 解决方法：@Suppress(&quot;IfThenToElvis&quot;) 很久以前的冷饭把以前想过的东西拿出来凑字数。 Kotlin数组类型在Java，你可以这样写： public static void some(Object o) { if (o instanceof String[]) { System.out.println(\"this is String[]\"); } } 但是辣鸡Kotlin不行： fun some(any: Any?) { // 编译错误：Cannot check for instance of erased type: Array&lt;String> // ↓ if (any is Array&lt;String>) { println(\"this is String[]\") } } 你需要这样写： if (any is Array&lt;*> &amp;&amp; any.isArrayOf&lt;String>()) { println(\"this is String[]\") } 这是一个Kotlin无法写出实现类的Java接口public interface IntMap&lt;T> extends java.util.Map&lt;Integer, T> { T get(Integer key); T get(int key); }","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"关于此博客，以及博主，还有那些七七八八的事","slug":"about","date":"2017-04-27T03:32:52.000Z","updated":"2020-05-26T15:26:05.725Z","comments":true,"path":"2017/04/27/about/","link":"","permalink":"https://aisia.moe/2017/04/27/about/","excerpt":"一些碎碎念讲道理，我搭好 Hexo 才发现，如果使用 Jekyll 的话，只要将页面源码 Push 到 Github 上，是可以自动生成页面并发布的。","text":"一些碎碎念讲道理，我搭好 Hexo 才发现，如果使用 Jekyll 的话，只要将页面源码 Push 到 Github 上，是可以自动生成页面并发布的。全栽在 CI 上了（用的是 AppVeyor），首先是太久没用 Git，忘记子模块怎么用了，坑了好久。之后是 Git 一些操作重定向 stdout 到 stderr 导致 PowerShell ISE 报错，于是 CI 那边就挂掉了。然后是 Gitlab 的神奇 Bug，一次 Push 让 CI 那边连续 Build 了 5 次…… 于是 3 天的人生就浪费掉了。其实如果不搞持续集成的话就没那么多事。虽然说结果都一样，但是总感觉有那么点不爽，我特么怎么就选了 Hexo 呢。越想越恼火。不排除以后换成 Jekyll 的可能性，不过主题一定是要换的。 2017年5月29日，主题由 indigo 变更为 material。 2018年1月20日，域名已部署，HTTPS已部署。 关于博客 ~ The History of RenTouemmm… 关于我唔，感觉没啥好说的呢。 人头会社三元老之一，精神病院第13号床位所有者。 不务正业的辣鸡。 噫，就这样。 其他这个博客是有评论系统的，看不到的话那应该是被墙了，请使用科学姿势查看。（或者等我换成其他系统（懒癌不允许我这么做（不！","raw":null,"content":null,"categories":[],"tags":[{"name":"Others","slug":"Others","permalink":"https://aisia.moe/tags/Others/"}]}]}