{"meta":{"title":"萌夜雀的人头会社","subtitle":null,"description":"要和谐, 要有爱","author":"Dexlind","url":"https://aisia.moe"},"pages":[{"title":"about","date":"2017-05-28T18:28:59.000Z","updated":"2018-07-27T03:21:48.178Z","comments":true,"path":"about/index.html","permalink":"https://aisia.moe/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"categories","date":"2017-04-18T17:12:52.000Z","updated":"2018-07-27T03:21:48.178Z","comments":true,"path":"categories/index.html","permalink":"https://aisia.moe/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2018-07-27T03:21:48.193Z","updated":"2018-07-27T03:21:48.193Z","comments":true,"path":"tags/index.html","permalink":"https://aisia.moe/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"timeline","date":"2018-07-27T03:21:48.193Z","updated":"2018-07-27T03:21:48.193Z","comments":true,"path":"timeline/index.html","permalink":"https://aisia.moe/timeline/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Kotlin 1.3 前瞻之 Inline Class","slug":"inline-class","date":"2018-07-03T14:14:08.000Z","updated":"2018-07-27T03:21:48.178Z","comments":true,"path":"2018/07/03/inline-class/","link":"","permalink":"https://aisia.moe/2018/07/03/inline-class/","excerpt":"\n啊啦啦，垃圾 Kotlin，你又偷拿人家东西了！","text":"啊啦啦，垃圾 Kotlin，你又偷拿人家东西了！ 这几年各路语言的发展就是把 Haskell 吃剩下的再拿出来吃一遍，Kotlin 也不例外（进入高级引战模式）。如果你精通 Haskell 或者 Scala，那太棒了，你不需要浪费时间阅读这篇辣鸡水文，请点击右上角的关闭按钮。 虽然说本文讲的是 Kotlin 1.3 版本的新特性，但是理论上 1.2.50 也能用（处于开发阶段，有大量 Bug，不建议日常使用）。如果想要体验这个实验性特性需要添加编译器参数 -XXLanguage:+InlineClasses。本文使用的 Kotlin 版本为 1.2.60-eap-7。 由于 Inline Class 这个特性尚未正式实装，实际情况可能会有所变动，届时本文可能会有部分过时内容。 因为本文只是一篇舅舅文，所以不会详细介绍各个细节，只抓重点讲。并且由于我太鶸，也许本文通篇错漏百出也说不定。 前言JB他们在17年4月份的时候，做了一份调查问卷，Kotlin Future Features Survey，内容是选出最希望实装的语言特性（20选3），后来得出的调查结果是 Inline Class 排第五。现在这个功能得以实装也算是众望所归了。 不过吃惊的是我没想到JB那帮人做得那么快，我还以为这特性要等到 Kotlin 2.0 才能摸出来。 什么是 Inline ClassInline Class，翻译成中文就是「内联类」。我们知道 Kotlin 有内联函数，可以消除函数调用的开销。那么内联类，则是可以消除创建对象的开销。 看起来很棒，是吧。如果不懂的话请往下看。 inline class Duck(val name: String) 以上代码就声明了一个最简单的内联类。 内联类必须有一个主构造函数，并且在主构造函数里必须有且只有一个 val 属性，除此之外，不能再拥有其他的字段。 可以给内联类添加泛型、次级构造函数、方法以及没有 backing field 的属性，还可以实现接口、继承其他类： inline class Duck(val name: String) { constructor() : this(\"wuyikoei\") fun talk(): Nothing = throw UnsupportedOperationException() var i: Int get() = 1551 set(value) = println(value) companion object { /* ... */ } } 使用起来就根普通的类一样： fun test() { val duck = Duck(\"ywwuyi\") println(duck.name) println(duck.i) duck.i = 6655 duck.talk() } 聪明的同学可能已经猜到了内联类的所谓「消除创建对象的开销」指的是什么。在经过编译器的处理后，以上代码就变成了下面这样： fun test() { val duck = \"ywwuyi\" println(duck) // 输出 1551 println(Duck$Erased.getI(duck)) Duck$Erased.setI(duck, 6655) Duck$Erased.talk(duck); } 整个类实例被“内联”掉了，只剩下它里面包裹的值。对成员方法的调用变成了对静态函数的调用（类似于扩展函数）。 也就是说，Inline class 可以给某个类型的值创建一个装箱类（就像上面的 Duck 包装了一个 Int 类型的值），并且这个装箱类能够被内联，“箱子”不复存在，只剩下那个被装箱的值。换句话说，内联类看起来就像是一个“零开销”的 wrapper。 用途举例垃圾没用.jpg、进入胡说八道模式.jpg。 严格的类型别名我们知道 Kotlin 有类型别名，能给某个类型取一个另外的名字。例如我们想用类型别名弄一个长度单位「米」： typealias Meter = Double 但是 Meter 和 Double 其实是同一个类型，你并不能阻止将一个 Meter 赋值给一个 Double 类型的变量，你也并不能阻止两者相加。 val a: Meter = getMeter() val b: Double = getMeter() val c = a + b 但是如果这里使用内联类就不一样了： inline class Meter(val value: Double) { operator fun plus(m: Meter) = Meter(this.value + m.value) } fun test2() { var a = Meter(1.0) val b = Meter(2.0) val c = a + b // ok, c的类型为Meter a = 3.0 // 编译错误：type mismatch } 由于 Meter 是内联类，所以上面的代码实际上并不会创建 Meter 类的实例，在运行时只是在操纵 double，但是却保证了井水不犯河水，Meter 和 Double 各不相干。你甚至可以用内联类定义一套计量单位。 任何你想得到的包装类（wrapper）“无痛”创建任何 wrapper，不用担心开销。 例如嫌原来的方法名字太丑，那就包一层： interface Aa { fun a1() fun a2() } inline class Fuck(val a: Aa) { inline fun fuck1() = a.a1() inline fun fuck2() = a.a2() } 例如属性代理： inline class InlinedDelegate&lt;out T>(val value: T): ReadOnlyProperty&lt;Any?, T> { override inline operator fun getValue(thisRef: Any?, property: KProperty&lt;*>): T { // do everything you like return value } } class Test { val some: String by InlinedDelegate(\"just for test\") } etc. 无符号整型无符号整型（unsigned integer）也是 Kotlin Future Features Survey 里面出现过的 feature（第12号），由于内联类的实装，无符号整型因此可以很好地实现，而不会有过大的开销。 inline class ULong(private val data: Long) : Comparable&lt;ULong> { /* balabala */ } fun test() { val a = 2_147_483_648.toUInt() // a 的类型为 UInt val b = 1_000_000_000 val c = a + b // c 的类型为 UInt println(c) // 3147483648 } 同时还新增了无符号整形字面量来简化声明。 // 结尾的u意味着这是一个无符号整形 val uintMask = 0xFFFF_FFFFu // UInt val ulongUpperPartMask = 0xFFFF_FFFF_0000_0000uL // ULong 不过目前该功能尚未完成，如果JB的 Kotlin 团队做得快的话，无符号整型就能在 Kotlin 1.3 里用上了。 Try/Result Monad（伪）函数式风格的错误处理，世面上已经有太多类似的玩意了（Arrow 的 Try，隔壁 Scala 的 Try[T]，河对面 Haskell 的 Exceptional e t）。 所以 Kotlin 官方团队打算把类似的东西塞进标准库里，预计将在 Kotlin 1.3 版本实装。 // 这个纯粹是夏姬八写了 inline class SuccessOrFailure&lt;T, E: Exception>(val value: T | E) // 代码仅供参考，请以实物为准 不过具体的情况还很微妙，Roman 大爷说并不打算做得和 Arrow 的那个一样，而是做成一个功能十分有限的玩意，连 flatMap 都要你自己写出来。没有 flatMap 的 Monad 还能叫做 Monad 么？ 目前来看，只是用于精简协程中的 Continuation 接口用。 更多的用处由于篇幅关系省略不写，摸了~ 编译器的魔术在你声明一个内联类的时候，编译器会为你生成两个类，一个类是内联类本体，另一个是为内联进行支持的辅助类。例如： inline class Dog(val name: String) : Cloneable { constructor() : this(\"quin\") fun talk() = println(\"rua~\") val next: Int get() = 22 } 经过编译器之手，就变成了如下这样（细节已省略）： inline class Dog(val name: String) : Cloneable { constructor() : this(\"quin\") fun talk() = Dog$Erased.talk(name) val next: Int get() = Dog$Erased.getNext(name) fun unbox() = name } public static final class Dog$Erased { public static final void talk(String $this) { System.out.println(\"rua~\"); } public static final int getNext(String $this) { return 22; } public static final Dog box(String v) { return new Dog(v); } } 对于用到内联类的地方，例如 fun test1(dog: Dog) { dog.next test2(dog, dog, dog) } fun &lt;T> test2(dog1: Dog?, dog2: Cloneable, dog3: T) { dog1!!.talk() (dog3 as Dog).name } 内联后变成这样（细节已省略）： fun test1(dog: String) { Dog$Erased.getNext(dog) test2(dog, Dog$Erased.box(dog), Dog$Erased.box(dog)) } fun &lt;T> test2(dog1: String?, dog2: Cloneable, dog3: T) { Dog$Erased.getNext(dog1!!) (dog3 as Dog).unbox() } 从上面可以看出，并不是所有的用处都能内联掉，在需要的时候仍然会将其装箱。 更多的细节由于篇幅关系省略不写，摸了~ 内联类的一些限制 内联类的主构造函数里的属性必须是 val，而不能是 var。 内联类必须在顶层声明，而不能声明为嵌套类。 内联类类型的 vararg 被禁用，例如 fun test(vararg dogs: Dog) {}。 以上这三点限制可能在将来能够解除。 其他的限制由于篇幅关系省略不写，摸了~ 未来可能支持内联枚举（inline enum），就像这样（随便找了一段 Java 代码用 Kotlin 重写）： inline enum NavigationMode(val value: Int) { NAVIGATION_MODE_STANDARD(0), NAVIGATION_MODE_LIST(1), NAVIGATION_MODE_TABS(2); } abstract val navigationMode: NavigationMode Kotlin 团队：摸了~ 补充说明我知道你们想要这个 inline class Reified&lt;reified T>(val some: T) 但是实际可能和你们想象的不一样 fun foo(a: Reified&lt;Int>, b: Reified&lt;String>) // 编译后 fun foo(a: Int, b: String) 已经在做了.jpg 更多的补充说明由于摸了的关系省略不写~","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"Kotlin Contracts DSL","slug":"kotlin-contracts-dsl","date":"2018-03-25T08:31:53.000Z","updated":"2018-07-27T03:21:48.178Z","comments":true,"path":"2018/03/25/kotlin-contracts-dsl/","link":"","permalink":"https://aisia.moe/2018/03/25/kotlin-contracts-dsl/","excerpt":"从 Kotlin 1.2 版本开始，如果你查看 apply、let 等函数的源码，你会发现比 1.1 版本多了几行不明觉厉的代码","text":"从 Kotlin 1.2 版本开始，如果你查看 apply、let 等函数的源码，你会发现比 1.1 版本多了几行不明觉厉的代码： public inline fun &lt;T, R> T.let(block: (T) -> R): R { // kotlin 1.2 加了下面三行代码 contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } // kotlin 1.2 加了上面三行代码 return block(this) } 很好，接下来就讲讲那几行多出来的代码到底有什么用。本文使用的 Kotlin 版本为 1.2.31。 简单的需求假设我们有这样一段代码： fun some() { var text: String? = getText() if(text.isNullOrEmpty()) { text = \"我永远喜欢燕结芽\" } println(text.length) // error, cannot smart cast to String } 稍有常识的人都会看出，如果我们的代码继续执行，这个可空类型的 text 变量，在最后一行那里不可能为 null。 但是编译器傻乎乎地向你丢出了一个编译错误：Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String? 原因在于编译器不能深入分析每个函数（在这个例子中是 isNullOrEmpty）的数据流，无法得知「test 不为空」的事实，也就无法进行 Smart Cast 了。 所以如果要享受到 Smart Cast 的便利的话，可以手动将 isNullOrEmpty 内联展开： if(text == null || text.isEmpty()) { text = \"我永远喜欢燕结芽\" } println(text.length) // ok, smart cast to String 但是这很麻烦，而且还不好看。为了解决这个问题，于是就有了 Contracts DSL。 Contracts DSLContracts DSL 可以为编译器提供关于函数行为的附加信息，帮助编译器分析函数的实际运行情况，从而让更多正确的代码能通过编译（例如上面的例子）。 我们可以查看一下 isNullOrEmpty 的源码： public inline fun CharSequence?.isNullOrEmpty(): Boolean { contract { returns(false) implies (this@isNullOrEmpty != null) } return this == null || this.length == 0 } 这里简单解释一下 contract 代码块里面的那行代码，表示「如果返回值为false，那么this（函数的接收者）不为null」。 因为这个东西目前还是个实验性特性，处于内部评估的状态，尚未对外公开发布，所以是默认关闭的。如果启用了该特性，那么编译器就能解析获取 Contracts DSL 所表达的信息，用于数据流分析。 为了开启这个特性，我们需要给编译器传入提供额外的编译参数：-Xeffect-system 和 -Xread-deserialized-contracts。然后下面的代码就能够正常通过编译： fun test() { val str: String? run { // captured value initialization is forbidden due to possible reassignment str = \"でないと、私のすごいとこ 見せられないじゃん\" } println(str) // str not initialized val notNull1: Any? = str requireNotNull(notNull1) println(notNull1.hashCode()) // cannot smart cast to Any val notNull2: String? = str if (!notNull2.isNullOrEmpty()) { println(notNull2.length) // cannot smart cast to String } } 虽然在 IDEA 里这些代码仍然会被标上红色下划线表示有错，但是加上编译器参数后的确能通过编译，也能够正常运行。 就拿上面例子的 run 函数说起，看看源码： public inline fun &lt;R> run(block: () -> R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block() } 编译器可以知道「传入的 lambda 会立即在“原地”执行有且仅有一次」，那么 str 一定会被初始化，而且不会被重新赋值。编译通过！ 现在 Contracts DSL 位于 kotlin.internal.contracts 这个包内，是 internal 的，一般用户还无法直接拿来写自己的 contract，这个特性预计将在 Kotlin 1.3 版本实装。 试着编写自己的 contract既然这玩意是 internal 的，那我把它改成 public 总能用了吧。 于是手工编译了一份魔改过的 stdlib，使用后发现IDEA也好了，能正确提示报错了。（貌似还需要加上编译器参数 -Xallow-kotlin-package（允许使用 kotlin 开头的包名）） 然后随便写了一下，看起来就像这个截图这样： 实际体验的话，那个 implies() 目前只支持几个基本的模式（空检验、类型检验等，以后应该会增加新的模式），IDEA 的报错也是时好时坏（一切以编译结果为准）。 而且我尝试写了如下的 contract： inline fun &lt;reified T> Any?.isInstanceOf(): Boolean { contract { returns(true) implies (this@isInstanceOf is T) } return this is T } 也不知道是我太鶸还是 Kotlin 太辣鸡，上面这个 contract 看起来不起作用。 嘛反正是处于实验阶段的特性，也不强求什么，至少比没有强（ 然后我发现了更简单的方法，并不需要魔改Kotlin标准库，只需要把标准库里面的 Contract Dsl 的源码复制一份到项目里，也能起到相同的作用。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"为什么我不用 Gradle Kotlin DSL","slug":"why-not-gradle-kts-dsl","date":"2018-02-26T11:11:00.000Z","updated":"2018-07-27T03:21:48.178Z","comments":true,"path":"2018/02/26/why-not-gradle-kts-dsl/","link":"","permalink":"https://aisia.moe/2018/02/26/why-not-gradle-kts-dsl/","excerpt":"一图流。\nGroovy：优雅，简洁，美观！\n\nKotlin DSL：你看看这何等鬼畜的用法！\n","text":"一图流。 Groovy：优雅，简洁，美观！ Kotlin DSL：你看看这何等鬼畜的用法！","raw":null,"content":null,"categories":[],"tags":[{"name":"Others","slug":"Others","permalink":"https://aisia.moe/tags/Others/"}]},{"title":"Kotlin协程 - 先入个门吧","slug":"kotlin-coroutine-kepa","date":"2018-02-08T15:16:58.000Z","updated":"2018-07-27T03:21:48.178Z","comments":true,"path":"2018/02/08/kotlin-coroutine-kepa/","link":"","permalink":"https://aisia.moe/2018/02/08/kotlin-coroutine-kepa/","excerpt":"你们要的协程文，嗯。封面图id：66548341。","text":"你们要的协程文，嗯。封面图id：66548341。 因为是入门嘛，所以本文保证不会出现任何与 kotlinx.coroutines 相关的内容。 前言话说为什么我要在已经有辣么多篇优秀的协程文的情况下再水一篇呢？因为我太鶸了，bennyhuo的那篇文章根本看不懂，一开始上来就抛出一堆难以理解的专业名词，比如线程、Lua、CoroutineContext 等等，再加上那一堆根本看不懂的 Lua 代码以及 UML 类图，萌新一脸懵逼，直接被劝退，根本不留情面。所以我决定自己写一篇（自己能看懂的），就酱。 本水文不保证其他读者能看懂！（逃 基本操作 Kotlin 1.1 的关键新特性是协程，它带来了 future/await、 yield 以及类似的编程模式的支持。Kotlin 的设计中的关键特性是协程执行的实现是语言库的一部分，而不是语言的一部分，所以你不必绑定任何特定的编程范式或并发库。 为了不让内容太过单薄，抄了一段Kotlin中文网上的翻译（逃 suspend 关键字Kotlin在1.1版本新增加了 suspend 关键字，可以用来修饰函数或者 lambda 表达式的类型： suspend fun suspendFunction(): String { …… } // ↑ 你看这辣鸡代码高亮 ↓ val suspendLambda: suspend () -> Unit = { …… } // 你需要显式写出这个suspend lambda的类型，不然其类型会推导成普通的lambda而不是suspend lambda 然后你得到了一个 suspend 函数和 suspend lambda。被标记为 suspend 的函数只能在 suspend 函数或 suspend lambda 中被调用。 Kotlin 1.2.30 版本提供了一个更简单的方法来声明无参数的 suspend lambda，不用显式写出类型了： // Kotlin 1.2.30 以后才能这样写 val suspendLambda = suspend { \"Hello world!\" } // suspendLambda 的类型将被自动推导为 suspend () -> String PS：Kotlin 将在下次大更新（可能是 1.3）时让 suspend 关键字能够修饰 lambda 表达式，使之称为一个 suspend lambda，就像上面代码里的那样。但是 Kotlin 团队的那帮人根本就没有耐心，决定在 Kotlin 1.2.30 版本（小更新）就引入这个特性，但是又不想引入 breaking change，于是折中了一下，往标准库里加入了一个辅助函数，等到大版本更新正式加入这个功能时再移除这个函数： @kotlin.internal.InlineOnly public inline fun &lt;R> suspend(noinline block: suspend () -> R): suspend () -> R = block 因为计划中这是要成为一个修饰符的，所以编译器会禁止那些看起来不像是修饰符的用法（non-modifier-like usages）： suspend { return@suspend \"1551\" } // 不允许 return@suspend，编译错误！ suspend poi@ { return@poi \"1551\" } // 这是好的！ ::suspend // 禁止函数引用，编译错误！ 因为是个折衷的版本嘛，所以目前只适用于声明无参 suspend lambda，等下个大版本真正成为一个 lambda 的修饰符的时候，就能适用于有参数的 lambda 了。 创建和启动协程创建并启动一个协程十分简单，你只需要两件宝具：一个 suspend lambda，以及一个 Continuation： import kotlin.coroutines.experimental.* val suspendLambda: suspend () -> String = { \"Hello world!\" } val completion = object : Continuation&lt;String> { override val context get() = EmptyCoroutineContext override fun resume(value: String) { println(value) } override fun resumeWithException(exception: Throwable): Unit = throw exception } 使用 Kotlin 标准库中的 createCoroutine 函数来创建协程： val coroutine: Continuation&lt;Unit> = suspendLambda.createCoroutine(completion) 然后调用 resume 方法启动这个协程： coroutine.resume(Unit) // 打印出 Hello world! 或者使用标准库里的 startCoroutine 函数来创建并立即启动一个协程： suspendLambda.startCoroutine(completion) // 打印出 Hello world! 很简单。另外对于有带接收者的 suspend lambda，有与之相对应的库函数。 fun &lt;T> (suspend () -> T).createCoroutine(completion: Continuation&lt;T>): Continuation&lt;Unit> fun &lt;R, T> (suspend R.() -> T).createCoroutine(receiver: R, completion: Continuation&lt;T>): Continuation&lt;Unit> fun &lt;T> (suspend () -> T).startCoroutine(completion: Continuation&lt;T>): Unit fun &lt;R, T> (suspend R.() -> T).startCoroutine(receiver: R, completion: Continuation&lt;T>): Unit 协程挂起和恢复执行想要暂停一个协程的执行，可以使用标准库里面的 suspendCoroutine 函数： val suspendLambda: suspend () -> Unit = { println(\"before suspend\") suspendCoroutine&lt;Unit> { } println(\"after suspend\") } suspendLambda.startCoroutine(object : Continuation&lt;Any> { …… }) // 只输出 before suspend 如果需要恢复协程，例如等待3秒后继续执行： val suspendLambda: suspend () -> Unit = { println(\"before suspend\") val int: Int = suspendCoroutine { c -> Thread.sleep(3000) c.resume(1551) } println(\"after suspend, resume with $int\") } suspendLambda.startCoroutine(object : Continuation&lt;Any> { …… }) // 输出（两行输出间隔3秒）： // before suspend // after suspend, resume with 1551 suspendCoroutine 函数的签名如下： inline suspend fun &lt;T> suspendCoroutine(crossinline block: (Continuation&lt;T>) -> Unit): T 如果你知道这上面的各段代码里面究竟发生了什么，那太棒了，你不需要浪费时间阅读这篇辣鸡水文，请点击右上角的关闭按钮。 概念摘出：ContinuationContinuation（续延）究竟是一个什么概念？一般来讲，Continuation 表示的是「剩余的计算」的概念，换句话说就是「接下来要执行的代码」。举个例子来说，假设我们有这样一段代码： println(1551.toString().length) 我们知道这段代码会先执行 1551.toString()，然后再执行 _.length，最后将结果打印出来 println(_)。 当 1551.toString() 求值之后，需要将其结果传递至 println(_.length)。我们可以将 println(_.length) 写成一个 lambda 表达式：{ s: String -&gt; println(s.length) }。这个 lambda 表达式（或者说是闭包）表示的就是 1551.toString() 的 Continuation，即「剩余的计算」。 这样，我们就可以通过把 1551.toString() 应用到这个lambda来重新构建原来的形式：{ s: String -&gt; println(s.length) }.invoke(1551.toString())。换句话说，执行该 lambda 表达式的 invoke 方法以执行「剩余的计算」。 那么 1551.toString().length 的 Continuation 又是什么呢？很简单，是 { i: Int -&gt; println(i) }。 以上讲的就是 Continuation 的一般概念。Kotlin 里面的 Continuation 长什么样子？大概像这样： interface Continuation&lt;in T> { val context: CoroutineContext fun resume(value: T) fun resumeWithException(exception: Throwable) } 这不就跟上面的 lambd 表达式很像嘛，Continuation接口的 resume 就相当与 lambda 表达式的 invoke ，所以当你拿到一个 Continuation 时，resume 方法即是「剩余的计算」的入口。 上文基本操作的例子中，createCoroutine 函数接受一个 Contiuation 参数 completion，表示「协程执行完之后要执行的代码」。而 createCoroutine 的接收者 suspendLambda 则是协程的主要部分。createCoroutine 函数把这两个东西搓成一个表示「整个协程所有需要执行的代码」的 Contiuation，称为初始 Continuation（initial continuation）。当 suspendLambda 执行完毕后，将其结果传至 completion 的 resume 方法；若 suspendLambda 的执行过程中抛出了异常，则走 completion 的 resumeWithException 方法。 再看上文 suspendCoroutine 函数的例子： val suspendLambda: suspend () -> Unit = { println(\"before suspend\") val int: Int = suspendCoroutine { c -> Thread.sleep(3000) c.resume(1551) } println(\"after suspend, resume with $int\") } suspendCoroutine 函数接收一个lambda表达式作为参数，这个 lambda 的 Continuation 参数即是表示「协程挂起后剩下的还没执行的代码」。在这个例子中，表示的是 { i: Int -&gt; val int = i; println(&quot;after suspend, resume with $int&quot;) }。调用resume方法将这个协程继续执行下去，suspendCoroutine 的返回值即是通过 resume 方法传入的值（本例中为1551），于是变量int得到值1551。 超简单~！ 编译器的魔术 「别逗我了。那种东西怎么会是魔法！」 那么 Kotlin 的协程是怎么实现的呢？ 协程完全通过编译技术实现（不需要来自 VM 或 OS 端的支持），挂起通过代码来生效。（本句话抄自 Kotlin 中文网） CPS 转换 「CPST 就是 Gödel–Gentzen 变换的 Curry–Howard 像而已，这有什么难理解的？」 在编译时，suspend 函数会被编译器加上一个 Continuation 参数： // 编译前 suspend fun &lt;T, U> suspendFunction(arg: U): T { …… } // 编译后 fun &lt;T, U> suspendFunction(arg: U, c: Continuation&lt;in String>): Any? { …… } 这叫做 CPS 转换（Continuation-Passing-Style transformation）。 可以认为每个 suspend 函数都有一个隐式参数，每个 suspend 函数都能通过这个参数拿到一个 Continuation，代表着「该函数之后将要执行的代码」。 PS：suspendFunction 经过CPS转换后，返回值的那个 Any? 其实是个类似于 union types（并集类型）的玩意。它其实是 T | COROUTINE_SUSPENDED，表示返回值可能为 T 类型的值，也可能是个 COROUTINE_SUSPENDED。但是辣鸡 Kotlin 没有 union types，所以只能写成 Any?，使用的时候再做类型强转。（看看人家 Scala 和 Ceylon ，做得多好） PPS：如果你喜欢翻看源码，你会发现在 Kotlin 标准库的协程部分以及 kotlinx.coroutines 里面能经常见到这种用 Any? 表示的 union types。 状态机我们知道 Continuation 就相当于一个闭包，经过 CPS 转换，每次调用 suspend 函数都需要传一个 Continuation 进去。为了避免创建过多的闭包和匿名类，Kotlin 选择使用状态机（state machines）来实现 Continuation。 由于懒，我直接把官方的非正式文档里面的例子抄了过来： suspend 函数会被编译成一个状态机，例如一个 suspend 函数里有以下代码： val a = a() val y = suspendFunction(foo(a)) // 挂起点 1 b() val z = suspendFunction(bar(a, y)) // 挂起点 2 c(z) 其中的2个 suspend 函数调用点（简称挂起点，suspension point）将这段代码分成3个状态： 状态0：第一个挂起点之前（初始状态） val a = a() foo(a) 状态1：第一个挂起点之后，至第二个挂起点之前 val y = _ b() bar(a, y) 状态2：第二个挂起点之后 val z = _ c(z) 代码会被编译成一个匿名类，它具有一个实现状态机的方法，一个保存状态机当前状态的字段，以及各个状态的局部变量的字段，看起来像这样： // 伪代码，简化模型，实际情况会比这个要复杂一些 class 状态机匿名类 extends CoroutineImpl implements Continuation&lt;Object> { // 这个int用来保存状态机当前的状态 int label = 0 // 用来保存suspend方法中的局部变量 A a = null Y y = null // 实现状态机的方法 void resume(Object data) { if (label == 0) goto L0 if (label == 1) goto L1 if (label == 2) goto L2 else throw IllegalStateException() // 英文不翻译了，懒~ L0: // data is expected to be `null` at this invocation a = a() label = 1 data = suspendFunction(foo(a), this) // 'this' is passed as a continuation if (data == COROUTINE_SUSPENDED) return // return if suspendFunction had suspended execution L1: // external code has resumed this coroutine passing the result of suspendFunction() as data y = (Y) data b() label = 2 data = suspendFunction(bar(a, y), this) // 'this' is passed as a continuation if (data == COROUTINE_SUSPENDED) return // return if suspendFunction had suspended execution L2: // external code has resumed this coroutine passing the result of suspendFunction() as data Z z = (Z) data c(z) label = -1 // No more steps are allowed return } } 各位读者自行体会，我懒得解释了。 我们可以看到每次调用 suspendFunction 时，传进去的 Continuation 都是同一个对象，即状态机本身；并且通过 label 来控制状态和代码跳转，使其符合「剩下的计算」的语义。 PS：并不是所有的 suspend 函数都会编译成一个状态机，存在一种尾调用优化（tail call optimization）的机制。举个例子： suspend fun f1() { println(\"do something before calling f2\") f2() // &lt;==这里 } suspend fun f2() { …… } f1函数内部唯一的一个 suspend 调用是在函数尾部的位置（即 tail suspension invocation），这时不会编译成状态机，而是这样： fun f1(c: Continuation&lt;in Unit>): Any? { println(\"do something before calling f2\") f2(c) } fun f2(c: Continuation&lt;in Unit>): Any? { …… } 即尾调用优化。（亲爱的读者可以思考一下为什么可以这么做） PPS：在 Kotlin 1.2.30 之前的版本中（不包括 1.2.30），上面的代码并不会发生尾调用优化，你需要这样： suspend fun f1() { println(\"do something before calling f2\") return f2() // 这里必须写 return } suspend fun f2() { …… } 显式地写成 return f2() 才能有尾调用优化。 伪・Call/CC前面提到，每个 suspend 函数都有一个隐式的 Continuation 参数（由编译器在编译时添加），但是我们在代码里是看不到这个参数的，我们要怎么样才能拿到这个参数呢？ Kotlin 厚颜无耻地把 Scheme 的 Call/CC（call-with-current-continuation）抄了过来并加以魔改，放在 kotlin.coroutines.experimental.intrinsics 这个包里，就是这玩意： inline suspend fun &lt;T> suspendCoroutineOrReturn(crossinline block: (Continuation&lt;T>) -> Any?): T 这个函数是 Kotlin 协程库中最重要的函数。在 Kotlin1.1 版本里，这个函数是个固有函数（intrinsic function，即编译器特殊对待的函数），如果你去看了它的源码（Kotlin1.1 版本），你会看到类似与这样的东西： inline suspend fun &lt;T> suspendCoroutineOrReturn(crossinline block: (Continuation&lt;T>) -> Any?): T = throw NotImplementedError(\"Implementation is intrinsic\") // 或者可能是一个 `null!!` 流石固有函数。在经过 CPS 转换后，我们来看一下这个函数的真面目： inline fun &lt;T> suspendCoroutineOrReturn(crossinline block: (Continuation&lt;T>) -> Any?, c: Continuation&lt;T>): Any? = block(c) 简单明了，直接将这个 Continuation 参数传给了 lambda，我们就可以通过这个 lambda 参数来操纵由 CPS 转换得来的 Continuation 。 上文讲过，这个返回值 Any? 其实是 T | COROUTINE_SUSPENDED ，COROUTINE_SUSPENDED 的定义也在这个包里： val COROUTINE_SUSPENDED: Any = Any() 太简单了。从上文的那个状态机伪代码里面可以看到，对于每个 suspend 函数的调用，都会检查其返回值是不是 COROUTINE_SUSPENDED。如果不是，那么状态机就开始执行下一个状态的代码；如果是 COROUTINE_SUSPENDED，就直接返回，停止执行代码，即协程挂起。可以写个demo来验证一下： suspend fun f3(): Unit = suspendCoroutineOrReturn { c -> COROUTINE_SUSPENDED } val suspendLambda: suspend () -> Unit = { println(\"before suspend\") f3() println(\"after suspend\") } suspendLambda.startCoroutine(object : Continuation&lt;Any> { …… }) 结果只有 before suspend 被打印了出来。如果要继续执行下去，则需要调用其 resume 方法： suspend fun f3(): Unit = suspendCoroutineOrReturn { c -> thread { Thread.sleep(5_000) c.resume(Unit) } COROUTINE_SUSPENDED } 这时候我们可以看到，before suspend 先被打印出来，5秒种后，after suspend 再被打印出来。 f3函数经过 CPS 转换、suspend 函数的尾调用优化以及 suspendCoroutineOrReturn 的内联，最终会变成如下的样子： fun f3(c: Continuation&lt;Unit>): Any? { thread { // ↑ 这个Any?其实是 ↓ Thread.sleep(5_000) // Unit | COROUTINE_SUSPENDED c.resume(Unit) } return COROUTINE_SUSPENDED } 看起来就像是在直接操纵附加的 Continuation 参数。 本节比较长，给个小结：suspendCoroutineOrReturn 能够让你直接操纵通过CPS转换得来的 Continuation 参数，这个函数接收一个 lambda 参数。在这个 lambda 里面，你将面临两种选择：直接返回需要的结果（不挂起协程）或者返回 COROUTINE_SUSPENDED（挂起协程）。如果你选择挂起协程，你需要在合适的地方与时机调用（从lambda的参数得到的）Continuation 的 resume 方法将需要的结果传入以便继续执行协程。 Kotlin 标准库里面的 suspendCoroutine 即是对 suspendCoroutineOrReturn 的封装，使其更易于使用。读者可以对比一下两者的函数签名以及文档上的注意事项。一般情况下使用 suspendCoroutine 即可满足需求。 PS：不知道从什么时候开始的，kotlin.coroutines.experimental.intrinsics 这个包以及里面的所有东西，都被Intellij IDEA的自动补全屏蔽了。你需要手动import这个包，里面的东西才能出现在自动补全的列表里。 PPS：在 Kotlin1.2 版本中，suspendCoroutineOrReturn 不再是一个固有函数，其实现由两个新的固有函数组成，但是不影响使用。（拆东墙补西墙） PPPS：本文完。 你学到了什么 Kotlin 协程的（不）常用的标准库函数的使用方法 编译器都做了什么事（的一部分） suspendCoroutineOrReturn有什么用 下一篇协程文？不存在的。 课后作业：Codewars上面的一道题，要求实现简单的控制流，很简单。如果你能看懂这篇文章，那么这道题对于你来说应该是十分简单的。（冰封julao仅用了不到十分钟的时间就做出来了） 反编译Tip：Intellij IDEA的Kotlin插件有将Kotlin代码反编译至Java的功能，但是在面对协程相关的代码时大多数情况下都不好用。请不要想太多，老老实实用其他反编译工具，我用的是这个jadx，版本0.6.1。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"},{"name":"Coroutine","slug":"Coroutine","permalink":"https://aisia.moe/tags/Coroutine/"}]},{"title":"Kotlin的一些技巧和迂回操作","slug":"kotlin-jiqiao","date":"2018-01-07T19:03:42.000Z","updated":"2018-07-02T09:36:25.000Z","comments":true,"path":"2018/01/07/kotlin-jiqiao/","link":"","permalink":"https://aisia.moe/2018/01/07/kotlin-jiqiao/","excerpt":"RT，不定期更新。\n不需要 import 就能使用的顶层函数","text":"RT，不定期更新。 不需要 import 就能使用的顶层函数 一个顶层函数，除非你在同一个文件里使用，否则就需要 import 或者使用完全限定名。问题是有些人就是嫌烦，想要所谓的“全局函数”，就像 Kotlin 标准库里的 println 一样。其实很简单，只需要写得跟 println 一样就行了： package kotlin fun fuck() {} 因为 kotlin 包下的东西都是自动导入的，也就不需要自己动手导入啦。 需要传入编译器参数 -Xallow-kotlin-package 来允许使用 kotlin 开头的包名。 递归的 Lambda 表达式刚才在某个 Kotlin 裙里看到有人在问： 是不是lambda无法递归 举个例子，我们可以写一个简单的递归函数： fun a() { println(\"1551\"); a() } a() // 打印出很多1551 如果要写成 Lambda 呢？这样的代码会报错： val a: () -> Unit = { println(\"1551\"); a() } 我们自然是不能直接写这样的代码的，它会说 a 没有定义。解决方法当然是使用 lateinit： lateinit var a: () -> Unit a = { println(\"1551\"); a() } a() // 打印出很多1551 更进一步：匿名 Lambda 表达式的递归正统的「Lambda演算」里面的函数全部都是匿名函数，需要使用「不动点组合子」实现递归： // 这是kotlin-js val z = { f: dynamic -> { g: dynamic -> g(g) } { x: dynamic -> f { y: dynamic -> x(x)(y) } } } val a = z { f: () -> Unit -> { println(\"1551\"); f() } } // 求斐波那契数列第n项的函数 val fib: (Int) -> Int = z { f: (Int) -> Int -> { x: Int -> if (x &lt;= 2) 1 else f(x - 1) + f(x - 2) } } // 输出斐波那契数列前10项 println((1.rangeTo(10).map(fib))) 上面的那一坨 val z 即是「Z组合子」。（读者可以思考一下为什么这里我给了 Kotlin-js 的例子是而不是 Kotlin-jvm（逃 阻止编译器添加对非空类型的函数参数的 NullCheck总所周知，当一个函数的参数是非空类型时，Kotlin编译器会在方法入口处加一行检查入参是否为空的代码。比如说 main 函数： fun main(args: Array&lt;String>) {} 经过编译后，再反编译成Java： public static final void main(@NotNull String[] args) { Intrinsics.checkParameterIsNotNull(args, \"args\"); } 可恶！辣鸡编译器自作主张！我不想要这行代码！ 如果不想编译器生成这些代码，把这几个编译器参数 -Xno-call-assertions、-Xno-param-assertions、-Xno-receiver-assertions 传给Kotlin编译器即可。 传递编译器参数的方法： 使用IDEA调用编译器的情况： Project 设置：File -&gt; Settings -&gt; 找到 Kotlin Compiler -&gt; Additional command line parameters Module 设置：File -&gt; Project Structure -&gt; Module -&gt; 找到你的Module里面的Kotlin设置 -&gt; Additional command line parameters 使用Gradle Kotlin DSL的情况： // build.gradle.kts tasks.withType&lt;KotlinCompile> { // 加上下面这行 kotlinOptions.freeCompilerArgs = listOf(\"-Xno-call-assertions\", \"-Xno-param-assertions\", \"-Xno-receiver-assertions\") } PS：注意IDEA的 Delegate IDE build/run actions to gradle 这个选项是否勾选的区别。 给data class自定义getter和setterdata class SomeClass(var name: String) 众所周知 Kotlin 不允许给声明在主构造器里面的属性写自定义getter、setter，主要是为了防止有好事者乱写，破坏规则就不好了。所以迂回操作如下： data class SomeClass(private var _name: String) { var name: String get() = _name set(value) { _name = value } } 解释：private的_name不会生成getter和setter，你再把你想写的getter和setter添上就好。这样SomeClass里面就有3样东西：String _name，String getName()和void setName(String)（以及data class根据_name自动生成的那些）。 缺点很明显，toString 生成的字符串会比较丑。 流的读取普通青年： // java 代码 void someFunc(InputStream in, OutputStream out) throws IOException { int read; while ((read = in.read()) != -1) { out.write(read); } } 文艺青年： fun someFunc(`in`: InputStream, out: OutputStream) { var read: Int = -1 while ({ read = `in`.read();read }() != -1) { out.write(read) } } 二逼青年： fun someFunc(`in`: InputStream, out: OutputStream) { var read: Int = `in`.read() while (read != -1) { out.write(read) read = `in`.read() } } 群里的优秀的青年（不是我）： fun someFunc(`in`: InputStream, out: OutputStream) { var read: Int = -1 while (`in`.read().also { read = it } != -1) { out.write(read) } } 限制扩展的作用域（防止污染命名空间）注意：此技巧并不稳定，可能在未来被官方干掉。 // 把扩展丢进一个object里面 object StringExtension { @JvmStatic fun String.fuck() = println(\"fuck $this\") } // 使用说明 fun test() { // 下面这行被注释掉的代码不能通过编译 // \"kotlin\".fuck() // 你要这么用，将MyExtentions塞进上下文（即this） with(StringExtention) { \"kotlin\".fuck() } } // 或者手动引入 import StringExtension.fuck fun test() { \"kotlin\".fuck() } // 以下是夏姬八写，别模仿 interface Extension inline fun &lt;T : Extension, R> T.use(block: T.() -> R) = this.block() object StringExtension : Extension { @JvmStatic fun String.fuck() = println(\"fuck $this\") } object IntExtension : Extension { @JvmStatic fun Int.love() = println(\"I love $this\") } fun test() { StringExtension.use { \"kotlin\".fuck() } IntExtension.use { 1551.love() } } 链式调用时输出中间值inline fun &lt;T> T.println(): T = printlnBy { it } inline fun &lt;T, U> T.printlnBy(selector: (T) -> U): T = this.also { println(selector(it)) } fun test() { listOf(1, 2, 3).asSequence() .map { it * 3 }.printlnBy { it.sum() } // &lt;==这里 .filter { it and 1 == 0 } .sum().println() // &lt;==还有这里 } // 输出： // 18 // 6 注意副作用，别夏姬八用！ 如果是集合操作，可以考虑使用 onEach 这个高阶函数，例如onEach { println(it) }。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"【水】Kotlin Puzzlers 改","slug":"kotlin-puzzlers","date":"2017-12-28T16:08:56.000Z","updated":"2018-07-27T03:21:48.178Z","comments":true,"path":"2017/12/28/kotlin-puzzlers/","link":"","permalink":"https://aisia.moe/2017/12/28/kotlin-puzzlers/","excerpt":"《Java Puzzlers》（中文名《Java 解惑》）里面讲解了许多 Java 语言的大坑，相信各位julao应该都看过。Kotlin 作为「a better Java」，在填补一些坑的同时，不可避免地引入了许多新坑。","text":"《Java Puzzlers》（中文名《Java 解惑》）里面讲解了许多 Java 语言的大坑，相信各位julao应该都看过。Kotlin 作为「a better Java」，在填补一些坑的同时，不可避免地引入了许多新坑。本来本鶸进行了一段时间的取材，想要写一篇《Kotlin Puzzlers》的，可谁知 已经有人早就把我的饭碗抢走了，而且素材比我还多，可恶！ 这篇文章就是本鶸看完录像（油土鳖上面有）以及 Github 上的完整内容后，将一些比较坑的谜题拿出来报复社会，蛐蛐一篇观后感而已。 题型为选择题，本辣鸡博客没有NGA的折叠，没有萌百的黑幕，为了防止一眼瞄到答案而造成剧透，本文对答案（以及解释）的摆放位置做了调整，例如第一题的答案被我放在了第二题的位置（以此类推）。各位看客从上到下开始阅读就好了。 使用的 Kotlin 版本为1.2。 没有坑到我的谜题虽然没有被坑，比较简单，但是值得注意的题。一些更加简单的题目就不放上来了。想刷一遍完整题库的同学可以到 GitHub 上面找。 强力返回 ~ Power Returnfun hello(): String { val result = return throw return \"Hello\" println(result.toString()) } println(hello()) 这会打印出什么？ a) Hello b) 两个Hello c) 这破代码根本没法通过编译 d) 以上答案都不对 本题答案（以及解释）在下一题那里。（以此类推） 计划生育 ~ One Chile Policyopen class Node(val name: String) { fun lookup() = println(name) } class Parent : Node(\"parent\") { fun child(name: String): Node? = Node(name) val child1 = child(\"child1\")?.apply { lookup() } val child2 = child(\"child2\").apply { lookup() } } Parent() 这会打印出什么？ a) child1 和 child2 b) child1 和 parent c) parent 和 child2 d) 以上答案都不对 上一题的答案：a 要记住，return *** 和 throw *** 都是表达式，其结果的类型为 Nothing，Nothing 类型是任意类型的子类型，所以 Nothing 可以被抛出，可以被返回，可以赋值给任意类型的变量。事实上 hello() 在 return &quot;Hello&quot; 的时候已经结束了，剩下的 throw、val result、println() 什么的都是不可到达代码（unreachable code），不会被运行。 PS：你甚至可以写出这样的代码：throw throw throw Exception() 两只拉姆达跑得快 ~ Two Lambdatypealias L = (String) -> Unit fun foo(one: L = {}, two: L = {}) { one(\"one\") two(\"two\") } foo { print(it) } foo({ print(it) }) 这会打印出什么？ a) oneone b) twotwo c) onetwo d) 以上答案都不对 上一题的答案：d 事实上是 child1 和 parent。Kotlin 的这些扩展方法如 apply、let、also 等等都是适用于所有类型的，包括可空类型。child2 那行 apply 函数接收的拉姆达表达式的类型其实是 Node?.() -&gt; Unit，如果 child2那行代码是写在 Parent 类的外面的话，你就会发现这行代码根本没法通过编译，这里面调用的 lookup 实际上是 parent 的 lookup。（你可以把 apply 换成 also 试试。） 衔尾蛇 ~ Cyclic Object Constructionsopen class A(val x: Any?) object B : A(C) object C : A(B) print(B.x) print(C.x) 这会打印出什么？ a) nullnull b) C@********null c) ExceptionInInitializerError d) 这破代码根本没法通过编译 上一题的答案：d 实际上是 twoone。第一句的语法只有在拉姆达表达式是最后一个参数的时候才能写的，所以是 two。第二句是普通的方法调用，先填上第一个参数，第二个参数使用默认值。 PS：想要朴素地实现 foo { } { } 这样的调用的话应该是办不到的吧。(如果能做到请赶快告诉我！) 哇，好长 ~ Breaking Linesval anExtremelyLongAndBoringStatementThatBarelyFitsOnALine = 2 val anotherExtremelyLongStatementThatBarelyFitsOnALine = 2 val someList = listOf(1) val result = someList.map { anExtremelyLongAndBoringStatementThatBarelyFitsOnALine + anotherExtremelyLongStatementThatBarelyFitsOnALine } print(result) 这会打印出什么？ a) [1] b) [2] c) [4] d) [1, 4] 上一题的答案：b B 初始化需要 C，C 初始化需要 B。咦，B 还没初始化完成呢，那么哪来的 B 呢，只能是 null 了啊！ 参见 http://jetbrains.github.io/kotlin-spec/#_singleton_objects 换个名字你就不认识我了 ~ Good Child Has Many Namesopen class C { open fun sum(x: Int = 1, y: Int = 2): Int = x + y } class D : C() { override fun sum(y: Int, x: Int): Int = super.sum(x, y) } val d: D = D() val c: C = d print(c.sum(x = 0)) print(d.sum(x = 0)) println() 这会打印出什么？ a) 22 b) 11 c) 21 d) 这破代码根本没法通过编译 上一题的答案：b 之前裙里有julao问过类似的问题所以我没被坑到。你可以把代码丢到IDEA里面，光标定位到加号前面，按下 Ctrl+B 或者 Ctrl+Q，看看那个加号是什么意思吧。解决方法：把加号放在上一行的后面可破。 排序 ~ Sortingval list = arrayListOf(1, 5, 3, 2, 4) val sortedList = list.sort() print(sortedList) 这会打印出什么？ a) [1, 5, 3, 2, 4] b) [1, 2, 3, 4, 5] c) kotlin.Unit d) 这破代码根本没法通过编译 上一题的答案：c 命名参数是静态分配的。 致命的顺序 ~ The Orderclass Order { private val c: String init { the() c = \"\" } private fun the() { println(c.length) } } Order() 这会打印出什么？ a) 0 b) null c) 这破代码根本没法通过编译 d) 以上答案都不对 上一题的答案：c 参见 https://zhuanlan.zhihu.com/p/27234651 本题的答案：d JVM 不想理你并向你抛出了一只 NPE。Java 也有这个问题，Scala 不熟悉不清楚。据说 Ceylon 就没有这个问题，具体可以看 Ceylon 官网上的说明（趁机吹一波 Ceylon）。 https://ceylon-lang.org/documentation/1.3/tour/initialization/#definite_assignment_and_definite_initialization Kotlin 官方人员曾表示修复这个缺陷是一件十分困难的事。 那些坑了我的迷题我果然是鶸，错了这么多，进入自卑模式~ 区间测试 ~ Inclusive Rangeval i = 10.5 when (i) { in 1..10 -> println(\"in\") !in 1..10 -> println(\"!in\") else -> println(\"else\") } 这会打印出什么？ a) in b) !in c) else d) 这破代码根本没法通过编译 据说这道题在 Kotlin 1.0 版本和 1.2 版本里有不同的表现。（我懒得试旧版本了） 极性不定 ~ Weird Chainingfun printNumberSign(num: Int) { if (num &lt; 0) { \"negative\" } else if (num > 0) { \"positive\" } else { \"zero\" }.let { println(it) } } printNumberSign(-2) printNumberSign(0) printNumberSign(2) 这会打印出什么？ a) negative; zero; positive b) negative; zero c) negative; positive d) zero; positive 上一题的答案：a 实际上是把 i 转成 Int 再进行的比较。 $_$ ~ Dollar In Multiline Literalsval multiline = \"\"\" To win \\$999.999 execute \"rm -fr \\$HOME/kotlin-puzzlers/*\" \"\"\".trimIndent() println(multiline) 这会打印出什么？ a) To win \\$999.999 execute &quot;rm -fr \\$HOME/kotlin-puzzlers/*&quot; b) To win 999.999 execute &quot;rm -fr \\/home/user/kotlin-puzzlers/*&quot; c) To win $999.999 execute &quot;rm -fr $HOME/kotlin-puzzlers/*&quot; d) 这破代码根本没法通过编译 上一题的答案：d 相当于： if (num &lt; 0) { \"negative\" } else { if (num > 0) { \"positive\" } else { \"zero\" }.let { println(it) } } 秒懂！ 解决方法：用小括号将那串 if else 括起来再接 let 可破。 你的名字是 ~ Property Overrideopen class Named { open var name: String? = null get() = field ?: \"&lt;unnamed>\" } class Person: Named() { override var name: String? = null get() = super.name set(value) { field = \"Mr $value\" } } val person = Person() person.name = \"Anton\" println(person.name) 这会打印出什么？ a) Anton b) Mr Anton c) &lt;unnamed&gt; d) null 上一题的答案：d 这种 raw string 里面美元符号 $ 一直都是表示模板表达式，而且不能被转义，所以 $HOME 这里糟了。（你问为什么 $999.999 没糟？因为 999.999 不是合法的变量名啊，你在 999.999 两边加上反引号试试。） 解决方法：”””${‘$’}HOME””” 冰雪聪明 ~ Custom Getter Smartcastclass SmartCastable { val list: List&lt;Int> = mutableListOf(1, 2, 3) val set: Set&lt;Int> = mutableSetOf(1, 2, 3) get() = field } val sc = SmartCastable() if(sc.list is MutableList) sc.list.add(4) if(sc.set is MutableSet) sc.set.add(4) println(\"${sc.list}, ${sc.set}\") 这会打印出什么？ a) [1, 2, 3], [1, 2, 3] b) [1, 2, 3, 4], [1, 2, 3, 4] c) UnsupportedOperationException d) 这破代码根本没法通过编译 上一题的答案：c 这里有两个 backing field，Named 类的那个 get 方法操纵了父类的 backing field，set 方法操纵的是自己的 backing field。 解决方法： class Person: Named() { override var name: String? get() = super.name set(value) { super.name = \"Mr $value\" } } 最小值 ~ MinIntfun printInt(n: Int) { println(n) } printInt(-2_147_483_648.inc()) 这会打印出什么？ a) -2147483647 b) -2147483649 c) 2147483647 d) 以上答案都不对 上一题的答案：d sc.set 有一个自定义 getter，编译器没法判断这个 getter 返回的是否是同一个对象，所以无法进行智能转换（smart cast）。 解决方法：这时候别声明只有 getter 的属性，声明有 backing field 的属性就好。或者像这样： val set = sc.set if(set is MutableSet) set.add(4) 人类衰退之后 ~ Population To Marsclass Population(var cities: Map&lt;String, Int>) { val 帝都 by cities val 魔都 by cities val 妖都 by cities } val population = Population(mapOf( \"帝都\" to 864_816, \"魔都\" to 413_782, \"妖都\" to 43_005 )) // 许多年过去了，地球毁灭了，只有少数幸存者抵达了火星（大吉大利今晚吃鸡）！ population.cities = emptyMap() with(population) { println(\"$帝都; $魔都; $妖都\") } 这会打印出什么？ a) 0; 0; 0 b) 864816; 413782; 43005 c) NullPointerException d) NoSuchElementException 上一题的答案：d 破代码没法通过编译。实际的求值顺序是：-(2_147_483_648.inc())，这TM是个 Long。这个一元操作符的优先级比普通方法调用低。 反物质 ~ AntiMatteroperator fun Nothing?.not() = Unit operator fun Unit.not() = null val foo = null println(!!!!!foo!!!!) 这会打印出什么？ a) null b) kotlin.Unit c) KotlinNullPointerException d) 这破代码根本没法通过编译 上一题的答案：b 用于委托代理的那个 Map 被保存在了一个 private final 的 field 里面，正常手段没法赋新值。 本题的答案：d null 的类型是 Nothing?（而且是这个类型的唯一值）。***!! 这个非空断言比 not() 的优先级要高，所以 foo!!!! 的类型是 Nothing，Nothing 是所有类型的子类型，所以编译器没法判断该调用哪个扩展方法。 总结这些辣鸡代码，别学。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"最近观察到的Kotlin的华点","slug":"huadian","date":"2017-10-18T15:44:52.000Z","updated":"2018-07-27T03:21:48.162Z","comments":true,"path":"2017/10/18/huadian/","link":"","permalink":"https://aisia.moe/2017/10/18/huadian/","excerpt":"不定期更新。","text":"不定期更新。以下内容使用的 Kotlin 版本为 1.1.51。 2017-10-18封面换成了艾拉酱，真好啊~真好啊~ ヾ(≧▽≦*)o 一件Java能做但是Kotlin不能做的事情在Codewars上刷题的时候发现的，本来这网站上面的Kotlin题就少，而且还有大把大把不会写，能玩的就更少了。这种题目不调戏一下冰酱就可惜了。具体是这道题。 这题要求你代码中不能出现fun、{以及}的情况下让定义一个拼接两个字符串的函数。这个要求等同于禁止你使用lambda表达式、函数声明，并且限制你仅用一个表达式完成任务（根据我的理解，是这样的没错）。 那我们来找找有什么现成的有invoke()方法的东西吧。首先想到了反射，但是反射那家伙需要传入接收者作为第一个参数，rua~。既然反射不行，啊，有个更好的东西，看起来完美符合需求。 马上写好代码准备吊打冰酱，然后就是喜闻乐见的辣鸡Kotlin时间，代码如下： val concatString = MethodHandles.lookup().findVirtual(String::class.java, \"concat\", MethodType.methodType(String::class.java, String::class.java)) val str = concatString(\"我永远喜欢\", \"珂朵莉\") as String // Boom！ 然后在Java里写下同样的代码进行测试，嗯，果然是辣鸡Kotlin。 炸裂原因是Kotlin不支持所谓的签名多态性（signature polymorphism），从编译出来的字节码可以看得出来： // kotlin INVOKEVIRTUAL java/lang/invoke/MethodHandle.invoke ([Ljava/lang/Object;)Ljava/lang/Object; // java INVOKEVIRTUAL java/lang/invoke/MethodHandle.invoke (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; 运行时要成功调用该方法的话，字节码中的参数与返回值类型必须与运行时MethodHandle所代表的实际的方法类型一致，否则会抛出WrongMethodTypeException。上面那段Kotlin代码运行时就会抛出这个异常，异常信息为cannot convert MethodHandle(String,String)String to (Object[])Object，正好与上面的字节码相对应。嗯就是这样。 Kotlin编译器现在还不能支持多态签名，而且这将持续很长一段时间（官方人员说了，1.2版本也不会实现这项功能）。 解决方法：辣鸡Kotlin。 2017-10-10最近翻看以前写的旧代码，发现由于Kotlin及其IDEA插件版本更新了，静态检查工具功能增强，检出了一些令人窒息的代码（例如 Check for instance is always ‘true’）。然后我在查看这些乱七八糟的代码时发现了两个问题。 编译器生成了无用的字节码(?)把问题单独抽出来就像是这样： class A&lt;T : Any>(val data: T) class B(val string: String) fun test(a: A&lt;*>) { a.data as B // 注意这行对应的字节码 a.data.string // 这里 a.data 有提示 Smart cast to B } 然后看看编译出的字节码里面都有啥： // 以上省略 L1 LINENUMBER 5 L1 ALOAD 0 INVOKEVIRTUAL A.getData ()Ljava/lang/Object; // a.data DUP IFNONNULL L2 // &lt;============================ 这里进行判空 NEW kotlin/TypeCastException DUP LDC \"null cannot be cast to non-null type B\" INVOKESPECIAL kotlin/TypeCastException.&lt;init> (Ljava/lang/String;)V ATHROW L2 CHECKCAST B // &lt;============================ 不为空则进行类型转换 POP L3 // 以下省略 大致内容就是判断 a.data 是否为 null，如果是 null 就 throw TypeCastException(&quot;null cannot be cast to non-null type B&quot;)。然而根据 A 这个类的定义，其属性 data 必定是非空的。对非空属性进行 null check 岂不是多余？难道说编译器太傻，在分析这种操作时不知道 a.data 是非空的？ 解决方法：加个问号，如下所示： fun test(a: A&lt;*>) { a.data as B? // 加了个问号，变成了B? a.data.string // 注意这里 a.data 同样有提示 Smart cast to B } 这时候字节码就是这样的： // 以上省略 L1 LINENUMBER 5 L1 ALOAD 0 INVOKEVIRTUAL A.getData ()Ljava/lang/Object; // a.data CHECKCAST B // &lt;============================ 直接进行类型转换 POP L2 // 以下省略 这回就没有多余的判空处理了。但是注意代码中的 a.data.string，IDE提示 a.data 能够 Smart cast to B。咦编译器还是蛮聪明的呢！ 检查工具提示可对代码进行负优化(?)这个问题单独抽出来就像这样： class A class B { fun getA(): A = TODO() } fun test(some: Any?): A { return if (some is B) some.getA() else A() // 注意这行 } 然后你可以看到，IDE提示你可以 Replace ‘if’ expression with elvis experssion。如果你让IDE帮你优化，就变成了这样： fun test(some: Any?): A { return (some as? B)?.getA() ?: A() // WTF??? } 不知道你们是怎么想的，至少对于我来说可读性下降，而且很明显生成的字节码也变复杂了。明显是负优化，吧？ 解决方法：@Suppress(&quot;IfThenToElvis&quot;) 很久以前的冷饭把以前想过的东西拿出来凑字数。 Kotlin数组类型与reified在Java，你可以这样写： public static void some(Object o) { if (o instanceof String[]) { System.out.println(\"this is String[]\"); } } 但是辣鸡Kotlin不行： fun some(any: Any?) { // 编译错误：Cannot check for instance of erased type: Array&lt;String> // ↓ if (any is Array&lt;String>) { println(\"this is String[]\") } } 说好的 Array&lt;reified T&gt; 呢？","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://aisia.moe/tags/Kotlin/"}]},{"title":"关于此博客，以及博主，还有那些七七八八的事","slug":"about","date":"2017-04-27T03:32:52.000Z","updated":"2018-07-27T03:21:48.162Z","comments":true,"path":"2017/04/27/about/","link":"","permalink":"https://aisia.moe/2017/04/27/about/","excerpt":"一些碎碎念讲道理，我搭好 Hexo 才发现，如果使用 Jekyll 的话，只要将页面源码 Push 到 Github 上，是可以自动生成页面并发布的。","text":"一些碎碎念讲道理，我搭好 Hexo 才发现，如果使用 Jekyll 的话，只要将页面源码 Push 到 Github 上，是可以自动生成页面并发布的。全栽在 CI 上了（用的是 AppVeyor），首先是太久没用 Git，忘记子模块怎么用了，坑了好久。之后是 Git 一些操作重定向 stdout 到 stderr 导致 PowerShell ISE 报错，于是 CI 那边就挂掉了。然后是 Gitlab 的神奇 Bug，一次 Push 让 CI 那边连续 Build 了 5 次…… 于是 3 天的人生就浪费掉了。其实如果不搞持续集成的话就没那么多事。虽然说结果都一样，但是总感觉有那么点不爽，我特么怎么就选了 Hexo 呢。越想越恼火。不排除以后换成 Jekyll 的可能性，不过主题一定是要换的。 2017年5月29日，主题由 indigo 变更为 material。 2018年1月20日，域名已部署，HTTPS已部署。 关于博客 ~ The History of RenTouemmm… 关于我唔，感觉没啥好说的呢。 人头会社三元老之一，精神病院第13号床位所有者。 不务正业的辣鸡。 噫，就这样。 其他这个博客是有评论系统的，看不到的话那应该是被墙了，请使用科学姿势查看。（或者等我换成其他系统（懒癌不允许我这么做（不！","raw":null,"content":null,"categories":[],"tags":[{"name":"Others","slug":"Others","permalink":"https://aisia.moe/tags/Others/"}]}]}