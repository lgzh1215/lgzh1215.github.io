{"meta":{"title":"萌夜雀的人头会社","subtitle":null,"description":"要和谐, 要有爱","author":"Dexlind","url":"https://lgzh1215.github.io"},"pages":[{"title":"about","date":"2017-05-28T18:28:59.000Z","updated":"2017-12-29T10:38:40.144Z","comments":true,"path":"about/index.html","permalink":"https://lgzh1215.github.io/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"categories","date":"2017-04-18T17:12:52.000Z","updated":"2017-12-29T10:38:40.144Z","comments":true,"path":"categories/index.html","permalink":"https://lgzh1215.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-12-29T10:38:40.222Z","updated":"2017-12-29T10:38:40.222Z","comments":true,"path":"tags/index.html","permalink":"https://lgzh1215.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"timeline","date":"2017-12-29T10:38:40.222Z","updated":"2017-12-29T10:38:40.222Z","comments":true,"path":"timeline/index.html","permalink":"https://lgzh1215.github.io/timeline/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Kotlin Puzzlers 改","slug":"kotlin-puzzlers","date":"2017-12-28T16:08:56.000Z","updated":"2017-12-29T10:38:40.128Z","comments":true,"path":"2017/12/28/kotlin-puzzlers/","link":"","permalink":"https://lgzh1215.github.io/2017/12/28/kotlin-puzzlers/","excerpt":"《Java Puzzlers》（中文名《Java 解惑》）里面讲解了许多 Java 语言的大坑，相信各位julao应该都看过。Kotlin 作为「a better Java」，在填补一些坑的同时，不可避免地引入了许多新坑。","text":"《Java Puzzlers》（中文名《Java 解惑》）里面讲解了许多 Java 语言的大坑，相信各位julao应该都看过。Kotlin 作为「a better Java」，在填补一些坑的同时，不可避免地引入了许多新坑。本来本鶸进行了一段时间的取材，想要写一篇《Kotlin Puzzlers》的，可谁知 已经有人早就把我的饭碗抢走了，而且素材比我还多，可恶！ 这篇文章就是本鶸看完录像（油土鳖上面有）以及 Github 上的完整内容后，将一些比较坑的谜题拿出来报复社会，蛐蛐一篇观后感而已。 题型为选择题，本辣鸡博客没有NGA的折叠，没有萌百的黑幕，为了不让一眼瞄到答案而造成剧透，本文对答案（以及解释）的摆放位置做了调整，例如第一题的答案被我放在了第二题的位置（以此类推）。各位看客从上到下开始阅读就好了。 使用的 Kotlin 版本为1.2。 没有坑到我的谜题虽然没有被坑，比较简单，但是值得注意的题。一些更加简单的题目就不放上来了。想刷一遍完整题库的同学可以到 GitHub 上面找。 强力返回 ~ Power Returnfun hello(): String { val result = return throw return \"Hello\" println(result.toString()) } println(hello()) 这会打印出什么？ a) Hello b) 两个Hello c) 这破代码根本没法通过编译 d) 以上答案都不对 本题答案（以及解释）在下一题那里。（以此类推） 计划生育 ~ One Chile Policyopen class Node(val name: String) { fun lookup() = println(name) } class Parent : Node(\"parent\") { fun child(name: String): Node? = Node(name) val child1 = child(\"child1\")?.apply { lookup() } val child2 = child(\"child2\").apply { lookup() } } Parent() 这会打印出什么？ a) child1 和 child2 b) child1 和 parent c) parent 和 child2 d) 以上答案都不对 上一题的答案：a 要记住，return *** 和 throw *** 都是表达式，其结果的类型为 Nothing，Nothing 类型是任意类型的子类型，所以 Nothing 可以被抛出，可以被返回，可以赋值给任意类型的变量。事实上 hello() 在 return &quot;Hello&quot; 的时候已经结束了，剩下的 throw、val result、println() 什么的都是不可到达代码（unreachable code），不会被运行。 PS：你甚至可以写出这样的代码：throw throw throw Exception() 两只拉姆达跑得快 ~ Two Lambdatypealias L = (String) -> Unit fun foo(one: L = {}, two: L = {}) { one(\"one\") two(\"two\") } foo { print(it) } foo({ print(it) }) 这会打印出什么？ a) oneone b) twotwo c) onetwo d) 以上答案都不对 上一题的答案：d 事实上是 child1 和 parent。Kotlin 的这些扩展方法如 apply、let、also 等等都是适用于所有类型的，包括可空类型。child2 那行 apply 函数接收的拉姆达表达式的类型其实是 Node?.() -&gt; Unit，如果 child2那行代码是写在 Parent 类的外面的话，你就会发现这行代码根本没法通过编译，这里面调用的 lookup 实际上是 parent 的 lookup。（你可以把 apply 换成 also 试试。） 衔尾蛇 ~ Cyclic Object Constructionsopen class A(val x: Any?) object B : A(C) object C : A(B) print(B.x) print(C.x) 这会打印出什么？ a) nullnull b) C@********null c) ExceptionInInitializerError d) 这破代码根本没法通过编译 上一题的答案：d 实际上是 twoone。第一句的语法只有在拉姆达表达式是最后一个参数的时候才能写的，所以是 two。第二句是普通的方法调用，先填上第一个参数，第二个参数使用默认值。 PS：想要朴素地实现 foo { } { } 这样的调用的话应该是办不到的吧。(如果能做到请赶快告诉我！) 哇，好长 ~ Breaking Linesval anExtremelyLongAndBoringStatementThatBarelyFitsOnALine = 2 val anotherExtremelyLongStatementThatBarelyFitsOnALine = 2 val someList = listOf(1) val result = someList.map { anExtremelyLongAndBoringStatementThatBarelyFitsOnALine + anotherExtremelyLongStatementThatBarelyFitsOnALine } print(result) 这会打印出什么？ a) [1] b) [2] c) [4] d) [1, 4] 上一题的答案：b B 初始化需要 C，C 初始化需要 B。咦，B 还没初始化完成呢，那么哪来的 B 呢，只能是 null 了啊！ 参见 http://jetbrains.github.io/kotlin-spec/#_singleton_objects 换个名字你就不认识我了 ~ Good Child Has Many Namesopen class C { open fun sum(x: Int = 1, y: Int = 2): Int = x + y } class D : C() { override fun sum(y: Int, x: Int): Int = super.sum(x, y) } val d: D = D() val c: C = d print(c.sum(x = 0)) print(d.sum(x = 0)) println() 这会打印出什么？ a) 22 b) 11 c) 21 d) 这破代码根本没法通过编译 上一题的答案：b 之前裙里有julao问过类似的问题所以我没被坑到。你可以把代码丢到IDEA里面，光标定位到加号前面，按下 Ctrl+B 或者 Ctrl+Q，看看那个加号是什么意思吧。解决方法：把加号放在上一行的后面可破。 排序 ~ Sortingval list = arrayListOf(1, 5, 3, 2, 4) val sortedList = list.sort() print(sortedList) 这会打印出什么？ a) [1, 5, 3, 2, 4] b) [1, 2, 3, 4, 5] c) kotlin.Unit d) 这破代码根本没法通过编译 上一题的答案：c 命名参数是静态分配的。 致命的顺序 ~ The Orderclass Order { private val c: String init { the() c = \"\" } private fun the() { println(c.length) } } Order() 这会打印出什么？ a) 0 b) null c) 这破代码根本没法通过编译 d) 以上答案都不对 上一题的答案：c 参见 https://zhuanlan.zhihu.com/p/27234651 本题的答案：d JVM 不想理你并向你抛出了一只 NPE。Java 也有这个问题，Scala 不熟悉不清楚。据说 Ceylon 就没有这个问题，具体可以看 Ceylon 官网上的说明（趁机吹一波 Ceylon）。 https://ceylon-lang.org/documentation/1.3/tour/initialization/#definite_assignment_and_definite_initialization Kotlin 官方人员曾表示修复这个缺陷是一件十分困难的事。 那些坑了我的迷题我果然是鶸，错了这么多，进入自卑模式~ 区间测试 ~ Inclusive Rangeval i = 10.5 when (i) { in 1..10 -> println(\"in\") !in 1..10 -> println(\"!in\") else -> println(\"else\") } 这会打印出什么？ a) in b) !in c) else d) 这破代码根本没法通过编译 据说这道题在 Kotlin 1.0 版本和 1.2 版本里有不同的表现。（我懒得试旧版本了） 极性不定 ~ Weird Chainingfun printNumberSign(num: Int) { if (num &lt; 0) { \"negative\" } else if (num > 0) { \"positive\" } else { \"zero\" }.let { println(it) } } printNumberSign(-2) printNumberSign(0) printNumberSign(2) 这会打印出什么？ a) negative; zero; positive b) negative; zero c) negative; positive d) zero; positive 上一题的答案：a 实际上是把 i 转成 Int 再进行的比较。 $_$ ~ Dollar In Multiline Literalsval multiline = \"\"\" To win \\$999.999 execute \"rm -fr \\$HOME/kotlin-puzzlers/*\" \"\"\".trimIndent() println(multiline) 这会打印出什么？ a) To win \\$999.999 execute &quot;rm -fr \\$HOME/kotlin-puzzlers/*&quot; b) To win 999.999 execute &quot;rm -fr \\/home/user/kotlin-puzzlers/*&quot; c) To win $999.999 execute &quot;rm -fr $HOME/kotlin-puzzlers/*&quot; d) 这破代码根本没法通过编译 上一题的答案：d 相当于： if (num &lt; 0) { \"negative\" } else { if (num > 0) { \"positive\" } else { \"zero\" }.let { println(it) } } 秒懂！ 解决方法：用小括号将那串 if else 括起来再接 let 可破。 你的名字是 ~ Property Overrideopen class Named { open var name: String? = null get() = field ?: \"&lt;unnamed>\" } class Person: Named() { override var name: String? = null get() = super.name set(value) { field = \"Mr $value\" } } val person = Person() person.name = \"Anton\" println(person.name) 这会打印出什么？ a) Anton b) Mr Anton c) &lt;unnamed&gt; d) null 上一题的答案：d 这种 raw string 里面美元符号 $ 一直都是表示模板表达式，而且不能被转义，所以 $HOME 这里糟了。（你问为什么 $999.999 没糟？因为 999.999 不是合法的变量名啊，你在 999.999 两边加上反引号试试。） 解决方法：”””${‘$’}HOME””” 冰雪聪明 ~ Custom Getter Smartcastclass SmartCastable { val list: List&lt;Int> = mutableListOf(1, 2, 3) val set: Set&lt;Int> = mutableSetOf(1, 2, 3) get() = field } val sc = SmartCastable() if(sc.list is MutableList) sc.list.add(4) if(sc.set is MutableSet) sc.set.add(4) println(\"${sc.list}, ${sc.set}\") 这会打印出什么？ a) [1, 2, 3], [1, 2, 3] b) [1, 2, 3, 4], [1, 2, 3, 4] c) UnsupportedOperationException d) 这破代码根本没法通过编译 上一题的答案：c 这里有两个 backing field，Named 类的那个 get 方法操纵了父类的 backing field，set 方法操纵的是自己的 backing field。 解决方法： class Person: Named() { override var name: String? get() = super.name set(value) { super.name = \"Mr $value\" } } 最小值 ~ MinIntfun printInt(n: Int) { println(n) } printInt(-2_147_483_648.inc()) 这会打印出什么？ a) -2147483647 b) -2147483649 c) 2147483647 d) 以上答案都不对 上一题的答案：d sc.set 有一个自定义 getter，编译器没法判断这个 getter 返回的是否是同一个对象，所以无法进行智能转换（smart cast）。 解决方法：这时候别声明只有 getter 的属性，声明有 backing field 的属性就好。或者像这样： val set = sc.set if(set is MutableSet) set.add(4) 人类衰退之后 ~ Population To Marsclass Population(var cities: Map&lt;String, Int>) { val 帝都 by cities val 魔都 by cities val 妖都 by cities } val population = Population(mapOf( \"帝都\" to 864_816, \"魔都\" to 413_782, \"妖都\" to 43_005 )) // 许多年过去了，地球毁灭了，只有少数幸存者抵达了火星（大吉大利今晚吃鸡）！ population.cities = emptyMap() with(population) { println(\"$帝都; $魔都; $妖都\") } 这会打印出什么？ a) 0; 0; 0 b) 864816; 413782; 43005 c) NullPointerException d) NoSuchElementException 上一题的答案：d 破代码没法通过编译。实际的求值顺序是：-(2_147_483_648.inc())，这TM是个 Long。这个一元操作符的优先级比普通方法调用低。 反物质 ~ AntiMatteroperator fun Nothing?.not() = Unit operator fun Unit.not() = null val foo = null println(!!!!!foo!!!!) 这会打印出什么？ a) null b) kotlin.Unit c) KotlinNullPointerException d) 这破代码根本没法通过编译 上一题的答案：b 用于委托代理的那个 Map 被保存在了一个 private final 的 field 里面，正常手段没法赋新值。 本题的答案：d null 的类型是 Nothing?（而且是这个类型的唯一值）。***!! 这个非空断言比 not() 的优先级要高，所以 foo!!!! 的类型是 Nothing，Nothing 是所有类型的子类型，所以编译器没法判断该调用哪个扩展方法。 总结这些辣鸡代码，别学。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://lgzh1215.github.io/tags/Kotlin/"}]},{"title":"2017-10-18：最近观察到的Kotlin的华点","slug":"huadian","date":"2017-10-18T15:44:52.000Z","updated":"2017-12-29T10:38:40.128Z","comments":true,"path":"2017/10/18/huadian/","link":"","permalink":"https://lgzh1215.github.io/2017/10/18/huadian/","excerpt":"每次有零零碎碎的新东西都发篇文章觉得不是很好，这里当作记录贴好了，不定期更新。封面换成了艾拉酱，真好啊~真好啊~ ヾ(≧▽≦*)o","text":"每次有零零碎碎的新东西都发篇文章觉得不是很好，这里当作记录贴好了，不定期更新。封面换成了艾拉酱，真好啊~真好啊~ ヾ(≧▽≦*)o使用的 Kotlin 版本为 1.1.51。 一件Java能做但是Kotlin不能做的事情在Codewars上刷题的时候发现的，本来这网站上面的Kotlin题就少，而且还有大把大把不会写，能玩的就更少了。这种题目不调戏一下冰酱就可惜了。具体是这道题。 这题要求你代码中不能出现fun、{以及}的情况下让定义一个拼接两个字符串的函数。这个要求等同于禁止你使用lambda表达式、函数声明，并且限制你仅用一个表达式完成任务（根据我的理解，是这样的没错）。 那我们来找找有什么现成的有invoke()方法的东西吧。首先想到了反射，但是反射那家伙需要传入接收者作为第一个参数，rua~。既然反射不行，啊，有个更好的东西，看起来完美符合需求。 马上写好代码准备吊打冰酱，然后就是喜闻乐见的辣鸡Kotlin时间，代码如下： val concatString = MethodHandles.lookup().findVirtual(String::class.java, \"concat\", MethodType.methodType(String::class.java, String::class.java)) val str = concatString(\"我永远喜欢\", \"珂朵莉\") as String // Boom！ 然后在Java里写下同样的代码进行测试，嗯，果然是辣鸡Kotlin。 炸裂原因是Kotlin不支持所谓的签名多态性（signature polymorphism），从编译出来的字节码可以看得出来： // kotlin INVOKEVIRTUAL java/lang/invoke/MethodHandle.invoke ([Ljava/lang/Object;)Ljava/lang/Object; // java INVOKEVIRTUAL java/lang/invoke/MethodHandle.invoke (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; 运行时要成功调用该方法的话，字节码中的参数与返回值类型必须与运行时MethodHandle所代表的实际的方法类型一致，否则会抛出WrongMethodTypeException。上面那段Kotlin代码运行时就会抛出这个异常，异常信息为cannot convert MethodHandle(String,String)String to (Object[])Object，正好与上面的字节码相对应。嗯就是这样。 Kotlin编译器现在还不能支持多态签名，而且这将持续很长一段时间（官方人员说了，1.2版本也不会实现这项功能）。 解决方法：辣鸡Kotlin。 2017-10-10最近翻看以前写的旧代码，发现由于Kotlin及其IDEA插件版本更新了，静态检查工具功能增强，检出了一些令人窒息的代码（例如 Check for instance is always ‘true’）。然后我在查看这些乱七八糟的代码时发现了两个问题。 编译器生成了无用的字节码(?)把问题单独抽出来就像是这样： class A&lt;T : Any>(val data: T) class B(val string: String) fun test(a: A&lt;*>) { a.data as B // 注意这行对应的字节码 a.data.string // 这里 a.data 有提示 Smart cast to B } 然后看看编译出的字节码里面都有啥： // 以上省略 L1 LINENUMBER 5 L1 ALOAD 0 INVOKEVIRTUAL A.getData ()Ljava/lang/Object; // a.data DUP IFNONNULL L2 // &lt;============================ 这里进行判空 NEW kotlin/TypeCastException DUP LDC \"null cannot be cast to non-null type B\" INVOKESPECIAL kotlin/TypeCastException.&lt;init> (Ljava/lang/String;)V ATHROW L2 CHECKCAST B // &lt;============================ 不为空则进行类型转换 POP L3 // 以下省略 大致内容就是判断 a.data 是否为 null，如果是 null 就 throw TypeCastException(&quot;null cannot be cast to non-null type B&quot;)。然而根据 A 这个类的定义，其属性 data 必定是非空的。对非空属性进行 null check 岂不是多余？难道说编译器太傻，在分析这种操作时不知道 a.data 是非空的？ 解决方法：加个问号，如下所示： fun test(a: A&lt;*>) { a.data as B? // 加了个问号，变成了B? a.data.string // 注意这里 a.data 同样有提示 Smart cast to B } 这时候字节码就是这样的： // 以上省略 L1 LINENUMBER 5 L1 ALOAD 0 INVOKEVIRTUAL A.getData ()Ljava/lang/Object; // a.data CHECKCAST B // &lt;============================ 直接进行类型转换 POP L2 // 以下省略 这回就没有多余的判空处理了。但是注意代码中的 a.data.string，IDE提示 a.data 能够 Smart cast to B。咦编译器还是蛮聪明的呢！ 检查工具提示可对代码进行负优化(?)这个问题单独抽出来就像这样： class A class B { fun getA(): A = TODO() } fun test(some: Any?): A { return if (some is B) some.getA() else A() // 注意这行 } 然后你可以看到，IDE提示你可以 Replace ‘if’ expression with elvis experssion。如果你让IDE帮你优化，就变成了这样： fun test(some: Any?): A { return (some as? B)?.getA() ?: A() // WTF??? } 不知道你们是怎么想的，至少对于我来说可读性下降，而且很明显生成的字节码也变复杂了。明显是负优化，吧？ 解决方法：@Suppress(&quot;IfThenToElvis&quot;)","raw":null,"content":null,"categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://lgzh1215.github.io/tags/Kotlin/"}]},{"title":"关于此博客，以及博主，还有那些七七八八的事","slug":"about","date":"2017-04-27T03:32:52.000Z","updated":"2017-12-29T10:38:40.128Z","comments":true,"path":"2017/04/27/about/","link":"","permalink":"https://lgzh1215.github.io/2017/04/27/about/","excerpt":"一些碎碎念讲道理，我搭好 Hexo 才发现，如果使用 Jekyll 的话，只要将页面源码 Push 到 Github 上，是可以自动生成页面并发布的。","text":"一些碎碎念讲道理，我搭好 Hexo 才发现，如果使用 Jekyll 的话，只要将页面源码 Push 到 Github 上，是可以自动生成页面并发布的。全栽在 CI 上了（用的是 AppVeyor），首先是太久没用 Git，忘记子模块怎么用了，坑了好久。之后是 Git 一些操作重定向 stdout 到 stderr 导致 PowerShell ISE 报错，于是 CI 那边就挂掉了。然后是 Gitlab 的神奇 Bug，一次 Push 让 CI 那边连续 Build 了 5 次…… 于是 3 天的人生就浪费掉了。其实如果不搞持续集成的话就没那么多事。虽然说结果都一样，但是总感觉有那么点不爽，我特么怎么就选了 Hexo 呢。越想越恼火。不排除以后换成 Jekyll 的可能性，不过主题一定是要换的。 关于博客 ~ The History of RenTou Q：这个博客的名字“人头会社”有什么含义么？ A：没啥，这个只是从我的 QQ 空间那里拿来的（逃 说实话我还专门上了一下万年没打理的 QQ 空间考究了一番，发现原来我的 QQ 空间是叫做 “反补课基地” 的（没错，我忘了）。初中时期补课之风盛行，原本每周都有的双休，补得只剩半天假期。唔，这个 “反补课基地” 就是当时中二病发作的产物。 所谓 “人头”，并不是位于身体最上方部位、由人的颅骨支撑的那个圆滚滚的东西（对不起让你们失望了），而是挂在小卖部外墙上的衣服或杂物。由于当时正值放假前夜，月黑风高，去买零食的3人误认为是人头。于是这项活动「在放假的前一天晚上，前往小卖部采购以庆祝放假」便固定了下来，美名其曰「人头节」，随后便有了「人头会」，可喜可贺。 虽然人头会仅3名成员，但经常与班上其他同学一起庆祝人头节，所谓“独乐乐不如众乐乐”。这被班上另一邪恶组织「精神病院」的院长大人看到了，院长害怕事情变得一发不可收拾，便对人头会施压，试图使其解散。坚毅的人头会成员不惧怕任何威胁，事实证明，看似实力强大的精神病院（十几名成员）实际上却是一盘散沙。高贵的人头会有共同的信仰（放假），有定期的活动（人头节），具有强大的精神凝聚力，不是无所事事的精神病院所能比拟的。 嘻嘻。院长大人别打我~~ 关于我唔，感觉没啥好说的呢。 人头会社三元老之一，精神病院第13号床位所有者。 不务正业的辣鸡。 噫，就这样。 其他这个博客是有评论系统的，看不到的话那应该是被墙了，请使用科学姿势查看。（或者等我换成友言（懒癌不允许我这么做（不！","raw":null,"content":null,"categories":[],"tags":[{"name":"Others","slug":"Others","permalink":"https://lgzh1215.github.io/tags/Others/"}]}]}